{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfe1 Home","text":"Welcome to libhal <p>Warning</p> <p>libhal is still in BETA!</p>"},{"location":"#abstract","title":"Abstract","text":"<p>libhal exists to make hardware drivers \ud83d\ude9a portable, \ud83e\uddbe flexible, \ud83d\udce6 accessible, and \ud83c\udf70 easy to use. libhal seeks to provide a foundation for embedded drivers, allowing those drivers to be used across different processors, microcontrollers, systems, and devices.</p> <p>The design philosophy of libhal is to be:</p> <ol> <li>Multi Targeted</li> <li>Light Weight</li> <li>General</li> <li>Minimalist</li> <li>Safe</li> <li>Tested &amp; Testable</li> <li>Compiled Quickly</li> <li>OS Agnostic</li> </ol>"},{"location":"#the-basics","title":"The Basics","text":"<p>libhal, at its core, is simply a set of interfaces that correspond to hardware devices and peripherals. These interfaces use runtime polymorphism in order to decouple application logic from driver implementation details. This decoupling enables applications to run on any target device that has the necessary components available.</p> <p>A quick example is a blinker program. The required interfaces for such a program is a <code>hal::output_pin</code> for controlling the LED and a <code>hal::steady_clock</code> for keeping time. Now your application takes both of these drivers without having to consider their implementation details and blink and LED at a specified interval.</p> <p>Below is a set of source code to make an application that can work with both the <code>lpc40xx</code> and <code>stm32f10x</code> microcontroller.</p> blinker.cpphardware_map.hppmain.cpplpc40.cppstm32f10.cpp <pre><code>#include &lt;libhal-util/steady_clock.hpp&gt;\n\n#include \"hardware_map.hpp\"\n\nhal::status application(starter::hardware_map&amp; p_map)\n{\nusing namespace std::chrono_literals;\nusing namespace hal::literals;\n\nwhile (true) {\nHAL_CHECK(p_map.led-&gt;level(true));\nHAL_CHECK(hal::delay(*p_map.steady_clock, 500ms));\nHAL_CHECK(p_map.led-&gt;level(false));\nHAL_CHECK(hal::delay(*p_map.steady_clock, 500ms));\n}\n\nreturn hal::success();\n}\n</code></pre> <pre><code>#pragma once\n\n#include &lt;libhal/functional.hpp&gt;\n#include &lt;libhal/output_pin.hpp&gt;\n#include &lt;libhal/steady_clock.hpp&gt;\n\nnamespace starter {\nstruct hardware_map\n{\nhal::output_pin* led;\nhal::steady_clock* steady_clock;\nhal::callback&lt;void()&gt; reset;\n};\n}  // namespace starter\n\n// Application function must be implemented by one of the compilation units\n// (.cpp) files.\nhal::status application(starter::hardware_map&amp; p_map);\nhal::result&lt;starter::hardware_map&gt; initialize_target();\n</code></pre> <pre><code>#include \"hardware_map.hpp\"\n\nint main()\n{\nauto init_result = initialize_target();\n\nif (!init_result) {\nhal::halt();\n}\n\nauto hardware_map = init_result.value();\nauto is_finished = application(hardware_map);\n\nif (!is_finished) {\nhardware_map.reset();\n} else {\nhal::halt();\n}\n\nreturn 0;\n}\n\nnamespace boost {\nvoid throw_exception([[maybe_unused]] std::exception const&amp; p_error)\n{\nstd::abort();\n}\n}  // namespace boost\n</code></pre> <pre><code>#include &lt;libhal-armcortex/dwt_counter.hpp&gt;\n#include &lt;libhal-armcortex/startup.hpp&gt;\n#include &lt;libhal-armcortex/system_control.hpp&gt;\n\n#include &lt;libhal-lpc40/output_pin.hpp&gt;\n\n#include \"hardware_map.hpp\"\n\nhal::result&lt;starter::hardware_map&gt; initialize_target()\n{\nhal::cortex_m::initialize_data_section();\nhal::cortex_m::system_control::initialize_floating_point_unit();\n\nauto&amp; led = HAL_CHECK((hal::lpc40xx::output_pin::get&lt;1, 18&gt;()));\n\nreturn starter::hardware_map{\n.led = &amp;led,\n.steady_clock = &amp;counter,\n.reset = []() { hal::cortex_m::system_control::reset(); },\n};\n}\n</code></pre> <pre><code>#include &lt;libhal-armcortex/dwt_counter.hpp&gt;\n#include &lt;libhal-armcortex/startup.hpp&gt;\n#include &lt;libhal-armcortex/system_control.hpp&gt;\n\n#include &lt;libhal-stm32f10x/output_pin.hpp&gt;\n\n#include \"hardware_map.hpp\"\n\nhal::result&lt;starter::hardware_map&gt; initialize_target()\n{\nhal::cortex_m::initialize_data_section();\n\nauto&amp; led = HAL_CHECK((hal::stm32f10x::output_pin::get&lt;'C', 13&gt;()));\n\nreturn starter::hardware_map{\n.led = &amp;led,\n.steady_clock = &amp;counter,\n.reset = []() { hal::cortex_m::system_control::reset(); },\n};\n}\n</code></pre>"},{"location":"#support","title":"Support","text":"<ul> <li>libhal discord server (preferred)</li> <li>GitHub issues</li> <li>Cpplang Slack #embedded channel</li> </ul>"},{"location":"#distribution","title":"Distribution","text":"<ul> <li>Conan package manager</li> <li>Source code is hosted on GitHub</li> <li>vcpkg (coming soon) package manager</li> </ul> <p>There are plans to support to more C++ package managers</p>"},{"location":"about/","title":"About","text":"<p>The world of embedded systems is written almost entirely in C and C++. More and more of the embedded world move away from C and towards C++. This has to do with the many benefits of C++ such as type safety, compile time features, meta-programming, multi-paradigm and much more. When these features are used correctly, they can result in smaller binary sizes and higher performance code than in C.</p> <p>But a problem that embedded C++ software suffers is that there isn't a consistent and common API for embedded libraries. Looking around, you will find that each hardware vendor has their own set of libraries and tools for their specific products. If you write a driver on top of their libraries, you will find that your code will only work for that specific platform/product. In some cases you may also be limited to just their toolchain. You as the developer are locked in to this one specific setup. And if you move to another platform, you must do the work of rewriting all of your code again.</p> <p>libhal seeks to solve this issue by creating a set of generic interfaces for embedded system concepts such as serial communication (UART), analog to digital conversion (ADC), inertial measurement units (IMU), pulse width modulation (PWM) and much more. The advantage of building a system on top of libhal is that higher level drivers can be used with any target platform whether it is a stm32, a nxp micro controller, a RISC-V, or is on an embedded linux.</p> <p>This project is inspired by the work of Rust's embedded_hal and follows many of the same design goals.</p> <p>libhal's design goals:</p> <ol> <li>Serve as a foundation for building an ecosystem of platform agnostic drivers.</li> <li>Must abstract away device specific details like registers and bitmaps.</li> <li>Must be generic across devices such that any platform can be supported.</li> <li>Must be minimal for boosting performance and reducing size costs.</li> <li>Must be composable such that higher level drivers can build on top of these.</li> <li>Be accessible through package mangers so that developers can easily pick and    choose which drivers they want to use.</li> </ol>"},{"location":"about/#software-copyrights","title":"Software Copyrights","text":"<p>This source code is licensed under the Apache License 2.0 as described in the LICENSE file.</p>"},{"location":"about/#third-party-library-licenses","title":"Third Party Library Licenses","text":"<ul> <li>Boost.LEAF, BOOST license</li> <li>tl-function-ref/1.0.0, CC0</li> </ul>"},{"location":"architecture/","title":"\ud83c\udfd7\ufe0f Architectural Design Decisions","text":""},{"location":"architecture/#a1-always-use-modern-c","title":"A.1 Always use modern C++","text":"<p>libhal uses the modern C++. Meaning that libhal is will follow the most modern and available compilers available. When a sufficient number of features have become available in both GCC &amp; Clang and are determined to be useful to libhal libhal will increment its major number to indicate that it has upgraded compiler versions.</p> <p>This decision exists to escape the issues of vendor and toolchain lock in thats prevalant in the C++ and embedded industry. With sufficient testing, upgrading compilers shouldn't result in bugs in applications.</p>"},{"location":"architecture/#a2-interface-design-choices","title":"A.2 Interface Design Choices","text":"<p>Interfaces MUST follow this layout:</p> <ul> <li>Use <code>#pragma once</code> at the start of the file: Simpler than an include guard</li> <li>All <code>virtual</code> functions must be private &amp; each <code>virtual</code> functions is   accompanied by a public API that is used to call the virtual API</li> <li>The return type of each API MUST be a <code>result&lt;T&gt;</code> where <code>T</code> is a structure.</li> </ul> <p>Pragma once is needed to ensure files are included once. Its also less error prone then hand writing include guards.</p> <p>The reasons for a private virtual with public API can be found in this article.</p> <p>Returning a structure for each API means that, in the future, if the return type needs to be extended, it can be done without breaking down stream libraries. For example:</p> <pre><code>class adc {\nstruct read_t { // V1\nfloat percentage;\n};\nstruct read_t { // V2\nfloat percentage;\n// Optional field that is default initialized to std::nullopt indicating\n// that it defaults to not exist\nstd::optional&lt;uint8_t&gt; bit_resolution = std::nullopt;\n};\n};\n</code></pre> <p>Given that the field <code>bit_resolution</code> is an optional, code looking for it can determine if it is available or not, and code that never used it can ignore it.</p>"},{"location":"architecture/#a21-no-utility-methods-in-interfaces-ufcs","title":"A.2.1 No utility methods in interfaces (UFCS)","text":"<p>Utility functions shall not exist in interface definitions. For example, <code>hal::i2c</code> could have a <code>hal::i2c::write()</code> and <code>hal::i2c::read()</code> function implemented in its interface.</p> <p>This has the effect of reducing the number of headers in the interface files and dependencies. This, in turn, results in an interface that is minimal, clean, and simple.</p> <p>The major purpose of this is to keep compile times down as much possible for each interface. This also ensures that the \"pay-for-what-you-use\" model is followed. No need to pay for a utility you never planned to use.</p> <p>The final reason is in preparation for UFCS (Unified Function Call Syntax). UFCS is a proposal for C++23 and C++26. It did not get into C++23 but is slated for review in 26. For more details see this page What is unified function call syntax anyway?.</p>"},{"location":"architecture/#a3-using-tweak-files-over-macros","title":"A.3 Using tweak files over macros","text":"<p>Tweak files were used as an alternative to MACROS. MACROs can be quite problematic in many situations and are advised against in the core C++ guidelines. The benefits of tweak files can be found here.</p>"},{"location":"architecture/#a4-header-only-implementations-see-amendment-a21","title":"~~A.4 Header Only Implementations~~ (See amendment A.21)","text":"<p>libhal libraries and drivers are, in general, header-only. libhal uses header only implementations in order to enable the broadest set of package managers, build system and projects to use it.</p> <p>The strongest reason for a header-only approach is due to the fact that libhal libraries never intend to be distributed in prebuilt binaries. Conan is designed to ship with prebuilt binaries or build against the host machine. These settings can be altered, but you still end up with a single global prebuilt binary for a driver does not make sense when that driver could be used in a variety of environments such as the host device for host side tests, a specific target device, and a target device that is in the family of that specific target device.</p> <p>For example, lets consider liblpc40xx. If you are building to target the lpc4078 chip then that prebuilt ought to be built with usage of FPU registers enabled. But if you use that same prebuilt with the lpc4074, you'll find that the program crashes because the 74 variant does not have an FPU. You can attempt make a prebuilt binary for ever possible build variation that an embedded engineer may want, but you'll always come up short. The better approach is to simply build the library each time, thus ensuring that the build flags are considered each time.</p> <p>If compile-times are a concern, there are reasonably easy methods for managing this. See Handling Long Compile Times.</p>"},{"location":"architecture/#a5-encapsulated-memory-mapped-classes","title":"A.5 Encapsulated Memory Mapped Classes","text":"<p>Target drivers that use Memory-Mapped-IO usually come with a vendor generated header file that describes each peripheral as a structure type, along with bit mask MACROs, and MACROs that result in pointers to each peripheral in memory. The main problem using these headers files causes is naming conflicts. Many of these vendor generated headers work with both C and C++. Meaning that namespaces are not utilized. And many do not expect that they will be used in an environment where another vendor generated header file will exists. So no care is taken to ensure that the names of the types are unique. This WILL cause linker errors as the linker sees both <code>GPIO_TypeDef</code> from an STM library and <code>GPIO_TypeDef</code> from an LPC library that aren't the same.</p> <p>Because of this we have style S.x Encapsulated Memory Mapped classes guideline.</p>"},{"location":"architecture/#a6-using-halfunction_ref-over-stdfunction","title":"A.6 Using hal::function_ref over std::function","text":"<p><code>std::function</code> has all of the flexibility and functionality needed, but it has the potential to allocate and requires potentially expensive copy operations when passed by value.</p> <p><code>hal::function_ref</code> is a non-owning version of the <code>std::function</code>, with a size of just two pointers. <code>hal::function_ref</code> fits most use cases in that class functions that take them only need them for the duration of the function and do not need to own them for later.</p> <p>!!! info <code>hal::function_ref</code> is an alias for <code>tl:function_ref</code> which comes from     the project     TartanLlama/function_ref.</p>"},{"location":"architecture/#a7-using-virtual-runtime-polymorphism","title":"A.7 Using <code>virtual</code> (runtime) polymorphism","text":"<p>Polymorphism is critical for libhal to reach the goals of flexible and easy of use. Static based polymorphism, by its nature, is inflexible at runtime and can be quite complicated to work with.</p> <p>Runtime polymorphism, or the usage of <code>virtual</code> enables a broader scope of flexibility and isolation between drivers and application logic. The only downside to using <code>virtual</code> polymorphism is the cost of a virtual function call. But the actual cost of making a virtual function call is usually tiny in comparison to the work performed in the actual API call. In most cases the call latency and lack of inlining of a virtual call isn't an important factor in most applications.</p> <p>And over all, along with the broad amount of flexibility comes the ease of use. Virtual polymorphism for interfaces is very easy to perform and has a ton of language support.</p>"},{"location":"architecture/#a8-strongly-leverage-package-managers","title":"A.8 Strongly Leverage Package Managers","text":"<p>Finding and integration libraries into C++ programs is a pain. Doing the same thing for embedded is doubly so, especially if there is vendor IDE lock in. libhal seeks to escape this by using the available package managers and indexes.</p> <p>Libhal was designed around and split up into parts that each come together via these package managers. The purpose of this design is to achieve:</p> <ul> <li>Stable version and release control for each library</li> <li>Can be easily found the indexes</li> <li>Ease of integration</li> </ul>"},{"location":"architecture/#a9-foundation-interface-stability","title":"A.9 Foundation &amp; Interface Stability","text":"<p><code>libhal-util</code>, <code>libhal-mock</code> and <code>libhal-soft</code> were all apart of <code>libhal</code> originally, but due to the constant changes and API breaks in those categories of code, the version number of <code>libhal</code> would increment constantly, shifting the foundation of the ecosystem. To prevent constant churn and API breaks <code>libahl</code> was split into those 4 libraries.</p> <p>The goal is to keep the version number for <code>libhal</code> constant for long periods of time to prevent breaking down stream libraries, drivers, and applications.</p>"},{"location":"architecture/#a10-libhal-driver-directory","title":"A.10 libhal driver directory","text":"<p>One of the libhal repos will contain a directory of libhal libraries that extend it along with which interfaces it implements and what type of library it is.</p> <p>Official libhal libraries must go into the directory. Developers outside of the libhal organization can also contribute to and opt into this directory by making a PR to the repo containing the directory.</p> <p>The purpose of this is to make finding and exploring the available set of drivers easier for the end developer by having them all in one place.</p>"},{"location":"architecture/#a11-github-actions-remote-workflows","title":"A.11 Github Actions &amp; Remote Workflows","text":"<p>libhal uses github and github action \"workflow_dispatch\" to allow other repos to reuse libhal's continuous integration steps. The actions are configurable via input parameters to allow libraries to customize and control how the CI works.</p> <p>libhal's CI attempts to use as many tools as reasonable to make sure that the C++ source code follows the style guide, C++ core guidelines and retains a certain level of quality. All offical libhal libaries must opt in to the common libhal/libhal workflow.</p> <p>This helps to ensure that all projects are held to the same standard and quality. The workflow files can be found in <code>libhal/libhal/.github/workflows</code>.</p>"},{"location":"architecture/#a12-boostut-as-our-unit-testing-framework","title":"A.12 Boost.UT as our unit testing framework","text":"<p>Boost.UT was chosen for its lack of macros, stunning compile time performance, and its ease of use.</p>"},{"location":"architecture/#a13-boostleaf-for-error-handling","title":"A.13 Boost.LEAF for error handling","text":"<p>One major issue with any project is handling errors. Because the <code>libhal</code> interfaces can be used in such broad environments, it is hard to determine what the BEST error type in advance could work for all users. Some use error codes, some use <code>std::expected&lt;T, E&gt;</code>, and some use exceptions.</p> <p>Error codes are problematic as they tend to lack details and context around an error. Sometimes the documentation along with the error code provides all of the necessary context, but many times more context is needed.</p> <p><code>std::expected&lt;T, E&gt;</code> seems like a better alternative to error codes, but... is it really? What should <code>E</code> be? An error code? What if we have it be an error code and a const string. What if we want a file name and function name? What about a line number? What about 16 bytes for holding context information about the error? That should be enough, right? What about- what about- what about? ... wait, how big is this error type? 32 bytes? Wasn't this supposed to be light weight? Unfortunately, <code>std::expected</code> is not a good choice for interfaces with extremely broad and unknowable of error states. This forces the error type to be massive to accommodate everything and everyone.</p> <p>Exceptions somewhat fix this issue but are still lacking. The benefit of exceptions is that you can throw just about anything, meaning the developer can provide loads of information in the thrown object. But exceptions fail on 4 counts:</p> <ul> <li>Exceptions tend to not be available for embedded systems, either due to a     toolchain not compiling with them enabled or because a project has strict     requirements that forbid exceptions.</li> <li>When exceptions do occur, the amount of time it takes to reach its catch can     take a long time, longer than what real time applications can handle.</li> <li>Normally requires heap allocation</li> <li>Exceptions can only throw one type and the cost of those thrown exceptions     are always paid for.</li> </ul> <p>Boost.LEAF has the following properties:</p> <ul> <li>Portable single-header format, no dependencies.</li> <li>Tiny code size when configured for embedded development.</li> <li>No dynamic memory allocations, even with very large payloads.</li> <li>Deterministic unbiased efficiency on the \"happy\" path and the \"sad\" path.</li> <li>Error objects are handled in constant time, independent of call stack depth.</li> <li>Can be used with or without exception handling.</li> <li>Can throw more than 1 error at a time</li> </ul> <p>All of these features are critical for libhal to have the performance for real time applications.</p> <p>The last feature is important for debugging, bug reports, and context specific error handling. Boost.LEAF gives the driver the choice to emit several error types and allows the user to pick out which one they would like to opt to catch if any of them. This can be used to capture an error code as well as s snapshot of the register map of a peripheral, the object's current state or even a debug message.</p>"},{"location":"architecture/#a14-using-statement-expressions-with-hal_check","title":"A.14 Using Statement Expressions with <code>HAL_CHECK()</code>","text":"<p><code>HAL_CHECK()</code> is the only MACRO in <code>libhal</code>. It exists because there is nothing like Rust's <code>?</code> operator which either unwraps a value or returns an error from the current function. The \"Statement Expression\" only works with GCC &amp; Clang which is one of the reasons why <code>libhal</code> only supports those compilers. Compare the following two expressions:</p> <pre><code>// 1. Using statement expressions\nauto percentage = HAL_CHECK(adc.read()).percentage;\n\n// 2. Without using statement expressions\nHAL_CHECK(adc_read_temporary, adc.read());\nauto percentage = adc_read_temporary.percentage;\n</code></pre> <p>The second option looks very unnatural and require explanation. On the other hand users who have never seen <code>HAL_CHECK()</code> in action have an immediate idea of how it works in the first section of the code. Portability to other compilers was sacrificed in order to make the code easier to read, understand, and write.</p>"},{"location":"architecture/#a15-libhal-will-not-use-fixed-point","title":"A.15 <code>libhal</code> WILL NOT use fixed point","text":"<p>Because fixed point will NOT result in better performance or space savings compared to SOFTWARE floating point. Team did venture to use fixed point throughout the entire code base and when we felt that the fixed point code reached a point where it was usable everywhere, we benchmarked it and got these:</p> <pre><code>double_time            = 8921794\n[i64 +Round]fixed_time = 4558238 (best fixed point option)\n[soft]float_time       = 1424913\n[i64 -Round]fixed_time = 1410720 (precision issues)\n[i32 +Round]fixed_time = 815107  (will easily overflow)\n[hard]float_time       = 110089  (not always available)\n[i32 -Round]fixed_time = 95085   (will not actually work)\n</code></pre> <p>Here is an old gist of the example: kammce/fixed_v_float.cpp</p> <p>The above metrics were for a program that run a map function to map an input number from one range to another range. The numbers on the right hand side are the number of cycles of a Arm Cortex M4F DWT counter. Fixed point 32-bit integers is enough for a representation but to handle arithmetic like multiplication, 64-bit integers were needed. Those 64-bit operations resulted in computation time approaching double floating point. If a system used 32-bit floats, the 32-bit fixed point would be ~4x slower. If a system used double floating point in software mode, it will only be ~2x slower than 32-bit fixed point. Fixed point, over all, is more expensive in terms of space and time.</p> <p>If you don't believe the metrics measured here, you can also check fpm performance metrics. Notice how fpm fairs far worse for anything that isn't addition/subtraction.</p> <p>See these articles for more details:</p> <ul> <li>You're Going To Have To   Think!</li> <li>WHY FIXED POINT WON'T CURE YOUR FLOATING POINT   BLUES</li> <li>WHY RATIONALS WON\u2019T CURE YOUR FLOATING POINT   BLUES</li> <li>Why Computer Algebra Won\u2019t Cure Your Floating Point   Blues</li> <li>Why Interval Arithmetic Won\u2019t Cure Your Floating Point   Blues</li> </ul>"},{"location":"architecture/#a16-libhal-does-not-use-a-units-library","title":"A.16 <code>libhal</code> does NOT use a units library","text":"<p>Unit libraries have the potential to really help prevent an entire category of unit based errors, it is also extremely difficult and annoying to use.</p> <p>Th article Unit of measurement libraries, their popularity and suitability goes into detail about the usability issues faced by unit libraries. Because, at the time of writing <code>libhal</code> there is not a unit library that is easy to use and concise, <code>libhal</code> decided to simply stick with 32-bit floats and helper UDLs.</p>"},{"location":"architecture/#a17-always-return-halresultt-from-every-api","title":"A.17 Always return <code>hal::result&lt;T&gt;</code> from every API","text":"<p>Every interface in libhal returns a <code>hal::result&lt;T&gt;</code> type.</p> <p>The return types should be a <code>result&lt;T&gt;</code> because the implementation could be an abstraction for anything. As an example, it could come from an I2C to PWM generator and if something goes wrong with the i2c communication, the information must be emitted from the function.</p>"},{"location":"architecture/#a18-using-inplace_functionhalcallback-for-interrupt-callbacks","title":"A.18 Using <code>inplace_function</code>/<code>hal::callback</code> for interrupt callbacks","text":"<p>There are interfaces such as <code>hal::can</code>, <code>hal::interrupt_pin</code>, and <code>hal::timer</code> that all have APIs for setting a callback.</p> <p>Because those callbacks could be lambdas, function objects, pure functions, or other callable types, we need a polymorphic type erased function type that can take any callable type as input and call it when its <code>operator()</code> is called.</p> <p>The options for these callbacks are:</p> <ul> <li><code>std::function</code><ul> <li>PROS<ul> <li>Part of the standard library</li> <li>Can take any callable type without restrictions</li> </ul> </li> <li>CONS<ul> <li>Allocating (compiler implementations will use SBO but the size of   those buffers are not specified in the standard and should not be   relied upon)</li> <li>Can be quite large in size (40 bytes on 32-bit arm)</li> </ul> </li> </ul> </li> <li><code>function_ref</code><ul> <li>PROS<ul> <li>Very lightweight (very fast construction)</li> <li>Very small size (2 pointers in size)</li> </ul> </li> <li>CONS<ul> <li>For this to work as a callback, the callable passed to the   <code>function_ref</code> must have a lifetime that is greater than the object   implementing the interface.</li> </ul> </li> </ul> </li> <li><code>inplace_function</code><ul> <li>PROS<ul> <li>Works and behaves just like <code>std::function</code></li> </ul> </li> <li>CONS<ul> <li>Fixed callable size limit</li> </ul> </li> </ul> </li> </ul> <p><code>std::function</code> is automatically out because it is allocating. Using <code>std::function</code> for any interface API would ensure that applications that disallow dynamic allocations after boot or in general could never use them.</p> <p><code>function_ref</code> has two great PROS but the largets CON is lifetime issues that are really easy to fall into. Specifically something like this:</p> <pre><code>obj.on_event([&amp;single_capture]() {\n// does a thing  ...\n});\n</code></pre> <p>The lambda is actually a temporary! So after this call it is out of scope and no longer exists. If the reference to temporary is stored and called later, the code WILL suffer from a \"stack use after scope\" violation which is undefined behavior.</p> <p><code>inplace_function</code> has all of the features of <code>std::function</code> but with limited size. Due to this, constructing an <code>inplace_function</code> is deterministic and relatively light weight.</p>"},{"location":"architecture/#a19-halcallback-sizing","title":"A.19 <code>hal::callback</code> sizing","text":"<p><code>hal::callback</code> is an alias to <code>inplace_function</code> with a buffer size of 2 pointers (<code>sizeof(std::intptr_t) * 2</code>). This size was chosen in order to be small and easily storable. Two pointers worth of size should be enough to hold a pointer to <code>this</code> in classes as well a pointer to some sort of state object.</p> <p>The size of the callback object was not choosen in order to improve the performance of calling callback setting class functions. Even with the small size of <code>hal::callback</code>, its too large to take advantage of register based parameter passing. Thus the size of 2 pointers was mostly to help in keeping the memory footprint of the <code>callback</code> small. In most cases, setting an callback is something that is either done once or done very infrequently, and thus does not get much of a benefit from higher performance function calls.</p>"},{"location":"architecture/#a20-why-functions-that-setup-events-do-not-return-halstatus","title":"A.20 Why functions that setup events do not return <code>hal::status</code>","text":"<p>Functions like <code>hal::can::on_receive()</code> and <code>hal::interrupt_pin::on_trigger()</code> return void and not <code>hal::status</code> like other APIs. Thus these functions cannot return an error and are considered \"infallible\". There infallibility guarantee makes constructing drivers using these interfaces easier. It also eliminates the need for drivers to concern themselves with handling errors from these APIs.</p> <p>This guarantee is easily made, because having any one of these APIs fail IS A bug and not something that a developer should or could be responsible with handling. These APIs MUST be implemented as target library peripheral drivers because setting interrupts is something that only target and processor libraries can do. Setting up and configuring interrupts is only possible if the processor supports it. Being apart of a target library means that they know exactly the set of possible configurations that are allowed. This also means that constructing a target peripheral with interrupt customization can be include compile time checks as well.</p>"},{"location":"architecture/#a21-critical-importance-of-providing-prebuilt-binaries","title":"A.21 Critical importance of providing prebuilt binaries","text":"<p>This amends architectural component A.4 and pivots away from header only libraries over to prebuilt binaries. This amendment explains the new direction as well as why A.4 was originally part of the architecture.</p> <p>Coming soon ...</p>"},{"location":"glossary/","title":"\ud83d\udcc3 Learning the Terms","text":"<p>Here is a list of terms used in libhal. It is HIGHLY RECOMMENDED that new users of libhal read this section.</p>"},{"location":"glossary/#targets","title":"Target(s)","text":"<p>Targets are defined as MCUs (micro-controllers), SOCs (system-on-chip), operating systems, or operating systems running on a particular SBC (single-board-computer).</p> <p>The following are examples:</p> MCUAPOSSOC <ul> <li>LPC40xx series family of MCUs</li> <li>STM32F10x series family of MCUs</li> <li>RP2040</li> </ul> <ul> <li>Broadcom BCM2836 SoC (Raspberry Pi)</li> <li>Samsung Exynos5422 (Odroid)</li> <li>TI AM335x Sitara</li> </ul> <ul> <li>Linux</li> <li>Windows CE</li> </ul> <ul> <li>Raspberry Pi</li> <li>ODROID UX</li> <li>BeagleBone Black</li> </ul>"},{"location":"glossary/#interfaces","title":"Interface(s)","text":"<p>Interfaces are the basic building blocks of libhal and enable the flexibility needed to be portable and flexible.</p> <p>An interface is a contract of functions that an implementing class must adhere to. Documentation for each interface API explain the expected behavior that each function should have on hardware regardless of the implementation.</p> <p>Any software that implements (inherits) an interface must provide implementations for each function in the interface, otherwise the compiler will generate a compiler error.</p> <p>In libhal each interface corresponds to a type of hardware peripheral or device such as:</p> <ul> <li><code>hal::output_pin</code> &amp; <code>hal::input_pin</code>: Digital I/O (input/output pins)</li> <li><code>hal::adc</code>: Analog to digital converter</li> <li><code>hal::pwm</code>: Pulse width modulation (pwm)</li> <li><code>hal::spi</code>: Serial peripheral interface (spi)</li> <li><code>hal::serial</code>: Universal asynchronous receiver transmitter (serial/uart)</li> <li><code>hal::accelerometer</code>: Accelerometer</li> </ul>"},{"location":"glossary/#driver-types","title":"Driver Types","text":"PeripheralDeviceSoft <p>Peripheral drivers are drivers for a target that is embedded within the device and therefore cannot be removed from the chip and is fixed in number.</p> <ul> <li>Example: A digital output and input pin</li> <li>Example: 1 of 5 hardware timers within a micro-controller</li> <li>Example: Integrated analog-to-digital converter</li> </ul> <p>Device drivers are drivers for devices external to a target. In order to communicate with such a device the target must have the necessary peripherals and peripheral drivers to operate correctly.</p> <ul> <li>Example: an accelerometer driver for the mpu6050</li> <li>Example: a memory storage driver for a at581 flash memory</li> <li>Example: a black and white pixel display</li> </ul> <p>Soft drivers are drivers that do not have any specific underlying hardware associated with them. They are used to emulate, give context to, or alter the behavior of interfaces. For a driver to be a soft driver it must implement or have a way to generate, construct or create implementations of hardware interfaces.</p> <p>Emulation Example</p> <ul> <li>Emulate spi by using 2 output pins and 1 input pin.</li> <li>Emulate uart transmission with a 16-bit spi driver and some clever bit   positioning.</li> </ul> <p>Context Example</p> <ul> <li>Implement a rotary encoder by using an adc, a potentiometer and some   specification of the potentiometer like min and max angle, along with min and   max voltage.</li> <li>Implement a dac using multiple output pins and a set of resistors and an op   amp.</li> </ul> <p>Alteration example</p> <ul> <li>Implement an input pin that inverts the readings of an actual input pin</li> <li>Implement an i2c driver that is thread safe by taking an i2c and locking   mechanism provided by the user.</li> </ul> <p>In general, software drivers tend to incur some overhead so nesting them deeply will effect performance.</p>"},{"location":"glossary/#processes","title":"Processes","text":"<p>A process is code that performs some work. Like an application on a desktop machine.</p>"},{"location":"glossary/#off-interface-function","title":"Off Interface Function","text":"<p>Off Interface functions are public class functions that a driver can have that is beyond what is available for the interface it is implementing. These functions usually configure a peripheral or device in a way that is outside the scope of the implementing interface. For peripherals these are platform specific. For drivers these are device specific features. Examples of such specific functions are as follows:</p> <ul> <li>An output pin driver with a high drain current mode</li> <li>An input pin driver with support for inverting the voltage level of what it   reads in hardware.</li> <li>Enabling/disabling continuous sampling from an accelerometer where sampling   continuously would make reading samples faster but would consume more power   and disabling continuous sampling would do the opposite.</li> </ul>"},{"location":"glossary/#types-of-libraries","title":"Types of Libraries","text":"targetutilitydeviceapplication <p>Target libraries contain the driver implementations for specific targets. Every application that uses libhal will need one of these libraries in order to work on any hardware. Without such libraries, the device could run an application, but couldn't interact with the world.</p> <p>Utility libraries are purely software libraries that help to either make performing some work on a device easier for the developer or help to organize and bring structure to an application.</p> <p>Device libraries are libraries containing drivers for specific hardware devices or module, such as a sensor, display or a motor controller. They are, generally, target agnostic and should be usable on any system that can support its interface, memory, and performance requirements.</p> <p>An application library is a full application that can be used as part of another application library or project.</p>"},{"location":"philosophy/","title":"\ud83d\udcdc Design Philosophy","text":"<p>These are the core design tenets that <code>libhal</code> and libraries extending it must seek to achieve with every design choice, line written, and architecture change made.</p>"},{"location":"philosophy/#d1-multi-targeted","title":"D.1 Multi Targeted","text":"<p><code>libhal</code> and the libraries that extend it, should work anywhere. So long as the appropriate compiler or cross compiler is used, the driver should do as it is intended. The exception is <code>target</code> libraries which are designated to execute for a particular target. Even so, those <code>target</code> libraries MUST be unit testable on any host machine.</p>"},{"location":"philosophy/#d2-light-weight","title":"D.2 Light Weight","text":"<p><code>libhal</code> should keep its interfaces and utility code light weight, meaning such things do not allocate, and if they do only once, do not perform long/length copies, unless a copy was the desired operation,</p>"},{"location":"philosophy/#d3-general","title":"D.3 General","text":"<p><code>libhal</code> interfaces should be general, meaning that they do not include APIs, or configuration settings that are uncommon in most targets or specific to a particular target.</p>"},{"location":"philosophy/#d4-minimalist","title":"D.4 Minimalist","text":"<p><code>libhal</code> aims to be as simple as possible and no simpler. Interfaces, utility functions, and libraries should be straight forward for most programmers to understand with added complexity only when it is necessary and no other options exist.</p>"},{"location":"philosophy/#d5-safe","title":"D.5 Safe","text":"<p><code>libhal</code> and its style guide aim to use patterns and techniques that help reduce safety issues. Safety does NOT extend to runtime checks that determine if there exists architectural defects.</p>"},{"location":"philosophy/#d6-tested-testable","title":"D.6 Tested &amp; Testable","text":"<p><code>libhal</code> code should be as testable and unit tested.</p>"},{"location":"philosophy/#d7-compiled-quickly","title":"D.7 Compiled Quickly","text":"<p><code>libhal</code> code should build fast and eliminate/replace any unnecessary dependencies that cause compile times to be long.</p>"},{"location":"philosophy/#d8-portable","title":"D.8 Portable","text":"<p><code>libhal</code> code should not require or depend on any OS or target specific code or behaviors. <code>libhal</code> is designed to work anywhere and should not rely on OS.</p>"},{"location":"prerequisites/","title":"\ud83e\uddf0 Install Prerequisites","text":"<p>What you will need in order to get started with libhal.</p> <ul> <li><code>make</code>: latest available version</li> <li><code>cmake</code>: 3.15 or above</li> <li><code>python</code>: 3.10 or above</li> <li><code>conan</code>: 1.57.0</li> <li>Suitable Compiler for running host tests (can be either of these):<ul> <li><code>gcc</code>: 11.3.0 or above</li> <li><code>clang</code>: 14 and above</li> </ul> </li> </ul> Ubuntu 22.04Ubuntu 20.04MacOS XWindows <p>Python 3.10 is default installed, no need to install it.</p> <p>Install GCC and build essentials:</p> <pre><code>sudo apt update &amp;&amp; sudo apt upgrade\nsudo add-apt-repository -y ppa:ubuntu-toolchain-r/test\nsudo apt install -y build-essential g++-11\n</code></pre> <p>Installing conan &amp; cmake:</p> <pre><code>python3 -m pip install \"conan&gt;=2.0.6\" cmake\n</code></pre> <p>Install python3.9:</p> <pre><code>sudo apt-get install python3.9\n</code></pre> <p>Install GCC and build essentials:</p> <pre><code>sudo apt update &amp;&amp; sudo apt upgrade\nsudo add-apt-repository -y ppa:ubuntu-toolchain-r/test\nsudo apt install -y build-essential g++-11\n</code></pre> <p>Installing conan &amp; cmake:</p> <pre><code>python3.9 -m pip install \"conan&gt;=2.0.6\" cmake\n</code></pre> <p>Install Homebrew:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Install latest version of Python 3.x:</p> <pre><code>brew install python\n</code></pre> <p>Install conan &amp; cmake:</p> <pre><code>python3 -m pip install \"conan&gt;=2.0.6\" cmake\n</code></pre> <p>Install Rosetta (only required for M1 macs):</p> <pre><code>/usr/sbin/softwareupdate --install-rosetta --agree-to-license\n</code></pre> <p>Rosetta necessary for intel based cross compilers:</p> <p>We recommend using the <code>choco</code> package manager for windows as it allows easy installation of tools via the command line.</p> <p>To install <code>choco</code>, open PowerShell as an administrator and run the following command:</p> <pre><code>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n</code></pre> <p>Tip</p> <p>If the <code>choco</code> command doesn't work after running this script try closing and opening again PowerShell.</p> <p>Now install <code>python</code>:</p> <pre><code>choco install python\n</code></pre> <p>Install <code>gcc</code> via the <code>mingw</code>:</p> <pre><code>choco install mingw\n</code></pre> <p>Install <code>make</code> for cmake:</p> <pre><code>choco install make\n</code></pre> <p>Installing conan &amp; cmake:</p> <pre><code>python3 -m pip install -U \"conan&gt;=2.0.6\" cmake\n</code></pre>"},{"location":"prerequisites/#setting-up-conan","title":"Setting up Conan","text":"<p>First lets create a default profile:</p> <pre><code>conan profile detect --force\n</code></pre>"},{"location":"prerequisites/#add-libhal-trunk-repository-to-conan-remotes","title":"Add <code>libhal-trunk</code> repository to conan remotes","text":"<p>This allows conan to search for packages in the <code>libhal-trunk</code> repository, which is updated with every change to the libhal organizations code base.</p> <pre><code>conan remote add libhal-trunk https://libhal.jfrog.io/artifactory/api/conan/trunk-conan\n</code></pre>"},{"location":"prerequisites/#profile-setting-for-gcc-11-users","title":"Profile setting for GCC 11 users","text":"Intel LinuxARM64 LinuxM1 MacIntel MacIntel WindowsARM64 Windows <p>If your host machine is using an intel core processor as its CPU then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/x86_64/linux/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>It is less likely your host desktop is an ARM64. This section is mostly for building applications and tests on a Raspberry PI or other SBC. But if you do have a laptop powered by an ARM64 core, then this is the correct configuration for you.</p> <pre><code>conan config install -sf profiles/armv8/linux/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If your macbook uses an M1 processor then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/armv8/mac/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If your macbook uses an Intel processor then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/x86_64/mac/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If your windows machine uses an Intel processor then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/x86_64/windows/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If you have a modern surface laptop with ARM64, then this may be the right choice for you.</p> <pre><code>conan config install -sf profiles/armv8/windows/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre>"},{"location":"prerequisites/#install-setting_useryml","title":"Install setting_user.yml","text":"<p>This installs the libhal <code>settings_user.yml</code> which extends the architectures of conan's <code>settings.yml</code> file to include baremetal architectures. These additional architecture definitions are required for MOST libhal applications.</p> <pre><code>conan config install -sf profiles/baremetal https://github.com/libhal/conan-config.git\n</code></pre>"},{"location":"style/","title":"\ud83c\udfa8 Style Guide","text":""},{"location":"style/#s0-code-guidelines","title":"S.0 Code Guidelines","text":"<p>All guides follow the C++ Core Guidelines.</p>"},{"location":"style/#s1-formatting","title":"S.1 Formatting","text":"<ul> <li>Code shall follow libhal's   <code>.clang-format</code>   file, which uses the Mozilla C++ style format as a base with some adjustments.</li> <li>Code shall follow libhal's   <code>.naming.style</code>   file, which is very similar to the standard library naming convention:</li> <li>CamelCase for template parameters.</li> <li>CAP_CASE for MACROs (avoid MACROs in general).</li> <li>lowercase snake_case for everything else.</li> <li>prefix <code>p_</code> for function parameters.</li> <li>prefix <code>m_</code> for private/protected class member.</li> <li>Refrain from variable names with abbreviations where it can be helped. <code>adc</code>,   <code>pwm</code>, and <code>i2c</code> are extremely common so it is fine to leave them as   abbreviations. Most people know the abbreviations more than the words that   make them up. But words like <code>cnt</code> should be <code>count</code> and <code>cdl</code> and <code>cdh</code>   should be written out as <code>clock_divider_low</code> and <code>clock_divider_high</code>.   Registers do get a pass if they directly reflect the names in the data sheet   which will make looking them up easier in the future.</li> <li>Use <code>#pragma once</code> as the include guard for headers.</li> <li>Every file must end with a newline character.</li> <li>Every line in a file must stay within a 80 character limit.</li> <li>Exceptions to this rule are allowed. Use <code>// NOLINT</code> in these cases.</li> <li>Radix for bit manipulation:</li> <li>Only use binary (<code>0b1000'0011</code>) or hex (<code>0x0FF0</code>) for bit manipulation.</li> <li>Never use decimal or octal as this is harder to reason about for most     programmers.</li> <li>Every public API must be documented with the doxygen style comments (CI will   ensure that every public API is documented fully).</li> <li>Include the C++ header version of C headers such as <code>&lt;cstdint&gt;</code> vs   <code>&lt;stdint.h&gt;</code>.</li> </ul>"},{"location":"style/#s2-refrain-from-performing-manual-bit-manipulation","title":"S.2 Refrain from performing manual bit manipulation","text":"<p>Use <code>hal::bit</code> from <code>libhal-util</code> library to perform bitwise operations operations.</p>"},{"location":"style/#s3-refrain-from-using-macros","title":"S.3 Refrain from using MACROS","text":"<p>Only use macros if something cannot be done without using them. Usually macros can be replaced with <code>constexpr</code> or const variables or function calls. A case where macros are the only way is for HAL_CHECK() since there is no way to automatically generate the boiler plate for returning if a function returns and error in C++ and thus a macro is needed here to prevent possible mistakes in writing out the boilerplate.</p> <p>Only use preprocessor <code>#if</code> and the like if it is impossible to use <code>if constexpr</code> to achieve the same behavior.</p>"},{"location":"style/#s4-never-include-c-stream-libraries","title":"S.4 Never include C++ stream libraries","text":"<p>Applications incur an automatic 150kB space penalty for including any of the ostream headers that also statically generate the global <code>std::cout</code> and the like objects. This happens even if the application never uses any part of <code>&lt;iostream&gt;</code> library.</p>"},{"location":"style/#s5-refrain-from-memory-allocations","title":"S.5 Refrain from memory allocations","text":"<p>Interfaces and drivers should refrain from APIs that force memory allocations or implementations that allocate memory from heap. This means avoiding STL libraries that allocate such as <code>std::string</code> or <code>std::vector</code>.</p> <p>Many embedded system applications, especially the real time ones, do not allow dynamic memory allocations. There are many reasons for this that can be found MISRA C++ and AutoSAR.</p>"},{"location":"style/#s6-drivers-should-not-log-to-stdout-or-stdin","title":"S.6 Drivers should not log to STDOUT or STDIN","text":"<p>Peripheral drivers must NOT log to stdout or stderr. This means no calls to</p> <ul> <li><code>std::printf</code></li> <li><code>std::cout</code></li> <li><code>std::print</code> (C++26's version of print based on <code>std::format</code>)</li> </ul> <p>Consider using the file I/O libraries in C, C++, python or some other language. Would you, as a developer, ever imagine that opening, reading, writing, or closing a file would (write?) to your console? Especially if there did not exist a way to turn off logging. Most users would be very upset as this would not seem like the role of the file I/O library to spam the console. This gets even worse if a particular application has thousands of files and each operation is logging.</p> <p>The role of logging should be held by the application developer, not their drivers or helper functions, unless the purpose of the helper functions or driver is to write to console.</p>"},{"location":"style/#s7-drivers-should-not-purposefully-halt-or-terminate-the-application","title":"S.7 Drivers should not purposefully halt OR terminate the application","text":"<p>Drivers are not entitled to halt the execution of the application and thus any code block that would effectively end or halt the execution of the program without giving control back to the application are prohibited.</p> <p>As an example drivers should never call:   - <code>std::abort()</code>   - <code>std::exit()</code>   - <code>std::terminate()</code>   - any of their variants</p> <p>This includes placing an infinite loop block in a driver.</p> <p>An application should have control over how their application ends. A driver should report severe errors to the application and let the application decide the next steps. If a particular operation cannot be executed as intended, then <code>hal::new_error()</code> should be called.</p> <p>Constructors would be the only valid place to put an exit statement, because they cannot return errors only themselves.</p> <p>The solution to this is to use a factory function like so:</p> Device Driver LibraryPeripheral Driver Library <pre><code>class device_driver {\npublic:\nresult&lt;device_driver&gt; create(/* ... */) {\n// Perform operations that may fail here\nreturn device_driver(/* ... */);\n}\n\nprivate:\ndevice_driver(/* ... */) {\n// Constructors should never fail and thus any work done here must not\n// fail.\n}\n};\n</code></pre> <pre><code>class peripheral_driver {\npublic:\n// Since peripherals are constrained and have a finite set of values\n// This also ensures that the driver is only constructed once and afterwards\n// simply returns back a reference to that object.\ntemplate&lt;size_t PortNumber&gt;\n// NOTE: Returns a reference not an object.\n//       Objects are owned by the create function\nresult&lt;peripheral_driver&amp;&gt; create(/* ... */) {\n// Perform operations that may fail here\nstatic peripheral_driver driver(/* ... */);\nreturn driver;\n}\n\nprivate:\nperipheral_driver(/* ... */) {\n// ...\n}\n};\n</code></pre>"},{"location":"style/#s8-drivers-should-not-pollute-the-global-namespace","title":"S.8 Drivers should not pollute the global namespace","text":"<p>All drivers must be within the <code>hal</code> namespace or within their own bespoke namespace.</p> <p>Inclusion of a C header file full of register map structures is not allowed as it pollutes the global namespace and tends to result in name collisions.</p> <p>Care should be taken to ensure that the <code>hal</code> namespace is also as clean as possible by placing structures, enums, const data, and any other symbols into the driver's class's namespace like so:</p> <pre><code>namespace hal::target\n{\nclass target {\nstruct register_map {\nstd::uint32_t control1;\nstd::uint32_t control2;\nstd::uint32_t data;\nstd::uint32_t status;\n// ..\n};\n\nstruct control1_register {\nstatic constexpr auto channel_enable = hal::bit::range::from&lt;0, 7&gt;();\nstatic constexpr auto peripheral_enable = hal::bit::range::from&lt;8&gt;();\n// ...\n};\n\n// ...\n};\n}\n</code></pre>"},{"location":"style/#s9-interface-should-follow-the-public-private-api-scheme","title":"S.9 Interface should follow the public private API Scheme","text":"<p>See private virtual method for more details. Rationale can be found within that link as well.</p>"},{"location":"style/#s10-avoid-using-bool","title":"S.10 Avoid using <code>bool</code>","text":""},{"location":"style/#s101-as-an-object-member","title":"S.10.1 As an object member","text":"<p><code>bool</code> has very poor information density and takes up 8-bits per entry. If only one <code>bool</code> is needed, then a bool is a fine object member. If multiple <code>bool</code>s are needed, then use a <code>std::bitset</code> along with static <code>constexpr</code> index positions in order to keep the density down to the lowest amount possible.</p>"},{"location":"style/#s102-as-a-parameter","title":"S.10.2 As a parameter","text":"<p>See the article \"Clean code: The curse of a boolean parameter\" for details as to why <code>bool</code> parameters are awful.</p> <p><code>bool</code> is fine if it is the only parameter and it acts as a lexical switch, for example:</p> <pre><code>// This is fine because it reads as set \"LED\" voltage \"level\" to \"FALSE\"\nled.level(false);\n// This is fine because it reads as set \"LED\" voltage \"level\" to \"TRUE\"\nled.level(true);\n</code></pre>"},{"location":"style/#s11-integrating-third-party-libraries-by-source","title":"S.11 Integrating third party libraries by source","text":"<p>In general, third party libraries should NOT be integrated into a library by source. It should be depended upon using a package manager. But in some cases third party libraries must be included by source. In these cases, the third party libraries should be committed into a project, without modifications, into the <code>include/&lt;library_name&gt;/third_party</code> directory. After that commit, the third party libraries can be used by and integrated into the library code base, in a following commit.</p> <p>If a third party library is modified, that library must have a section at the top of the file with the following description:</p> <pre><code>/**\n * [libhal] modifications to this file are as follows:\n *\n *    1. mod 1\n *    2. mod 2\n *    3. mod 3\n *    4. mod 4\n */\n\n/**\n * &lt;LICENSE GOES HERE!&gt;\n */\n</code></pre> <p>Care must be taken to ensure that third party libraries do not conflict with the licenses of libhal libraries and permit direct integration as well as modification.</p> <p>Rationale: Makes keeping track of changes and the history of files easier to manage.</p>"},{"location":"style/#s12-avoid-stdatomic","title":"S.12 Avoid <code>std::atomic</code>","text":"<p>Avoid using <code>std::atomic</code> because of portability issues across devices in architectures. Especially when <code>std::atomic</code> is not fully supported by the compiler.</p> <p>Info</p> <p><code>target</code> and <code>processor</code> libraries are allowed to use <code>std::atomic</code> if it is available with their cross compiler and toolchain. In this case, the we can know which target devices the software is running on, either the target itself, which we already know can support it, or on a host machine for unit testing, which is very likely to have a compiler that supports atomics.</p>"},{"location":"style/#s13-avoid-thread","title":"S.13 Avoid <code>&lt;thread&gt;</code>","text":"<p>Embedded system compilers tend to not provide an implementation of <code>&lt;thread&gt;</code> because the choice of which threading model or multi-threading operating system is left to the developer.</p> <p>In general, <code>#include &lt;thread&gt;</code> will almost never work when cross compiling.</p>"},{"location":"trying_out/","title":"\ud83d\ude80 Trying out libhal","text":""},{"location":"trying_out/#building-demos","title":"\ud83d\udee0\ufe0f Building Demos","text":"<p>Make sure to complete \ud83e\uddf0 Install Prerequisites</p>"},{"location":"trying_out/#cloning-the-target-libraries","title":"Cloning the target libraries","text":"<p>Clone the target library you would like to run the demos for. You can download just one or both if you have both devices.</p> LPC4078 <pre><code>git clone https://github.com/libhal/libhal-lpc40\ncd libhal-lpc40/demo\n</code></pre>"},{"location":"trying_out/#building-using-conan-cmake","title":"Building using Conan &amp; CMake","text":"<p>To build using conan and cmake, you just need to run the following:</p> <pre><code>conan build . -pr lpc4088 -s build_type=MinSizeRel\n</code></pre> <p>Note</p> <p>You may need to add the argument <code>-b missing</code> at the end of the above command if you get an error stating that the prebuilt binaries are missing. <code>-b missing</code> will build them locally for your machine. After which those libraries will be cached on your machine and you'll no longer need to include those arguments.</p> <p>Tip</p> <p>The following build types, <code>build_type</code> argument are available:</p> <ul> <li>\u274c Debug: No optimization, do not recommend, normally used for unit   testing.</li> <li>\ud83e\uddea RelWithDebInfo: Turn on some optimizations to reduce binary size and   improve performance while still maintaining the structure to make   debugging easier. Recommended for testing and prototyping.</li> <li>\u26a1\ufe0f Release: Turn on optimizations and favor higher performance   optimizations over space saving optimizations.</li> <li>\ud83d\udddc\ufe0f MinSizeRel: Turn on optimizations and favor higher space saving   optimizations over higher performance.</li> </ul> <p>Note that <code>Release</code> and <code>MinSizeRel</code> build types both usually produce binaries faster and smaller than <code>RelWithDebInfo</code> and thus should definitely be used in production.</p> <p>When this completes you should have some applications in the <code>build/lpc4078/MinSizeRel/</code> with names such as <code>uart.elf</code> or <code>blinker.elf</code>.</p>"},{"location":"trying_out/#uploading-demos-to-device","title":"\ud83d\udcbe Uploading Demos to Device","text":""},{"location":"trying_out/#necessary-parts","title":"Necessary Parts","text":"<p>In order to complete this tutorial you'll need either a</p> <ul> <li>LPC4078 MicroMod with Sparkfun ATP board or</li> <li>or SJ2 Board</li> </ul>"},{"location":"trying_out/#uploading-applications","title":"Uploading Applications","text":"<p>There are python programs built for uploading binary files to devices.</p> <p>First step is connecting your MicroMod carrier board to your computer using the USB-C connector.</p> <p>Question</p> <p>Don't know which serial port to use? Use this guide Find Arduino Port on Windows, Mac, and Linux from the MATLAB docs to help. Simply ignore that its made for Arduino, this guide will work for any serial USB device.</p> LPC4078 <p>Install the <code>nxpprog</code> flashing software for LPC devices:</p> <pre><code>python3 -m pip install nxpprog\n</code></pre> <p>Tip</p> <p>On Ubuntu 22.04 you will need to use the command <code>python3.9</code> because the default python is usually 3.8.</p> <pre><code>python3.9 -m pip install nxpprog\n</code></pre> <pre><code>nxpprog --control --binary \"build/lpc4078/MinSizeRel/uart.elf.bin\" --device \"/dev/tty.usbserial-140\"\n</code></pre> <ul> <li>Replace <code>/dev/tty.usbserial-140</code> with the correct port.</li> <li>Replace <code>uart.elf.bin</code> with any other application found in the   <code>demos/applications/</code> directory.</li> </ul>"},{"location":"directory/status/","title":"Library Status","text":"<p>Repo</p> <p>CI State</p> <p>Coverage</p> <p>Latest Version</p> libhal/libhal-__platform__ libhal/libhal-stm32f1 libhal/libhal-esp8266 libhal/libhal-__device__ libhal/libhal-mpu libhal/libhal-pca libhal/libhal-rmd libhal/libhal-tmp libhal/libhal-mock libhal/libhal-soft libhal/libhal-lpc40 libhal/libhal-util libhal/libhal libhal/libhal-armcortex"},{"location":"how-to/application/","title":"\ud83d\udd3a Application Libraries","text":""},{"location":"how-to/arm_cortex_bringup/","title":"\ud83d\udd38 Bare-Metal ARM Cortex Target Bring-Up","text":"<p>This guide will step you through making a libhal + conan target library for a arm processor microcontroller. Unlike libhal applications that can be executed on a machine running an OS like linux, example Raspberry Pi and Beagle Boards, you cannot just execute the binary.</p> <p>This guide assumes that <code>libhal-library</code> was used as a template and has already updated and changed all of the names from <code>libhal-library</code> to the appropriate library name.</p> <p>In order to build an application that can be loaded and executed onto a microcontroller you only need:</p> <ol> <li>Add <code>libhal-armcortex</code> as a dependency</li> <li>Provide a linker script for each microcontroller</li> <li>Determine minimum compiler flags for each microcontroller</li> <li>Provide a library component for that microcontroller</li> </ol> <p>The rest can be handled by the <code>arm-gnu-embedded-toolchain</code>'s <code>crt0</code> implementation, the <code>arm-gnu-embedded-toolchain</code> conan package and the <code>libhal-armcortex</code> conan package.</p>"},{"location":"how-to/arm_cortex_bringup/#adding-the-libhal-armcortex-dependency","title":"Adding the <code>libhal-armcortex</code> dependency","text":"<p>Simply add <code>libhal-armcortex</code> to your <code>requirements()</code> method:</p> <pre><code>def requirements(self):\n    # ...\n    self.requires(\"libhal-armcortex/[^1.0.1]\")\n</code></pre>"},{"location":"how-to/arm_cortex_bringup/#writing-the-linker-scripts","title":"Writing the linker scripts","text":""},{"location":"how-to/arm_cortex_bringup/#setup-linker-script-directory","title":"Setup linker script directory","text":"<p>Create a <code>linker_scripts</code> directory at the root of the library package. Add <code>linker_scripts/*</code> directory to the export sources in the package <code>conanfile.py</code>, like so:</p> <pre><code>exports_sources = \"include/*\", \"linker_scripts/*\", \"tests/*\", \"LICENSE\"\n</code></pre>"},{"location":"how-to/arm_cortex_bringup/#finding-linker-scripts-info","title":"Finding linker scripts info","text":"<p>Lets consider the <code>lpc4074</code> microcontroller. What you'll need to figure out is:</p> <ol> <li>Flash memory address &amp; size</li> <li>Ram memory address &amp; size</li> </ol> <p>These sections are part of whats called the \"memory map\". Most modern day systems use a system called \"Memory-mapped I/O\" which means that the system uses the same address space to address both memory and I/O devices. In this case we simply want to find the addresses of the flash memory and ram memory. This information can be found in the data sheet or user manual of the chip.</p> <p>The LPC40 series of microcontrollers will be used for this example: The memory map can be found on page 52 of the <code>LPC408X_7X.pdf</code> data sheet or page 14 of the <code>UM10562.pdf</code> user manual.</p> <p></p> <p> Figure 1. LPC40xx Memory Map </p> <p>Here you can see that flash starts at address <code>0x00000000</code> for all sizes of flash memory. The SRAM locations all start at <code>0x10000000</code> for all sizes of SRAM. This chart does not provide which chips have which ram and flash sizes.</p> <p>Looking through the data sheet and searching for terms like \"part numbers\", \"ordering options\", or even just the number 512 (the maximum flash size), eventually this section will appear:</p> <p></p> <p> Figure 2. LPC40xx Part Ordering Info part 1 </p> <p></p> <p> Figure 3. LPC40xx Part Ordering Info part 2 </p> <p>Now all of the information to write the linker scripts is available:</p> lpc4072.ldlpc4074.ldlpc4076.ldlpc4078.ldlpc4088.ld <pre><code>__flash = 0x00000000;\n__flash_size = 64K;\n__ram = 0x10000000;\n__ram_size = 16K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <pre><code>__flash = 0x00000000;\n__flash_size = 128K;\n__ram = 0x10000000;\n__ram_size = 32K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <pre><code>__flash = 0x00000000;\n__flash_size = 256K;\n__ram = 0x10000000;\n__ram_size = 64K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <pre><code>__flash = 0x00000000;\n__flash_size = 512K;\n__ram = 0x10000000;\n__ram_size = 64K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <pre><code>__flash = 0x00000000;\n__flash_size = 512K;\n__ram = 0x10000000;\n__ram_size = 64K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <p>Question</p> <p>You may be wondering why the RAM size is 64kB and not 96kB for some of the linker scripts and thats due to the fact that the LPC40xx series has a dual SRAM architecture. To keep this simple, only the largest RAM block is supported.</p> <p>The linker script only needs 4 lines as <code>libhal-armcortex</code> provides a standard linker script for ARM microcontrollers supporting 1 flash memory and 1 ram device. Defining the <code>__flash</code>, <code>__flash_size</code>, <code>__ram</code>, and <code>__ram_size</code> linker script variables is all that is needed to make a usable linker script.</p> <p>There are plans to support dual flash, dual ram and other varieties of flash and ram combinations in the future in <code>libhal-armcortex</code>.</p> <p>Warning</p> <p>Many of the microcontrollers come in different packages and may have some differences in the number of peripherals they support, pins they have and performance. The linker script does not need to worry about such differences and thus, a linker script should NOT be made for every possible chip variety in the series but for the common flash sizes and ram sizes for each.</p>"},{"location":"how-to/arm_cortex_bringup/#compiler-flags","title":"Compiler flags","text":""},{"location":"how-to/arm_cortex_bringup/#processor-flags","title":"Processor flags","text":"<p>The data sheet will include information about the processor. The compiler flag will match the following based on the CPU:</p> <ul> <li><code>-mcpu=cortex-m0</code></li> <li><code>-mcpu=cortex-m0plus</code> (cortex-M0+)</li> <li><code>-mcpu=cortex-m1</code></li> <li><code>-mcpu=cortex-m3</code></li> <li><code>-mcpu=cortex-m4</code></li> <li><code>-mcpu=cortex-m7</code></li> <li><code>-mcpu=cortex-m23</code></li> <li><code>-mcpu=cortex-m33</code></li> <li><code>-mcpu=cortex-m35p</code></li> <li><code>-mcpu=cortex-m55</code></li> <li><code>-mcpu=cortex-m85</code></li> <li><code>-mcpu=cortex-m1.small-multiply</code></li> <li><code>-mcpu=cortex-m0.small-multiply</code></li> <li><code>-mcpu=cortex-m0plus.small-multiply</code></li> </ul>"},{"location":"how-to/arm_cortex_bringup/#floating-point-support","title":"Floating Point Support","text":"<p>After one of the following to the architecture flags:</p> <ul> <li><code>-mfloat-abi=soft</code>: if the processor is an cortex-m3 or below</li> <li><code>-mfloat-abi=softfp</code>: if the processor is a cortex-m4 and above AND also has   a floating point unit. This can be determined by searching the data sheet.</li> </ul>"},{"location":"how-to/arm_cortex_bringup/#creating-components-for-the-library","title":"Creating components for the library","text":"<p>libhal target library's split up the library into components, one for each microcontroller variant. For LPC40 that split would look like: <code>libhal::lpc4072</code>, <code>libhal::lpc4074</code>, <code>libhal::lpc4076</code>, <code>libhal::lpc4078</code>, and <code>libhal::lpc4088</code>. When a build system, for example, uses the <code>libhal::lpc4078</code> component, it includes the necessary compiler flags and linker script selection.</p> <p>Along with these components, will be a special generic component named <code>libhal::lpc</code> which does not provide any compiler flags or linker script. This special target is used for applications that want to use their own linker script, or for software running on a host machine like simulations or unit tests.</p> <p>To add components it must be added in the <code>package_info</code> method of the <code>ConanFile</code> package class. Here is what it looks like for the <code>libhal-lpc</code> library. Copy this section and tailor it to your needs.</p> <pre><code>def package_info(self):\n  # Specify, for the component, all requirements of the package\n  requirements_list = [\"libhal::libhal\",\n                       \"libhal-util::libhal-util\",\n                       \"libhal-armcortex::libhal-armcortex\",\n                       \"ring-span-lite::ring-span-lite\"]\n\n  # List of REQUIRED compiler flags for the gnu-arm-embedded-toolchain for some\n  # of the chips. These are determined by the capabilities of the chip.\n  # For example all but the lpc4072 and lpc4074 have hardware floating point\n  # arithmetic support so they ought to use \"float-abi=softfp\" which uses the\n  # floating point hardware BUT is ABI compatible with the software\n  # implementation.\n  m4f_architecture_flags = [\n      \"-mcpu=cortex-m4\",\n      \"-mfloat-abi=softfp\",\n  ]\n\n  # List of REQUIRED compiler flags for the gnu-arm-embedded-toolchain for\n  # some of the chips. These are determined by the capabilities of the chip.\n  # For example the lpc4072 and lpc4074 do not have hardware floating point\n  # arithmetic support so they must use \"float-abi=soft\" for a software\n  # implementation.\n  m4_architecture_flags = [\n      \"-mcpu=cortex-m4\",\n      \"-mfloat-abi=soft\"\n  ]\n\n  # Create a path to the linker_script directory which resides in the\n  # package's package_folder.\n  linker_path = os.path.join(self.package_folder, \"linker_script\")\n\n  # Set the cmake file name\n  self.cpp_info.set_property(\"cmake_file_name\", \"libhal-lpc\")\n  # All the package to be found in anyway with cmake\n  self.cpp_info.set_property(\"cmake_find_mode\", \"both\")\n\n  # Create the special/generic component \"lpc\" and set its component name\n  self.cpp_info.components[\"lpc\"].set_property(\n      \"cmake_target_name\",  \"libhal::lpc\")\n\n  # This is where we add the path to our linker scripts to the set of linker\n  # flags.\n  self.cpp_info.components[\"lpc\"].exelinkflags.append(\"-L\" + linker_path)\n\n  # Add the list of requirements to the generic component\n  self.cpp_info.components[\"lpc\"].requires = requirements_list\n\n  # Helper function for creating components\n  def create_component(self, component, flags):\n\n      link_script = \"-Tlibhal-lpc/\" + component + \".ld\"\n      component_name = \"libhal::\" + component\n      self.cpp_info.components[component].set_property(\n          \"cmake_target_name\", component_name)\n      # Make the special component the only requirement for the component,\n      # inheriting all of the transitive dependencies.\n      self.cpp_info.components[component].requires = [\"lpc\"]\n      # Add the link script and flags to the component's linker flags and\n      # compiler flags\n      self.cpp_info.components[component].exelinkflags.append(link_script)\n      self.cpp_info.components[component].exelinkflags.extend(flags)\n      # Add flags to the cflags &amp; cxxflags to ensure that each compilation unit\n      # Knows the instruction set and float ABI\n      self.cpp_info.components[component].cflags = flags\n      self.cpp_info.components[component].cxxflags = flags\n\n  # Create the components for each chip.\n  create_component(self, \"lpc4072\", m4_architecture_flags)\n  create_component(self, \"lpc4074\", m4_architecture_flags)\n  create_component(self, \"lpc4076\", m4f_architecture_flags)\n  create_component(self, \"lpc4078\", m4f_architecture_flags)\n  create_component(self, \"lpc4088\", m4f_architecture_flags)\n</code></pre>"},{"location":"how-to/arm_cortex_bringup/#verifying","title":"Verifying","text":""},{"location":"how-to/arm_cortex_bringup/#creating-the-package","title":"Creating the package","text":"<p>Run <code>conan create .</code> in the folder with the <code>conanfile.py</code> recipe in it. The test package and build stages should show something like this during the cmake phase:</p> <pre><code>-- Conan: Component target declared 'libhal::lpc'\n-- Conan: Component target declared 'libhal::lpc4072'\n-- Conan: Component target declared 'libhal::lpc4074'\n-- Conan: Component target declared 'libhal::lpc4076'\n-- Conan: Component target declared 'libhal::lpc4078'\n-- Conan: Component target declared 'libhal::lpc4088'\n</code></pre>"},{"location":"how-to/arm_cortex_bringup/#testing-out-a-demo","title":"Testing out a demo","text":"<p>Create a demo and have it require the library. In this case the demo <code>conafile.py</code> may include:</p> <pre><code>from conan import ConanFile\nfrom conan.tools.cmake import CMake, cmake_layout\n\n\nclass Lpc40xxDemos(ConanFile):\n    settings = \"compiler\", \"build_type\"\n    generators = \"CMakeToolchain\", \"CMakeDeps\", \"VirtualBuildEnv\"\n\n    def requirements(self):\n        self.requires(\"libhal-lpc/1.1.4\") # &lt;-- change this\n        self.requires(\"libhal-util/[^1.0.0]\") # &lt;-- update this if necessary\n        self.tool_requires(\"gnu-arm-embedded-toolchain/11.3.0\")\n        self.tool_requires(\"cmake-arm-embedded/0.1.1\")\n\n    def layout(self):\n        cmake_layout(self)\n\n    def build(self):\n        cmake = CMake(self)\n        cmake.configure()\n        cmake.build()\n</code></pre> <p>Change the library name to the library you are creating.</p> <pre><code>self.tool_requires(\"gnu-arm-embedded-toolchain/11.3.0\")\nself.tool_requires(\"cmake-arm-embedded/0.1.1\")\n</code></pre> <p>The above two requirements are required to download and install the toolchain/compiler and the cmake toolchain/helper files. The project should compile if everything was done correctly.</p>"},{"location":"how-to/device/","title":"\ud83d\udd39 Device Libraries","text":"<p>Info</p> <p>Documentation coming soon...</p>"},{"location":"how-to/project/","title":"\ud83c\udd95 Creating a new Project","text":"<p>In this example we create a project using the CMake build system.</p> <p>In order to make a project you need 5 files:</p> <ol> <li><code>conanfile.txt</code>: list of project dependencies.</li> <li><code>CMakeLists.txt</code>: instructions describing the project's source files,    executables and how to build them.</li> <li><code>main.cpp</code>: application software</li> <li><code>libhal.tweaks.hpp</code>: configuration file for libhal</li> <li><code>newlib.cpp</code> : definitions of low level C functions</li> </ol>"},{"location":"how-to/project/#quick-start","title":"Quick Start","text":"<p>Clone this starter project:</p> <pre><code>git clone https://github.com/libhal/libhal-starter.git\n</code></pre>"},{"location":"how-to/project/#creating-the-conanfiletxt","title":"Creating the <code>conanfile.txt</code>","text":"<p>A standard libhal <code>conanfile.txt</code> will look like this:</p> <pre><code>[requires]\nlibhal-lpc40/1.1.6\n\n[tool_requires]\ngnu-arm-embedded-toolchain/11.3.0\ncmake-arm-embedded/0.1.1\n\n[generators]\nCMakeToolchain\nCMakeDeps\n</code></pre> <ul> <li><code>[requires]</code> lists the project dependencies.<ul> <li>Each libhal project needs a target library and this example uses   <code>libhal-lpc40</code> which is used for the SJ2 board or the LPC4078 micromod.</li> </ul> </li> <li><code>[tool_requires]</code> lists the tools that are needed to build the project.<ul> <li><code>gnu-arm-embedded-toolchain/11.3.0</code> brings in the ARM GCC cross compiler   which is used to compile to the code for ARM Cortex microcontroller.</li> <li><code>cmake-arm-embedded/0.1.1</code> brings in cmake helper scripts and toolchain   files for configuring cmake for the cross compiler.</li> </ul> </li> <li><code>[generators]</code> list the generators which generate files for the project build    systems.<ul> <li><code>CMakeToolchain</code>: Generates toolchain cmake scripts based on the conan   package recipe information.</li> <li><code>CMakeDeps</code>: Generates cmake package/configuration files for each library which can be</li> </ul> </li> </ul>"},{"location":"how-to/project/#making-the-cmakeliststxt-file","title":"Making the <code>CMakeLists.txt</code> file","text":"<p>Below is the minimal amount of cmake code needed for a libhal project:</p> <pre><code>cmake_minimum_required(VERSION 3.20)\n\nproject(project_name.elf VERSION 0.0.1 LANGUAGES CXX)\n\nfind_package(libhal-lpc40 REQUIRED CONFIG)\n\nadd_executable(${PROJECT_NAME} main.cpp newlib.cpp)\ntarget_compile_features(${PROJECT_NAME} PRIVATE cxx_std_20)\ntarget_include_directories(${PROJECT_NAME} PUBLIC .)\ntarget_link_libraries(${PROJECT_NAME} PRIVATE libhal::lpc4078)\n\narm_cortex_post_build(${PROJECT_NAME})\n</code></pre> <p>If you are unfamiliar with cmake, please take a look at the guide An Introduction to Modern CMake.</p> <p>There are a few elements of the CMakeList.txt file which do not standard CMake:</p> <ol> <li><code>libhal::lpc4078</code>: Defines the specific package component for the the    <code>lpc4078</code> micro-controller. Using this component will automatically use the    minimum required compiler and link flags for the microcontroller as well as    use the standard linker script for the device.</li> <li><code>arm_cortex_post_build(${PROJECT_NAME})</code>: Provided by the toolchain    file in the <code>cmake-arm-embedded</code> tool package. Generates the <code>.hex</code>    (intel hex), <code>.bin</code> (binary), <code>.S</code> (disassembly) and <code>.lst</code> (disassembly with    source interweaved).</li> </ol>"},{"location":"how-to/project/#writing-maincpp","title":"Writing <code>main.cpp</code>","text":"<p>Read through the source code below to get an idea of whats needed:</p> <pre><code>#include &lt;libhal-armcortex/dwt_counter.hpp&gt;\n#include &lt;libhal-armcortex/startup.hpp&gt;\n#include &lt;libhal-armcortex/system_control.hpp&gt;\n#include &lt;libhal-lpc40/output_pin.hpp&gt;\n#include &lt;libhal-lpc40/system_controller.hpp&gt;\n#include &lt;libhal-util/steady_clock.hpp&gt;\n\nint\nmain()\n{\nusing namespace hal::literals;\nusing namespace std::literals;\n\n// Initializing the data section initializes global and static variables and\n// is required for the standard C library to run.\nhal::cortex_m::initialize_data_section();\nhal::cortex_m::system_control::initialize_floating_point_unit();\n\n// Create a hardware counter\nauto&amp; clock = hal::lpc40xx::clock::get();\nauto cpu_frequency = clock.get_frequency(hal::lpc40xx::peripheral::cpu);\nstatic hal::cortex_m::dwt_counter steady_clock(cpu_frequency);\n\n// Get an output pin to use as the LED pin control\nauto&amp; led_pin = hal::lpc40xx::output_pin::get&lt;1, 18&gt;().value();\n\nwhile (true) {\n(void)led_pin.level(true);\n(void)hal::delay(steady_clock, 500ms);\n(void)led_pin.level(false);\n(void)hal::delay(steady_clock, 500ms);\n}\n\nreturn 0;\n}\n\n// When libhal.tweaks.hpp includes:\n//\n// #define BOOST_LEAF_EMBEDDED\n// #define BOOST_LEAF_NO_THREADS\n//\n// Then Boost.LEAF needs this function to be defined\nnamespace boost {\nvoid\nthrow_exception([[maybe_unused]] std::exception const&amp; p_error)\n{\nstd::abort();\n}\n} // namespace boost\n</code></pre>"},{"location":"how-to/project/#the-newlibcpp-file","title":"The <code>newlib.cpp</code> file","text":"<p>The <code>newlib.cpp</code> contains low level APIs used by the standard C library. With an OS these are implemented with OS APIs. For example, the function that provides memory to <code>malloc()</code> is the newlib API <code>sbrk()</code>.</p> <p>To learn more about how to write <code>newlib.cpp</code> see From Zero to main(): Bootstrapping libc with Newlib.</p> <p>See libhal-starter/newlib.cpp for the default empty implementations.</p>"},{"location":"how-to/project/#compiling-the-project","title":"Compiling the project","text":"<p>The command for building the project:</p> <pre><code>conan build .\n</code></pre>"},{"location":"how-to/utility/","title":"\ud83e\ude9b Utility Libraries","text":"<p>Info</p> <p>Documentation coming soon...</p>"},{"location":"interfaces/adc/","title":"<code>adc</code> interface design","text":"<p>See ADC interface API for details on the interface and how to use it.</p>"},{"location":"interfaces/adc/#discussing-read_t","title":"Discussing <code>read_t</code>","text":"<p><code>read_t</code> only has a singular field and that is <code>percentage</code>. The reason a floating point number between -1.0 and 1.0 is to erase information like voltage and bit-resolution.</p>"},{"location":"interfaces/adc/#erasing-voltage","title":"Erasing Voltage","text":"<p>The actual voltage on an ADC pin is not usually determinable by a ADC driver. The only thing an ADC peripheral can determine is the proportion of the read voltage relative to a voltage reference. That voltage reference could be anything, and therefore, there's no reason to try to embed that information into the ADC interface.</p>"},{"location":"interfaces/adc/#erasing-bit-resolution","title":"Erasing Bit Resolution","text":"<p>In general, analog to digital converters have a fixed bit resolution. In what cases would knowing the ADC resolution at runtime be useful? It wouldn't be useful in terms of calculating the voltage because you can use the floating point value for that.</p> <p>No, the only reason why a developer or driver would need the bit resolution to discriminate against an ADC, emitting an error that indicates that the resolution of an ADC is not high enough for the driver or application to work. But this would violate the D.4 Safe design philosophy that drivers should NOT hold code that attempts to check for problems of architecture.</p>"},{"location":"interfaces/can/","title":"<code>can</code> interface design","text":""},{"location":"interfaces/dac/","title":"<code>dac</code> interface design","text":"<p>See DAC interface API for details on the interface and how to use it.</p> <p><code>dac</code> is effectively the same design as ADC but as an output device and thus shares the same design rationale as ADC.</p> <p>See design/adc for details.</p>"},{"location":"interfaces/i2c/","title":"<code>i2c</code> interface design","text":"<p>See I2C interface API for details on the interface and how to use it.</p>"},{"location":"interfaces/i2c/#i2ctransaction","title":"<code>i2c::transaction()</code>","text":"<p>The singular transaction API can support all forms of standard i2c communication operations such as read, write, and write then read. It also comes with a timeout parameter which indicates to the i2c driver when a transaction should abort. Normally applications and drivers will use <code>hal::never_timeout</code> for parameter, unless an external device has the capability/need to perform clock stretching on the bus.</p> <p>The APIs for transaction were not split up into a separate <code>read()</code>, <code>write()</code> and <code>write_then_read()</code> functions in order to reduce vtable size to just two entries. Many i2c implementations incorporate all of these operations in the same algorithm or interrupt state machine which matches the current API structure.</p> <p>The separate operations can be made available using the i2c utility functions in <code>libhal-util</code>.</p>"},{"location":"interfaces/i2c/#i2cconfigure","title":"<code>i2c::configure()</code>","text":"<p>There is not much to say about configuration for i2c. There really is only one option that is variable with i2c an that is clock speed. Everything else is device and target specific.</p>"},{"location":"interfaces/input_pin/","title":"<code>hal::input_pin</code> Interface Tutorial","text":"<p>In this tutorial, we'll learn about the <code>hal::input_pin</code> interface and how digital input pins work. This interface provides a hardware abstraction for digital input pins, making it easier to read the pin state and determine if the voltage on it is HIGH or LOW.</p>"},{"location":"interfaces/input_pin/#what-is-a-digital-input-pin","title":"What is a Digital Input Pin?","text":"<p>A digital input pin is a pin on a microcontroller that reads the voltage level applied to it. The pin can read either a HIGH or a LOW voltage level. In most cases, a HIGH voltage level is represented by the supply voltage (e.g., 3.3V or 5V), while a LOW voltage level is represented by the ground (0V). Digital input pins are commonly used to read signals from sensors, buttons, and other external devices.</p>"},{"location":"interfaces/input_pin/#understanding-the-halinput_pin-interface","title":"Understanding the <code>hal::input_pin</code> Interface","text":"<p>The <code>hal::input_pin</code> interface is designed to provide a consistent way to interact with digital input pins across various hardware platforms. It consists of a few key components:</p>"},{"location":"interfaces/input_pin/#1-settings-structure","title":"1. <code>settings</code> Structure","text":"<p>This structure holds the generic settings for input pins. It currently contains a single field, <code>pin_resistor</code>, which represents the pull resistor configuration for the input pin. The pull resistor can be set to <code>pull_up</code> or <code>pull_down</code>, depending on the hardware requirements.</p>"},{"location":"interfaces/input_pin/#2-level_t-structure","title":"2. <code>level_t</code> Structure","text":"<p>The <code>level_t</code> structure is used to represent the measured state of the input pin. It has a single boolean field, <code>state</code>, which indicates whether the pin is at a HIGH voltage level (<code>true</code>) or a LOW voltage level (<code>false</code>).</p>"},{"location":"interfaces/input_pin/#3-configure-method","title":"3. <code>configure</code> Method","text":"<p>This method is used to configure the input pin according to the supplied settings. It takes a <code>settings</code> object as an argument and returns a <code>status</code> object indicating success or failure. If the settings cannot be achieved, an <code>std::errc::invalid_argument</code> exception is thrown.</p>"},{"location":"interfaces/input_pin/#4-level-method","title":"4. <code>level</code> Method","text":"<p>The <code>level</code> method reads the state of the input pin and returns a <code>result&lt;level_t&gt;</code> object. A <code>true</code> value indicates a HIGH voltage level, while a <code>false</code> value indicates a LOW voltage level.</p>"},{"location":"interfaces/input_pin/#5-virtual-driver-methods","title":"5. Virtual Driver Methods","text":"<p>The <code>driver_configure</code> and <code>driver_level</code> methods are virtual and must be implemented by the derived class for specific hardware platforms. These methods are responsible for configuring the input pin and reading its level, respectively.</p>"},{"location":"interfaces/input_pin/#using-the-halinput_pin-interface","title":"Using the <code>hal::input_pin</code> Interface","text":"<p>To use the <code>hal::input_pin</code> interface, you need to create a derived class that implements the virtual driver methods for your specific hardware platform. Here's a basic outline of how to do that:</p> <ol> <li>Include the <code>input_pin.hpp</code> header file in your project.</li> <li>Create a derived class that inherits from <code>hal::input_pin</code>.</li> <li>Implement the <code>driver_configure</code> and <code>driver_level</code> methods in your derived    class.</li> </ol> <pre><code>#include \"input_pin.hpp\"\n\nclass my_input_pin : public hal::input_pin {\nprivate:\nvirtual hal::status driver_configure(const hal::input_pin::settings&amp;\np_settings) override\n{\n// Implement hardware-specific configuration logic here\n}\n\nvirtual hal::result&lt;hal::input_pin::level_t&gt; driver_level() override\n{\n// Implement hardware-specific level reading logic here\n}\n};\n</code></pre> <p>Once you've created your derived class, you can use the <code>configure</code> and <code>level</code> methods to interact with the digital input pin.</p> <pre><code>my_input_pin input_pin;\nhal::input_pin::settings pin_settings;\npin_settings.resistor = hal::pin_resistor::pull_up;\n\nauto configStatus = input_pin.configure(pin_settings);\nif (configStatus == hal::status::success) {\n// Successfully configured the input pin\n} else {\n// Handle configuration failure\n}\n\n// Read the state of the input pin\nauto pin_level_result = input_pin.level();\nif (pin_level_result) {\nhal::input_pin::level_t pinLevel = pin_level_result.value();\nif (pinLevel.state) {\n// The pin is at a HIGH voltage level\n} else {\n// The pin is at a LOW voltage level\n}\n} else {\n// Handle level reading failure\n}\n</code></pre>"},{"location":"interfaces/input_pin/#digital-input-pin-tutorial","title":"Digital Input Pin Tutorial","text":"<p>Now that you understand the <code>hal::input_pin</code> interface, let's explore how digital input pins work in more detail.</p> <p>Digital input pins are used to read the voltage level applied to them. When a voltage level is applied to the pin, it compares the voltage to a threshold value to determine if the pin should read HIGH or LOW. This threshold is often set at around half of the supply voltage.</p> <p>When using digital input pins, it's essential to consider pull-up or pull-down resistors. These resistors help prevent undefined behavior caused by floating pins. A floating pin is a pin that is not connected to a HIGH or LOW voltage source and can pick up noise, resulting in unpredictable behavior.</p>"},{"location":"interfaces/input_pin/#pull-up-resistor","title":"Pull-Up Resistor","text":"<p>A pull-up resistor connects the digital input pin to the supply voltage (Vcc) through a resistor. When no external voltage is applied to the pin, the pull-up resistor pulls the voltage level to Vcc, causing the pin to read HIGH. When an external device connects the pin to ground (GND), the pin reads LOW.</p>"},{"location":"interfaces/input_pin/#pull-down-resistor","title":"Pull-Down Resistor","text":"<p>A pull-down resistor connects the digital input pin to ground (GND) through a resistor. When no external voltage is applied to the pin, the pull-down resistor pulls the voltage level to GND, causing the pin to read LOW. When an external device connects the pin to the supply voltage (Vcc), the pin reads HIGH.</p> <p>It's important to choose the appropriate pull resistor configuration based on your specific hardware and application requirements. The <code>hal::input_pin::settings</code> structure in the <code>hal::input_pin</code> interface allows you to specify the pull resistor configuration for your input pin.</p> <p>To use the <code>hal::input_pin</code> interface with the appropriate pull resistor configuration, create a derived class as described earlier in the tutorial. In the <code>driver_configure</code> method implementation, configure your hardware platform to use the specified pull resistor settings. Then, use the <code>configure</code> and <code>level</code> methods provided by the <code>hal::input_pin</code> interface to interact with the digital input pin and read its state.</p>"},{"location":"interfaces/interrupt_pin/","title":"<code>interrupt_pin</code> interface design","text":""},{"location":"interfaces/motor/","title":"<code>motor</code> interface design","text":""},{"location":"interfaces/output_pin/","title":"<code>output_pin</code> interface design","text":""},{"location":"interfaces/pwm/","title":"<code>pwm</code> interface design","text":"<p>A basic PWM should have the capability to control frequency and duty cycle.</p>"},{"location":"interfaces/serial/","title":"<code>serial</code> interface design","text":""},{"location":"interfaces/servo/","title":"<code>servo</code> interface design","text":""},{"location":"interfaces/socket/","title":"<code>socket</code> interface design","text":""},{"location":"interfaces/spi/","title":"<code>spi</code> interface design","text":"<p>See SPI interface API for details on the interface and how to use it.</p>"},{"location":"interfaces/spi/#supporting-just-8-bit-frames","title":"Supporting just 8-bit frames","text":"<p>8-bit frames are the most common frame size for SPI. 16-bit does work, but this can be achieved with two 8-bit frames of data. Other frame sizes are very rare and thus does not warrant the complexity added to the interface, <code>hal::spi::settings_t</code> object, and <code>hal::spi::configure</code> function. If additional frame sizes are needed, then a new <code>hal::variable_frame_spi</code> interface would be created. In the case the <code>hal::variable_frame_spi</code>, you pay for the cost of a more complex implementation.</p>"},{"location":"interfaces/spi/#not-including-chip-select","title":"Not including chip select","text":"<p>The spi interface gives no control over a chip select pin. There are two reasons for this:</p> <ol> <li>Most SPI peripherals have a single <code>NSS</code> or <code>CS</code> pin per SPI bus. If the user wants to    talk to multiple devices on that bus, then the application will need to    disable that pin and use separate output pins to select the appropriate    device. Thus the CS pin is useless in this situation.</li> <li>The behavior of a chip select pin is device specific and may not match how    the peripheral controls the chip select. Drivers must have complete control    over the chip select pin and how it used, thus that control cannot be given    to the SPI peripheral.</li> </ol> <p>Because of these two factors SPI driver are decoupled from their respective chip select pin. Thus ever device driver that accepts a <code>hal::spi</code> must also accept a chip select pin, unless the device does not have an chip select pin and must exist on the bus all by itself.</p>"},{"location":"interfaces/steady_clock/","title":"<code>steady_clock</code> interface design","text":""},{"location":"interfaces/timer/","title":"<code>timer</code> interface design","text":""},{"location":"tutorials/building_blocks/","title":"\ud83e\uddf1 Interface Building Blocks","text":""},{"location":"tutorials/building_blocks/#halresultt-halstatus","title":"<code>hal::result&lt;T&gt;</code> &amp; <code>hal::status</code>","text":"<p><code>hal::result&lt;T&gt;</code> is an alias for the <code>boost::leaf::result&lt;T&gt;</code> type. This type can either be the value <code>T</code> or an error. The type is not a variant but can be considered closer to a <code>std::pair&lt;T, bool&gt;</code>. It holds both and the bool indicates if the object is an error or not. No errors are held in the status structure. The error data is either dropped or saved to the variable within the handler statement within a <code>hal::attempt</code> block (which is an alias for <code>boost::leaf::try_handle_some</code>). <code>hal::status</code> is simply a concise alias for the type <code>boost::leaf::result&lt;void&gt;</code>.</p> <p>See Boost.LEAF for more details about it and how it works.</p> <p>The main reasons why Boost.LEAF was used can be found in Architecture: Boost.LEAF for error handling.</p>"},{"location":"tutorials/building_blocks/#hal_check","title":"<code>HAL_CHECK()</code>","text":"<p><code>HAL_CHECK()</code> is a macro that takes an expression that evaluates to a <code>hal::result&lt;T&gt;</code> or <code>hal::status</code>. <code>HAL_CHECK()</code> either returns from the calling function if an error was emitted as a result of evaluating the expression or in the case of <code>hal::result&lt;T&gt;</code>, <code>HAL_CHECK()</code> returns the value <code>T</code>.</p> <p>For example:</p> <pre><code>// HAL_CHECK unwraps the hal::result&lt;T&gt; type and returns it if it was successful\n// or returns from the calling function with an error result.\nhal::adc::read_t adc_reading = HAL_CHECK(adc.read());\n</code></pre>"},{"location":"tutorials/building_blocks/#libhalunitshpp","title":"<code>libhal/units.hpp</code>","text":"<p>This file contains the definition of the common base units used in libhal as well UDL (user defined literals) that help to make unit conversions easier. Although most of the units are simply floats, giving them names in the APIs helps with clarity and readability.</p>"},{"location":"tutorials/building_blocks/#haltimeout-concept","title":"<code>hal::timeout</code> concept","text":"<p>A <code>timeout</code> in <code>libhal</code> is a \"callable\" that takes no arguments and returns a <code>hal::status</code> as such <code>using timeout = hal::status(void)</code> as defined in <code>libhal/timeout.hpp</code>. A \"callable\" is something that can be called such as function, functor, lambda, etc. The purpose of <code>hal::timeout</code> is to indicate when an operation has run out of time. <code>hal::timeout</code> will emit a <code>std::errc::timed_out</code> value if it timed out. Because it returns a <code>hal::status</code> it can also emit other errors. The other errors should be passed up the stack rather than handled by the operation. And because of this, if a <code>hal::timeout</code> ever emits something other than a <code>std::errc::timed_out</code>, then the operation stops and the error is bubbled up to the appropriate handler.</p> <p>Timeout callable objects are used rather than a time duration because the source of an timeout may not be time based but based on an interrupt signal from another system. Using a time duration for a timeout means that the system would either need (and have to manage) a global clock or take a singular clock like source at construction time. Using this gives the most flexibility to the user.</p>"},{"location":"tutorials/configuration/","title":"\ud83c\udf9a\ufe0f Configuration","text":"<p>libhal is very lightweight and thus has very few knobs that can be configured. The few that it does have are critical to get right. libhal uses <code>tweak.hpp</code> header files for customization and configuration. See A New Approach to Build-Time Library Configuration for more details.</p> <p>Below is an example <code>libhal.tweaks.hpp</code> file with all 3 fields set to their defaults:</p> <pre><code>#pragma once\n#include &lt;string_view&gt;\n\nnamespace hal::config {\nconstexpr std::string_view platform = \"undefined\";\nconstexpr bool on_error_callback_enabled = false;\nconstexpr auto on_error_callback = []() {};\n}  // namespace hal::config\n</code></pre> <p>Create a <code>libhal.tweaks.hpp</code> file somewhere in your application and make sure it is within one of the compiler's include paths. For GCC/Clang you can use the <code>-I</code> flag to specify the directory where headers can be found. The file must be at the root of the directory listed within the <code>-I</code> include path. There can only be one <code>libhal.tweaks.hpp</code> per application build.</p> <p>Error</p> <p>Not providing a <code>libhal.tweaks.hpp</code> file will result in a compiler error by libhal.</p>"},{"location":"tutorials/configuration/#platform","title":"<code>platform</code>","text":"<p>Note</p> <p>Currently this flag is mislabelled as <code>platform</code> and should be labeled as <code>target</code>.</p> <p>Set the string to the name of the device you are working with. Information about what the <code>target</code> string should be set to can be found in the target's libhal library README.md.</p> <p>Lets consider we are using the <code>STM32 Blue Pill Board</code>. The microcontroller on that board is the <code>stm32f103c8t6</code> and thus the target name should be <code>stm32f103c8t6</code>.</p> <p>Drivers will use parts of the target string to configure their behavior such as using generating a compile time error if a peripheral is used with an unsupported target.</p> <p>Using a shorter target name, such as <code>stm32f10</code> will work as well. What this tells the drivers is that you want this project to work on any generic STM32F10x series chip. This will limit which drivers the application can use to the ones common across all STM32F10x series chips can support.</p> <p>A special target name is <code>test</code> which is used to indicate to driver to configure themselves for unit testing. This generally means that memory mapped peripherals will allocate their registers in ram rather than attempting to access them via their peripheral address, which wouldn't make sense on a host machine as their memory maps are different.</p>"},{"location":"tutorials/configuration/#on_error_callback_enable","title":"<code>on_error_callback_enable</code>","text":"<p><code>on_error_callback_enabled</code> enables the usage of the <code>on_error_callback</code>.</p>"},{"location":"tutorials/configuration/#on_error_callback","title":"<code>on_error_callback</code>","text":"<p><code>on_error_callback</code> specifies a callback that should be called when any errors occur. The main purpose of this is to capture a stack trace when errors occur but can be used for anything.</p> <p>Info</p> <p>The callback is called before the error has been constructed and transported</p> <p>Tip</p> <p>Prefer to use an <code>extern</code> function defined above the <code>libhal::config</code> namespace and define the function elsewhere. This prevents issues with inclusion order issues with <code>libhal.tweaks.hpp</code> which occur because ALL libhal interfaces include <code>&lt;libhal/config.hpp&gt;</code> which directly includes <code>libhal.tweaks.hpp</code> which WILL result in an circular inclusion error/issue.</p> <p>Here is an example below:</p> <pre><code>#pragma once\n#include &lt;string_view&gt;\n\nnamespace my_project::config {\nextern void my_error_handler();\n}\n\nnamespace hal::config {\nconstexpr std::string_view platform = \"undefined\";\nconstexpr bool on_error_callback_enabled = false;\nconstexpr auto on_error_callback = []() {\nmy_project::config::my_error_handler();\n};\n}  // namespace hal::config\n</code></pre>"},{"location":"tutorials/debugging/","title":"\ud83d\udd0e On Chip Software Debugging \ud83d\udfe1","text":"<p>JTAG and SWD debuggers are the standard ways to interact with microcontrollers in order to halt their actions, inspect memory, and step through code. It can be used to flash devices, which can sometimes be faster than doing so over serial. Can be used to perform on device line-by-line code debugging which is a powerful tool over print statements when it comes to debugging the state and behavior of a program.</p> <p>This tutorial uses <code>PyOCD</code> because its easy to use, and easy to install. The other big OCD (on-chip debugging) software is OpenOCD which works as well but is a bit more complicated to use. One issue with <code>PyOCD</code> is that it only works for ARM processors, so it cannot be used for RISC-V, MIPS, XTensa based devices.</p> <p>To install <code>PyOCD</code> run:</p> <pre><code>python3 -m pip install pyocd\n</code></pre>"},{"location":"tutorials/debugging/#connecting-to-a-debugger","title":"Connecting to a Debugger","text":"<p>Connect the debugger (STLinkV2) to your MicroMod Carrier board using the STLink to SWD connector adapter. Before connecting and powering everything check that the the ribbon connector is connected to the port with the glowing LED. That is the correct connection. Using the incorrect connection could cause part damage.</p> <p>If you are using another type of device with different connections follow this guide. A connection to ground (<code>GND</code>) must be made between the debugger and the development board in order for the devices to communicate.</p> <p>Danger</p> <p>DOUBLE AND TRIPLE CHECK YOUR CONNECTIONS! Incorrect connects can result in breaking a board, debugger or possible your computer.</p> Connecting SWDConnecting JTAG <p>Connect jumpers from <code>GND</code>, <code>SWDIO</code> and <code>SWDCLK</code> to the pins on the board. If the board supports both <code>SWD</code> and <code>JTAG</code> like many arm cortex boards do, then connect the pins in the following way:</p> <ul> <li><code>SWDIO</code> --&gt; <code>TMS</code></li> <li><code>SWDCLK</code> --&gt; <code>TCK</code></li> </ul> <p>Connect jumpers from the <code>GND</code>, <code>TDI</code>, <code>TMS</code>, <code>TCK</code>, and <code>TDO</code> pins on the JTAG debugger to the headers on the development board of the same name.</p>"},{"location":"tutorials/debugging/#using-gdb","title":"Using GDB","text":"<p>If you do not know how to use GDB here is a GDB Cheat Sheet.</p> <p>You should be able to add breakpoints to add breakpoints at this point. A typical first breakpoint for a program is to set a breakpoint on main.</p> <pre><code>&gt;&gt;&gt; break main\n</code></pre> <p>Next you will want to reset the program back to the start and halt the CPU using the following command.</p> <pre><code>&gt;&gt;&gt; monitor reset halt\n</code></pre> <p>To begin running through the program use the <code>continue</code> command.</p> <pre><code>&gt;&gt;&gt; continue\n</code></pre> <p>At this point you should see the source code of your <code>main.cpp</code> show up. Now you can step through your code and set breakpoints using <code>step</code>, <code>next</code>, <code>finish</code> and <code>continue</code>, <code>break</code>, etc.</p> <p>Typically you would use the <code>run</code> command to start the code. When performing firmware testing, the <code>run</code> command is not needed as the code is already \"running\" on the remote microcontroller.</p> <p>Info</p> <p>On boards with a factory bootloader, when you start debugging, you will notice that you cannot see the source code lines in the gdb shell. This is because the bootloader instructions are not associated with any addresses in your code, thus you will not see source code. This is fine. Continue with the guide. The LPC40xx family of microcontrollers has such a bootloader.</p> <p>Tip</p> <p>Highly recommend using <code>tui enable</code> or gdb-dashboard which is an awesome tool for making command line gdb debugging easier.</p>"},{"location":"tutorials/debugging/#using-print-and-set-variable-commands","title":"Using <code>print</code> and <code>set variable</code> commands","text":"<p>A very helpful command for GDB is the <code>print</code> command.</p> <pre><code>&gt;&gt;&gt; print a + 123\n</code></pre> <p>The statement above takes any expression and will print its result. For example one could do something like this:</p> <pre><code>&gt;&gt;&gt; print reg.TIM1.CCER\n</code></pre> <p>The above expression will print the TIMER1 CCER register value.</p> <p>Tip</p> <p>If you get an error like:</p> <pre><code>Cannot access memory at address ???\n</code></pre> <p>This happens because GDB is limiting access to memory that is known at link time and is apart of the binary's structure. But if a user wants to access peripheral memory not associated with RAM or Flash memory then they can execute this command:</p> <pre><code>set mem inaccessible-by-default off\n</code></pre> <p>You can also use the <code>set variable</code> command to actually change those values. For example, if you are within a loop you force the loop <code>i</code> iterator variable to 5. You can also change register values as well.</p> <pre><code>&gt;&gt;&gt; set variable i = 5\n&gt;&gt;&gt; set variable reg.USART1.CR1 = 1\n</code></pre>"},{"location":"tutorials/error_handling/","title":"\ud83e\udea4 Error Handling \ud83d\udfe1","text":""},{"location":"tutorials/organization/","title":"\ud83d\uddc3\ufe0f Organization","text":"<p>This section will explain the different parts/repos of libhal organization and ecosystem and how they are organized.</p>"},{"location":"tutorials/organization/#target-libraries","title":"Target Libraries","text":"<p>Target libraries depend on processor/OS libraries. The target libraries will include drivers for peripherals contained within their chip packages or, in the case of development boards and SBC (single board computers), these can also contain drivers external to the main chip. Processor/OS libraries contain APIs specific to those platforms for doing such things as handling interrupt service routines, initializing memory and more.</p> <pre><code>flowchart LR\n    libhal\n    subgraph processor/OS\n      libriscvmcu\n      libarmcortex\n      libhal-linux\n    end\n    subgraph arm-targets\n      liblpc40xx\n      libstm32f10x\n    end\n    subgraph riscv-targets\n      libgv32f10x\n      libsifive\n    end\n    subgraph linux-targets\n      libhal-linux-generic\n      libraspi\n    end\n\n    libhal--&gt;libhal-linux\n    libhal--&gt;libriscvmcu\n    libhal--&gt;libarmcortex\n\n    libarmcortex--&gt;liblpc40xx\n    libarmcortex--&gt;libstm32f10x\n\n    libriscvmcu--&gt;libgv32f10x\n    libriscvmcu--&gt;libsifive\n\n    libhal-linux--&gt;libhal-linux-generic\n    libhal-linux--&gt;libraspi</code></pre>"},{"location":"tutorials/organization/#device-libraries","title":"Device Libraries","text":"<p>Device driver libraries have a very simple relationship tree. Device libraries just need the libhal interfaces to work. The implementations of those interfaces will come from a target library in the application.</p> <pre><code>flowchart TD\n    libhal\n    libhal--&gt;libhal-soft\n    libhal--&gt;libmpu\n    libhal--&gt;libesp8266\n    libhal--&gt;libdrv\n    libhal--&gt;libwii\n    libhal--&gt;liballegro-micro\n    libhal--&gt;libdisplay-ssd\n    libhal--&gt;libled-apa-sk\n    libhal--&gt;libmatrix</code></pre>"},{"location":"tutorials/organization/#typical-application","title":"Typical Application","text":"<p>Lets consider an application such as \"Pong\". A game of pong where we use an LED matrix and two Wii controllers using the STM32F103 microcontroller.</p> <pre><code>flowchart LR\n    libhal--&gt;libmatrix--&gt;app\n    libhal--&gt;libarmcortex--&gt;libstm32f10x --&gt;app\n    libhal--&gt;libwii--&gt;app</code></pre> <p>The <code>conanfile.txt</code> would look something like this:</p> <pre><code>[requires]\nlibstm32f10x/1.1.0\nlibmatrix/1.0.2\nlibwii/1.5.2\n\n[generators]\nCMakeToolchain\nCMakeDeps\nVirtualRunEnv\n</code></pre>"},{"location":"tutorials/organization/#application-libraries","title":"Application Libraries","text":"<p>Application libraries are effectively applications with no specific dependency on a particular target. The point of a Application library is to deploy a fully fledged application, but with customizable drivers. For example, the pong game mentioned earlier doesn't require a wii controller or a LED matrix specifically. You could take a <code>hal::display</code> interface (not currently available) and some <code>pong::gamepad</code> interface defined by the Application library that the developer can implement themselves. Then the pong Application can take your display, gamepad and additional information like, \"paddle size\" and \"font size\" and use it to generate a game of pong. The developer gets the opportunity to choose which parts they want for each. Maybe they want a very large TFT display or they want to use a LED matrix. Maybe they want to use a Stadia controller or maybe they want to make a controller out of capacitive sensors and bananas. The choices are endless.</p>"},{"location":"tutorials/organization/#finding-drivers","title":"\ud83d\udd0d Finding Drivers","text":"<p>To find drivers you can look in three locations</p> <ul> <li>libhal organization</li> <li>conan center index</li> <li>libhal driver index \u274c</li> </ul> <p>Example</p> <p>libhal driver index is not available currently and is key to finding drivers around the ecosystem.</p> <p>Search for the name of the device or target you are interested with with the prefix <code>lib</code> in front of it. Try not to be too specific though. For example, the <code>stm32f103c8t6</code> microcontroller target library drivers will be in the package <code>libstm32f10x</code>. The <code>mpu6050</code> accelerometer will be in <code>libmpu</code>.</p>"},{"location":"tutorials/organization/#reference-material","title":"\ud83d\udcd1 Reference Material","text":"<p>Reference material can be found in the <code>datasheets/</code> and <code>schematic/</code> folders. The layout of these directories match that <code>demos/</code>, where the first layer of folders are named after the microcontroller or board they describe.</p> <p>These folders are updated with relevant documents for easy access for our developers and contributors.</p>"}]}