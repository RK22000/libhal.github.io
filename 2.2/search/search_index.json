{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83c\udfe1 Home","text":"Welcome to libhal"},{"location":"#abstract","title":"Abstract","text":"<p>libhal exists to make hardware drivers \ud83d\ude9a portable, \ud83e\uddbe flexible, \ud83d\udce6 accessible, and \ud83c\udf70 easy to use. libhal seeks to provide a foundation for embedded drivers, allowing those drivers to be used across different processors, microcontrollers, systems, and devices.</p> <p>The design philosophy of libhal is to be:</p> <ol> <li>Portable &amp; Cross Platform</li> <li>Light Weight</li> <li>General</li> <li>Minimalist</li> <li>Safe &amp; Reliable</li> <li>Tested &amp; Testable</li> <li>Compiled Quickly</li> <li>OS Agnostic</li> </ol>"},{"location":"#the-basics","title":"The Basics","text":"<p>libhal, at its core, is simply a set of interfaces that correspond to hardware devices and peripherals. These interfaces use runtime polymorphism in order to decouple application logic from driver implementation details. This decoupling enables applications to run on any platform device that has the necessary components available.</p> <p>A quick example is a blinker program. The required interfaces for such a program is a <code>hal::output_pin</code> for controlling the LED and a <code>hal::steady_clock</code> for keeping time. Now your application takes both of these drivers without having to consider their implementation details and blink and LED at a specified interval.</p>"},{"location":"#support","title":"Support","text":"<ul> <li>libhal discord server (preferred)</li> <li>GitHub issues</li> <li>Cpplang Slack #embedded channel</li> </ul>"},{"location":"#distribution","title":"Distribution","text":"<ul> <li>Conan package manager</li> <li>Source code is hosted on GitHub</li> <li><code>vcpkg</code> package manager (planned for the future)</li> </ul>"},{"location":"#sponsorships","title":"Sponsorships","text":"<p>We are proud to be sponsored by JFrog. JFrog generously provides us with free artifact management, security, and CI/CD tools, allowing us to focus on the success of our project.</p> <p>We are grateful for their support and contribution to the open source community. Thank you, JFrog!</p> <p>For more information about JFrog's community initiatives, visit their Giving Back page.</p>"},{"location":"getting_started/","title":"\ud83d\ude80 Getting Started","text":""},{"location":"getting_started/#install-prerequisites","title":"\ud83e\uddf0 Install Prerequisites","text":"<p>What you will need in order to get started with libhal.</p> <ul> <li><code>make</code>: latest available version</li> <li><code>cmake</code>: 3.15 or above</li> <li><code>python</code>: 3.10 or above</li> <li><code>conan</code>: 2.0.13 or above</li> <li>Suitable Compiler for running host tests (can be either of these):</li> <li><code>gcc</code>: 11.3.0 or above</li> <li><code>clang</code>: 14 and above</li> </ul> Ubuntu 22.04Ubuntu 20.04MacOS XWindows <p>Python 3.10 is default installed, no need to install it.</p> <p>Install GCC, clang-tidy, and build essentials:</p> <pre><code>sudo apt update &amp;&amp; sudo apt upgrade\nsudo add-apt-repository -y ppa:ubuntu-toolchain-r/test\nsudo apt install -y build-essential g++-11 clang-tidy\n</code></pre> <p>Installing conan &amp; cmake:</p> <pre><code>python3 -m pip install \"conan&gt;=2.0.13\" cmake\n</code></pre> <p>Install python3.9:</p> <pre><code>sudo apt-get install python3.10\n</code></pre> <p>Install GCC, clang-tidy, and build essentials:</p> <pre><code>sudo apt update &amp;&amp; sudo apt upgrade\nsudo add-apt-repository -y ppa:ubuntu-toolchain-r/test\nsudo apt install -y build-essential g++-11 clang-tidy\n</code></pre> <p>Installing conan &amp; cmake:</p> <pre><code>python3.10 -m pip install \"conan&gt;=2.0.13\" cmake\n</code></pre> <p>Install Homebrew:</p> <pre><code>/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n</code></pre> <p>Install latest version of Python 3.x:</p> <pre><code>brew install python\n</code></pre> <p>Install llvm:</p> <pre><code>brew install llvm\n</code></pre> <p>Make <code>clang-tidy</code> available on the command line:</p> <pre><code>sudo ln -s $(brew --prefix llvm)/bin/clang-tidy /usr/local/bin/\n</code></pre> <p>Install conan &amp; cmake:</p> <pre><code>python3 -m pip install \"conan&gt;=2.0.13\" cmake\n</code></pre> <p>Install Rosetta (only required for M1 macs):</p> <pre><code>/usr/sbin/softwareupdate --install-rosetta --agree-to-license\n</code></pre> <p>Rosetta necessary for intel based cross compilers:</p> <p>We recommend using the <code>choco</code> package manager for windows as it allows easy installation of tools via the command line.</p> <p>To install <code>choco</code>, open PowerShell as an administrator and run the following command:</p> <pre><code>Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))\n</code></pre> <p>Tip</p> <p>If the <code>choco</code> command doesn't work after running this script try closing and opening again PowerShell.</p> <p>Now install <code>python</code>:</p> <pre><code>choco install python\n</code></pre> <p>Install <code>gcc</code> via the <code>mingw</code>:</p> <pre><code>choco install mingw\n</code></pre> <p>Install <code>make</code> for cmake:</p> <pre><code>choco install make\n</code></pre> <p>Installing conan &amp; cmake:</p> <pre><code>python3 -m pip install -U \"conan&gt;=2.0.13\" cmake\n</code></pre>"},{"location":"getting_started/#setting-up-conan","title":"\ud83d\udd27 Setting up Conan","text":"<p>Add the <code>libhal-trunk</code> repository to your system. This repository holds all of the libhal packages.</p> <pre><code>conan remote add libhal-trunk https://libhal.jfrog.io/artifactory/api/conan/trunk-conan\n</code></pre> <p>Next, install the libhal <code>settings_user.yml</code> which extends the architectures of conan's <code>settings.yml</code> file to include baremetal architectures. These additional architecture definitions are required for ALMOST ALL libhal applications.</p> <pre><code>conan config install -sf profiles/baremetal https://github.com/libhal/conan-config.git\n</code></pre> <p>Next, setup the host profile. Host profiles define the compiler, compiler version, standard library version, and many other settings used to configure how applications are built.</p> <p>First detect the default. This will be overwritten in the next step.</p> <pre><code>conan profile detect --force\n</code></pre> <p>Now install the profile for your particular OS and CPU architecture.</p> Intel LinuxARM64 LinuxM1 MacIntel MacIntel WindowsARM64 Windows <p>If your host machine is using an intel core processor as its CPU then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/x86_64/linux/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>It is less likely your host desktop is an ARM64. This section is mostly for building applications and tests on a Raspberry PI or other SBC. But if you do have a laptop powered by an ARM64 core, then this is the correct configuration for you.</p> <pre><code>conan config install -sf profiles/armv8/linux/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If your macbook uses an M1 processor then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/armv8/mac/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If your macbook uses an Intel processor then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/x86_64/mac/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If your windows machine uses an Intel processor then you'll want to use this default configuration.</p> <pre><code>conan config install -sf profiles/x86_64/windows/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre> <p>If you have a modern surface laptop with ARM64, then this may be the right choice for you.</p> <pre><code>conan config install -sf profiles/armv8/windows/ -tf profiles https://github.com/libhal/conan-config.git\n</code></pre>"},{"location":"getting_started/#building-demos","title":"\ud83d\udee0\ufe0f Building Demos","text":"<p>Clone the target library you would like to run the demos for. You can download just one or both if you have both devices.</p> LPC4078STM32F103 <pre><code>git clone https://github.com/libhal/libhal-lpc40\ncd libhal-lpc40/demos\n</code></pre> <pre><code>git clone https://github.com/libhal/libhal-stm32f1\ncd libhal-stm32f1/demos\n</code></pre> <p>This command will install the profiles for the ARM cortex processor and LPC40 series microcontrollers. The LPC40 microcontrollers are: <code>lpc4072</code>, <code>lpc4074</code>, <code>lpc4076</code>, <code>lpc4078</code>, and <code>lpc4088</code>.</p> <p>The LPC40 profiles import <code>cortex-m4</code> and <code>cortex-m4f</code> profiles from the ARM cortex processor library <code>libhal-armcortex</code> and thus need to be installed as well.</p> LPC4078STM32F103 <pre><code>conan config install -sf conan/profiles/ -tf profiles https://github.com/libhal/libhal-armcortex.git\nconan config install -sf conan/profiles/ -tf profiles https://github.com/libhal/libhal-lpc40.git\n</code></pre> <pre><code>conan config install -sf conan/profiles/ -tf profiles https://github.com/libhal/libhal-armcortex.git\nconan config install -sf conan/profiles/ -tf profiles https://github.com/libhal/libhal-stm32f1.git\n</code></pre> <p>To build using conan and cmake, you just need to run the following:</p> LPC4078STM32F103 <pre><code>conan build . -pr lpc4078 -s build_type=MinSizeRel\n</code></pre> <pre><code>conan build . -pr stm32f103 -s build_type=MinSizeRel\n</code></pre> <p>Note</p> <p>You may need to add the argument <code>-b missing</code> at the end of the above command if you get an error stating that the prebuilt binaries are missing. <code>-b missing</code> will build them locally for your machine. After which those libraries will be cached on your machine and you'll no longer need to include those arguments.</p> <p>To build a binary for a particular microcontroller, you need to specify the microcontroller you plan to target such as the <code>lpc4078</code> and the build type.</p> <p>Each microcontroller has different properties such as more or less ram and the presence or lack of a floating point unit.</p> <p>The following build types, <code>build_type</code> argument are available:</p> <ul> <li>\u274c Debug: No optimization, do not recommend, normally used for unit   testing.</li> <li>\ud83e\uddea RelWithDebInfo: Turn on some optimizations to reduce binary size and   improve performance while still maintaining the structure to make   debugging easier. Recommended for testing and prototyping.</li> <li>\u26a1\ufe0f Release: Turn on optimizations and favor higher performance   optimizations over space saving optimizations.</li> <li>\ud83d\udddc\ufe0f MinSizeRel: Turn on optimizations and favor higher space saving   optimizations over higher performance.</li> </ul> <p>Note that <code>Release</code> and <code>MinSizeRel</code> build types both usually produce binaries faster and smaller than <code>RelWithDebInfo</code> and thus should definitely be used in production.</p> <p>When this completes you should have some applications in the <code>build/lpc4078/MinSizeRel/</code> with names such as <code>uart.elf</code> or <code>blinker.elf</code>.</p> <p>Error</p> <p>You can get this error if the arm gnu toolchain wasn't installed correctly and the cmake toolchain was already generated.</p> <pre><code>  The CMAKE_CXX_COMPILER:\n\n    /Users/kammce/.conan2/p/b/arm-ged7418b49387e/p/bin/bin/arm-none-eabi-g++\n\n  is not a full path to an existing compiler tool.\n</code></pre> <p>Fix this by deleting the <code>build/</code> in the <code>demo</code> directory like so:</p> <pre><code>rm -r demos/build\n</code></pre>"},{"location":"getting_started/#uploading-demos-to-device","title":"\ud83d\udcbe Uploading Demos to Device","text":"<p>In order to complete this tutorial you'll one of these devices:</p> <ul> <li>LPC4078 MicroMod with SparkFun ATP board</li> <li>SJ2 Board</li> <li>STM32F103 MicroMod with SparkFun ATP board</li> <li>STM32 Blue Pill along with USB to serial adapter</li> </ul> <p>Question</p> <p>Don't know which serial port to use? Use this guide Find Arduino Port on Windows, Mac, and Linux from the MATLAB docs to help. Simply ignore that its made for Arduino, this guide will work for any serial USB device.</p> LPC4078STM32F103 <p>Install the <code>nxpprog</code> flashing software for LPC devices:</p> <pre><code>python3 -m pip install nxpprog\n</code></pre> <p>Tip</p> <p>On Ubuntu 22.04 you will need to use the command <code>python3.10</code> because the default python is usually 3.8.</p> <pre><code>python3.10 -m pip install nxpprog\n</code></pre> <pre><code>nxpprog --control --binary \"build/lpc4078/MinSizeRel/uart.elf.bin\" --device \"/dev/tty.usbserial-140\"\n</code></pre> <ul> <li>Replace <code>/dev/tty.usbserial-140</code> with the correct port.</li> <li>Replace <code>uart.elf.bin</code> with any other application found in the   <code>demos/applications/</code> directory.</li> </ul> <p>Install the <code>stm32loader</code> flashing software for STM32 devices:</p> <pre><code>python3 -m pip install stm32loader\n</code></pre> <p>then</p> <pre><code>stm32loader -p /dev/tty.usbserial-10 -e -w -v demos/build/stm32f103c8/Debug/blinker.elf.bin\n</code></pre> <p>Replace <code>/dev/tty.usbserial-10</code> with the correct port.</p> <p>Use <code>demos/build/stm32f103c8/Debug/blinker.elf.bin</code> or replace it with any other application to be uploaded.</p>"},{"location":"getting_started/#creating-a-new-project","title":"\ud83c\udf89 Creating a new Project","text":"<p>Start by cloning <code>libhal-starter</code>:</p> <pre><code>git clone https://github.com/libhal/libhal-starter.git\n</code></pre> <p>Take a look at the <code>README.md</code> of libhal/libhal-starter to get details about how to modify the starter project and make it work for your needs.</p>"},{"location":"summary/","title":"Summary","text":"<ul> <li>\ud83c\udfe1 Home</li> <li>\ud83d\ude80 Getting Started</li> <li>\ud83d\udcd6 User Guide</li> <li>\ud83e\uddf1 Fundamentals of libhal</li> <li>\ud83d\udd17 Interfaces in Software Development and libhal</li> <li>\ud83c\udfaf Debugging Code with PyOCD</li> <li>\ud83c\udf9a\ufe0f Configuration</li> <li>\ud83e\udea4 Error Handling in libhal using Boost.LEAF</li> <li>\u2696\ufe0f Policies &amp; FAQ</li> <li>\ud83d\udcda Contributor Guides</li> <li>\ud83d\udcdc Design Philosophy</li> <li>\ud83d\uddc3\ufe0f Organization</li> <li>\ud83c\udfa8 Style Guide</li> <li>\ud83d\udd39 Library Development Guide</li> <li>\ud83d\udcbb VSCode Setup</li> <li>\ud83c\udfd7\ufe0f Architectural Design Decisions</li> <li>\ud83d\udcca Project Information</li> <li>\ud83d\udfe2 Library Status \ud83d\udd34</li> <li>About</li> <li>\ud83e\udde9 APIs</li> <li>\ud83d\udce6 Libraries<ul> <li>api/namespacehal*.md</li> </ul> </li> <li>\ud83d\uddc2\ufe0f Files</li> <li>\u26d3\ufe0f Hierarchy</li> <li>\u26aa\ufe0f Misc<ul> <li>api/*.md</li> </ul> </li> </ul>"},{"location":"contributor_guide/architecture/","title":"\ud83c\udfd7\ufe0f Architectural Design Decisions","text":""},{"location":"contributor_guide/architecture/#a1-always-use-modern-c","title":"A.1 Always use modern C++","text":"<p>libhal uses the modern C++. Meaning that libhal is will follow the most modern and available compilers available. When a sufficient number of features have become available in both GCC &amp; Clang and are determined to be useful to libhal libhal will increment its major number to indicate that it has upgraded compiler versions.</p> <p>This decision exists to escape the issues of vendor and toolchain lock in thats prevalant in the C++ and embedded industry. With sufficient testing, upgrading compilers shouldn't result in bugs in applications.</p>"},{"location":"contributor_guide/architecture/#a2-interface-design-choices","title":"A.2 Interface Design Choices","text":"<p>Interfaces MUST follow this layout:</p> <ul> <li>Use <code>#pragma once</code> at the start of the file: Simpler than an include guard</li> <li>All <code>virtual</code> functions must be private &amp; each <code>virtual</code> functions is   accompanied by a public API that is used to call the virtual API</li> <li>The return type of each API MUST be a <code>result&lt;T&gt;</code> where <code>T</code> is a structure.</li> </ul> <p>Pragma once is needed to ensure files are included once. Its also less error prone then hand writing include guards.</p> <p>The reasons for a private virtual with public API can be found in this article.</p> <p>Returning a structure for each API means that, in the future, if the return type needs to be extended, it can be done without breaking down stream libraries. For example:</p> <pre><code>class adc {\n  struct read_t { // V1\n    float percentage;\n  };\n  struct read_t { // V2\n    float percentage;\n    // Optional field that is default initialized to std::nullopt indicating\n    // that it defaults to not exist\n    std::optional&lt;uint8_t&gt; bit_resolution = std::nullopt;\n  };\n};\n</code></pre> <p>Given that the field <code>bit_resolution</code> is an optional, code looking for it can determine if it is available or not, and code that never used it can ignore it.</p>"},{"location":"contributor_guide/architecture/#a21-no-utility-methods-in-interfaces-ufcs","title":"A.2.1 No utility methods in interfaces (UFCS)","text":"<p>Utility functions shall not exist in interface definitions. For example, <code>hal::i2c</code> could have a <code>hal::i2c::write()</code> and <code>hal::i2c::read()</code> function implemented in its interface.</p> <p>This has the effect of reducing the number of headers in the interface files and dependencies. This, in turn, results in an interface that is minimal, clean, and simple.</p> <p>The major purpose of this is to keep compile times down as much possible for each interface. This also ensures that the \"pay-for-what-you-use\" model is followed. No need to pay for a utility you never planned to use.</p> <p>The final reason is in preparation for UFCS (Unified Function Call Syntax). UFCS is a proposal for C++23 and C++26. It did not get into C++23 but is slated for review in 26. For more details see this page What is unified function call syntax anyway?.</p>"},{"location":"contributor_guide/architecture/#a3-using-tweak-files-over-macros","title":"A.3 Using tweak files over macros","text":"<p>Tweak files were used as an alternative to MACROS. MACROs can be quite problematic in many situations and are advised against in the core C++ guidelines. The benefits of tweak files can be found here.</p>"},{"location":"contributor_guide/architecture/#a4-header-only-implementations-see-amendment-a21","title":"A.4 \u274c Header Only Implementations \u27a1\ufe0f (See Amendment A.21)","text":"<p>libhal libraries and drivers are, in general, header-only. libhal uses header only implementations in order to enable the broadest set of package managers, build system and projects to use it.</p> <p>The strongest reason for a header-only approach is due to the fact that libhal libraries never intend to be distributed in prebuilt binaries. Conan is designed to ship with prebuilt binaries or build against the host machine. These settings can be altered, but you still end up with a single global prebuilt binary for a driver does not make sense when that driver could be used in a variety of environments such as the host device for host side tests, a specific target device, and a target device that is in the family of that specific target device.</p> <p>For example, lets consider liblpc40xx. If you are building to target the lpc4078 chip then that prebuilt ought to be built with usage of FPU registers enabled. But if you use that same prebuilt with the lpc4074, you'll find that the program crashes because the 74 variant does not have an FPU. You can attempt make a prebuilt binary for ever possible build variation that an embedded engineer may want, but you'll always come up short. The better approach is to simply build the library each time, thus ensuring that the build flags are considered each time.</p> <p>If compile-times are a concern, there are reasonably easy methods for managing this. See Handling Long Compile Times.</p>"},{"location":"contributor_guide/architecture/#a5-encapsulated-memory-mapped-classes","title":"A.5 Encapsulated Memory Mapped Classes","text":"<p>Target drivers that use Memory-Mapped-IO usually come with a vendor generated header file that describes each peripheral as a structure type, along with bit mask MACROs, and MACROs that result in pointers to each peripheral in memory. The main problem using these headers files causes is naming conflicts. Many of these vendor generated headers work with both C and C++. Meaning that namespaces are not utilized. And many do not expect that they will be used in an environment where another vendor generated header file will exists. So no care is taken to ensure that the names of the types are unique. This WILL cause linker errors as the linker sees both <code>GPIO_TypeDef</code> from an STM library and <code>GPIO_TypeDef</code> from an LPC library that aren't the same.</p> <p>Because of this we have style S.x Encapsulated Memory Mapped classes guideline.</p>"},{"location":"contributor_guide/architecture/#a6-using-halfunction_ref-over-stdfunction","title":"A.6 Using hal::function_ref over std::function","text":"<p><code>std::function</code> has all of the flexibility and functionality needed, but it has the potential to allocate and requires potentially expensive copy operations when passed by value.</p> <p><code>hal::function_ref</code> is a non-owning version of the <code>std::function</code>, with a size of just two pointers. <code>hal::function_ref</code> fits most use cases in that class functions that take them only need them for the duration of the function and do not need to own them for later.</p> <p>!!! info <code>hal::function_ref</code> is an alias for <code>tl:function_ref</code> which comes from     the project     TartanLlama/function_ref.</p>"},{"location":"contributor_guide/architecture/#a7-using-virtual-runtime-polymorphism","title":"A.7 Using <code>virtual</code> (runtime) polymorphism","text":"<p>Polymorphism is critical for libhal to reach the goals of flexible and easy of use. Static based polymorphism, by its nature, is inflexible at runtime and can be quite complicated to work with.</p> <p>Runtime polymorphism, or the usage of <code>virtual</code> enables a broader scope of flexibility and isolation between drivers and application logic. The only downside to using <code>virtual</code> polymorphism is the cost of a virtual function call. But the actual cost of making a virtual function call is usually tiny in comparison to the work performed in the actual API call. In most cases the call latency and lack of inlining of a virtual call isn't an important factor in most applications.</p> <p>And over all, along with the broad amount of flexibility comes the ease of use. Virtual polymorphism for interfaces is very easy to perform and has a ton of language support.</p>"},{"location":"contributor_guide/architecture/#a8-strongly-leverage-package-managers","title":"A.8 Strongly Leverage Package Managers","text":"<p>Finding and integration libraries into C++ programs is a pain. Doing the same thing for embedded is doubly so, especially if there is vendor IDE lock in. libhal seeks to escape this by using the available package managers and indexes.</p> <p>Libhal was designed around and split up into parts that each come together via these package managers. The purpose of this design is to achieve:</p> <ul> <li>Stable version and release control for each library</li> <li>Can be easily found the indexes</li> <li>Ease of integration</li> </ul>"},{"location":"contributor_guide/architecture/#a9-foundation-interface-stability","title":"A.9 Foundation &amp; Interface Stability","text":"<p><code>libhal-util</code>, <code>libhal-mock</code> and <code>libhal-soft</code> were all apart of <code>libhal</code> originally, but due to the constant changes and API breaks in those categories of code, the version number of <code>libhal</code> would increment constantly, shifting the foundation of the ecosystem. To prevent constant churn and API breaks <code>libahl</code> was split into those 4 libraries.</p> <p>The goal is to keep the version number for <code>libhal</code> constant for long periods of time to prevent breaking down stream libraries, drivers, and applications.</p>"},{"location":"contributor_guide/architecture/#a10-libhal-driver-directory","title":"A.10 libhal driver directory","text":"<p>One of the libhal repos will contain a directory of libhal libraries that extend it along with which interfaces it implements and what type of library it is.</p> <p>Official libhal libraries must go into the directory. Developers outside of the libhal organization can also contribute to and opt into this directory by making a PR to the repo containing the directory.</p> <p>The purpose of this is to make finding and exploring the available set of drivers easier for the end developer by having them all in one place.</p>"},{"location":"contributor_guide/architecture/#a11-github-actions-remote-workflows","title":"A.11 Github Actions &amp; Remote Workflows","text":"<p>libhal uses github and github action \"workflow_dispatch\" to allow other repos to reuse libhal's continuous integration steps. The actions are configurable via input parameters to allow libraries to customize and control how the CI works.</p> <p>libhal's CI attempts to use as many tools as reasonable to make sure that the C++ source code follows the style guide, C++ core guidelines and retains a certain level of quality. All offical libhal libaries must opt in to the common libhal/libhal workflow.</p> <p>This helps to ensure that all projects are held to the same standard and quality. The workflow files can be found in <code>libhal/libhal/.github/workflows</code>.</p>"},{"location":"contributor_guide/architecture/#a12-boostut-as-our-unit-testing-framework","title":"A.12 Boost.UT as our unit testing framework","text":"<p>Boost.UT was chosen for its lack of macros, stunning compile time performance, and its ease of use.</p>"},{"location":"contributor_guide/architecture/#a13-boostleaf-for-error-handling","title":"A.13 Boost.LEAF for error handling","text":"<p>One major issue with any project is handling errors. Because the <code>libhal</code> interfaces can be used in such broad environments, it is hard to determine what the BEST error type in advance could work for all users. Some use error codes, some use <code>std::expected&lt;T, E&gt;</code>, and some use exceptions.</p> <p>Error codes are problematic as they tend to lack details and context around an error. Sometimes the documentation along with the error code provides all of the necessary context, but many times more context is needed.</p> <p><code>std::expected&lt;T, E&gt;</code> seems like a better alternative to error codes, but... is it really? What should <code>E</code> be? An error code? What if we have it be an error code and a const string. What if we want a file name and function name? What about a line number? What about 16 bytes for holding context information about the error? That should be enough, right? What about- what about- what about? ... wait, how big is this error type? 32 bytes? Wasn't this supposed to be light weight? Unfortunately, <code>std::expected</code> is not a good choice for interfaces with extremely broad and unknowable of error states. This forces the error type to be massive to accommodate everything and everyone.</p> <p>Exceptions somewhat fix this issue but are still lacking. The benefit of exceptions is that you can throw just about anything, meaning the developer can provide loads of information in the thrown object. But exceptions fail on 4 counts:</p> <ul> <li>Exceptions tend to not be available for embedded systems, either due to a     toolchain not compiling with them enabled or because a project has strict     requirements that forbid exceptions.</li> <li>When exceptions do occur, the amount of time it takes to reach its catch can     take a long time, longer than what real time applications can handle.</li> <li>Normally requires heap allocation</li> <li>Exceptions can only throw one type and the cost of those thrown exceptions     are always paid for.</li> </ul> <p>Boost.LEAF has the following properties:</p> <ul> <li>Portable single-header format, no dependencies.</li> <li>Tiny code size when configured for embedded development.</li> <li>No dynamic memory allocations, even with very large payloads.</li> <li>Deterministic unbiased efficiency on the \"happy\" path and the \"sad\" path.</li> <li>Error objects are handled in constant time, independent of call stack depth.</li> <li>Can be used with or without exception handling.</li> <li>Can throw more than 1 error at a time</li> </ul> <p>All of these features are critical for libhal to have the performance for real time applications.</p> <p>The last feature is important for debugging, bug reports, and context specific error handling. Boost.LEAF gives the driver the choice to emit several error types and allows the user to pick out which one they would like to opt to catch if any of them. This can be used to capture an error code as well as s snapshot of the register map of a peripheral, the object's current state or even a debug message.</p>"},{"location":"contributor_guide/architecture/#a14-using-statement-expressions-with-hal_check","title":"A.14 Using Statement Expressions with <code>HAL_CHECK()</code>","text":"<p><code>HAL_CHECK()</code> is the only MACRO in <code>libhal</code>. It exists because there is nothing like Rust's <code>?</code> operator which either unwraps a value or returns an error from the current function. The \"Statement Expression\" only works with GCC &amp; Clang which is one of the reasons why <code>libhal</code> only supports those compilers. Compare the following two expressions:</p> <pre><code>// 1. Using statement expressions\nauto percentage = HAL_CHECK(adc.read()).percentage;\n\n// 2. Without using statement expressions\nHAL_CHECK(adc_read_temporary, adc.read());\nauto percentage = adc_read_temporary.percentage;\n</code></pre> <p>The second option looks very unnatural and require explanation. On the other hand users who have never seen <code>HAL_CHECK()</code> in action have an immediate idea of how it works in the first section of the code. Portability to other compilers was sacrificed in order to make the code easier to read, understand, and write.</p>"},{"location":"contributor_guide/architecture/#a15-libhal-will-not-use-fixed-point","title":"A.15 <code>libhal</code> WILL NOT use fixed point","text":"<p>Because fixed point will NOT result in better performance or space savings compared to SOFTWARE floating point. Team did venture to use fixed point throughout the entire code base and when we felt that the fixed point code reached a point where it was usable everywhere, we benchmarked it and got these:</p> <pre><code>double_time            = 8921794\n[i64 +Round]fixed_time = 4558238 (best fixed point option)\n[soft]float_time       = 1424913\n[i64 -Round]fixed_time = 1410720 (precision issues)\n[i32 +Round]fixed_time = 815107  (will easily overflow)\n[hard]float_time       = 110089  (not always available)\n[i32 -Round]fixed_time = 95085   (will not actually work)\n</code></pre> <p>Here is an old gist of the example: kammce/fixed_v_float.cpp</p> <p>The above metrics were for a program that run a map function to map an input number from one range to another range. The numbers on the right hand side are the number of cycles of a Arm Cortex M4F DWT counter. Fixed point 32-bit integers is enough for a representation but to handle arithmetic like multiplication, 64-bit integers were needed. Those 64-bit operations resulted in computation time approaching double floating point. If a system used 32-bit floats, the 32-bit fixed point would be ~4x slower. If a system used double floating point in software mode, it will only be ~2x slower than 32-bit fixed point. Fixed point, over all, is more expensive in terms of space and time.</p> <p>If you don't believe the metrics measured here, you can also check fpm performance metrics. Notice how fpm fairs far worse for anything that isn't addition/subtraction.</p> <p>See these articles for more details:</p> <ul> <li>You're Going To Have To   Think!</li> <li>WHY FIXED POINT WON'T CURE YOUR FLOATING POINT   BLUES</li> <li>WHY RATIONALS WON\u2019T CURE YOUR FLOATING POINT   BLUES</li> <li>Why Computer Algebra Won\u2019t Cure Your Floating Point   Blues</li> <li>Why Interval Arithmetic Won\u2019t Cure Your Floating Point   Blues</li> </ul>"},{"location":"contributor_guide/architecture/#a16-libhal-does-not-use-a-units-library","title":"A.16 <code>libhal</code> does NOT use a units library","text":"<p>Unit libraries have the potential to really help prevent an entire category of unit based errors, it is also extremely difficult and annoying to use.</p> <p>Th article Unit of measurement libraries, their popularity and suitability goes into detail about the usability issues faced by unit libraries. Because, at the time of writing <code>libhal</code> there is not a unit library that is easy to use and concise, <code>libhal</code> decided to simply stick with 32-bit floats and helper UDLs.</p>"},{"location":"contributor_guide/architecture/#a17-always-return-halresultt-from-every-api","title":"A.17 Always return <code>hal::result&lt;T&gt;</code> from every API","text":"<p>Every interface in libhal returns a <code>hal::result&lt;T&gt;</code> type.</p> <p>The return types should be a <code>result&lt;T&gt;</code> because the implementation could be an abstraction for anything. As an example, it could come from an I2C to PWM generator and if something goes wrong with the i2c communication, the information must be emitted from the function.</p>"},{"location":"contributor_guide/architecture/#a18-using-inplace_functionhalcallback-for-interrupt-callbacks","title":"A.18 Using <code>inplace_function</code>/<code>hal::callback</code> for interrupt callbacks","text":"<p>There are interfaces such as <code>hal::can</code>, <code>hal::interrupt_pin</code>, and <code>hal::timer</code> that all have APIs for setting a callback.</p> <p>Because those callbacks could be lambdas, function objects, pure functions, or other callable types, we need a polymorphic type erased function type that can take any callable type as input and call it when its <code>operator()</code> is called.</p> <p>The options for these callbacks are:</p> <ul> <li><code>std::function</code><ul> <li>PROS<ul> <li>Part of the standard library</li> <li>Can take any callable type without restrictions</li> </ul> </li> <li>CONS<ul> <li>Allocating (compiler implementations will use SBO but the size of   those buffers are not specified in the standard and should not be   relied upon)</li> <li>Can be quite large in size (40 bytes on 32-bit arm)</li> </ul> </li> </ul> </li> <li><code>function_ref</code><ul> <li>PROS<ul> <li>Very lightweight (very fast construction)</li> <li>Very small size (2 pointers in size)</li> </ul> </li> <li>CONS<ul> <li>For this to work as a callback, the callable passed to the   <code>function_ref</code> must have a lifetime that is greater than the object   implementing the interface.</li> </ul> </li> </ul> </li> <li><code>inplace_function</code><ul> <li>PROS<ul> <li>Works and behaves just like <code>std::function</code></li> </ul> </li> <li>CONS<ul> <li>Fixed callable size limit</li> </ul> </li> </ul> </li> </ul> <p><code>std::function</code> is automatically out because it is allocating. Using <code>std::function</code> for any interface API would ensure that applications that disallow dynamic allocations after boot or in general could never use them.</p> <p><code>function_ref</code> has two great PROS but the largets CON is lifetime issues that are really easy to fall into. Specifically something like this:</p> <pre><code>obj.on_event([&amp;single_capture]() {\n  // does a thing  ...\n});\n</code></pre> <p>The lambda is actually a temporary! So after this call it is out of scope and no longer exists. If the reference to temporary is stored and called later, the code WILL suffer from a \"stack use after scope\" violation which is undefined behavior.</p> <p><code>inplace_function</code> has all of the features of <code>std::function</code> but with limited size. Due to this, constructing an <code>inplace_function</code> is deterministic and relatively light weight.</p>"},{"location":"contributor_guide/architecture/#a19-halcallback-sizing","title":"A.19 <code>hal::callback</code> sizing","text":"<p><code>hal::callback</code> is an alias to <code>inplace_function</code> with a buffer size of 2 pointers (<code>sizeof(std::intptr_t) * 2</code>). This size was chosen in order to be small and easily storable. Two pointers worth of size should be enough to hold a pointer to <code>this</code> in classes as well a pointer to some sort of state object.</p> <p>The size of the callback object was not choosen in order to improve the performance of calling callback setting class functions. Even with the small size of <code>hal::callback</code>, its too large to take advantage of register based parameter passing. Thus the size of 2 pointers was mostly to help in keeping the memory footprint of the <code>callback</code> small. In most cases, setting an callback is something that is either done once or done very infrequently, and thus does not get much of a benefit from higher performance function calls.</p>"},{"location":"contributor_guide/architecture/#a20-why-functions-that-setup-events-do-not-return-halstatus","title":"A.20 Why functions that setup events do not return <code>hal::status</code>","text":"<p>Functions like <code>hal::can::on_receive()</code> and <code>hal::interrupt_pin::on_trigger()</code> return void and not <code>hal::status</code> like other APIs. Thus these functions cannot return an error and are considered \"infallible\". There infallibility guarantee makes constructing drivers using these interfaces easier. It also eliminates the need for drivers to concern themselves with handling errors from these APIs.</p> <p>This guarantee is easily made, because having any one of these APIs fail IS A bug and not something that a developer should or could be responsible with handling. These APIs MUST be implemented as target library peripheral drivers because setting interrupts is something that only target and processor libraries can do. Setting up and configuring interrupts is only possible if the processor supports it. Being apart of a target library means that they know exactly the set of possible configurations that are allowed. This also means that constructing a target peripheral with interrupt customization can be include compile time checks as well.</p>"},{"location":"contributor_guide/architecture/#a21-critical-importance-of-providing-prebuilt-binaries","title":"A.21 Critical importance of providing prebuilt binaries","text":"<p>This amends architectural component A.4 and pivots away from header only libraries over to prebuilt binaries.</p> <p>The following are the reasons why supporting, producing and distibuting prebuilt binaries is critical to libhal.</p> <ul> <li>\u23f1\ufe0f Faster compilation times: When a project grows in size, compiling   a C++ codebase can become time-consuming. By using precompiled binaries,   the compiler has less work to do because portions of the code have already   been compiled. It doesn't need to parse and compile the same headers over and   over again. Developers will refuse to use libhal if it results in extremely   long compilation times. They will tire of the project and seek faster to   compile alternatives.</li> <li>\u2705 Consistency: With precompiled binaries, you can be sure that the same   code will be compiled in the same way, which can reduce inconsistencies   between different environments or build configurations. libhal will not be   taken seriously if libhal didn't use prebuilt binaries and also support   producing them. Distributing consistent code in a consistent form will be a   requirement for many organizations seeking to use libhal.</li> <li>\ud83d\udce6 Code distribution and updates: When distributing C++ code, rather than   give out the full source code or require users to compile it themselves,   providing a precompiled binary is more user-friendly. Updates to the program   can also be handled by replacing the old binaries with the new ones, without   requiring the end-user to handle the compilation process. The philosophy of   conan regarding library packages is that, at their core, C++ libraries are   header files and prebuilt binaries.</li> <li>\ud83d\udd12 Protection of Intellectual Property: Precompiled binaries are much   harder to reverse-engineer than raw source code. If a developer wants to   write an application and distribute the binary, but the C++ code contains   proprietary algorithms or trade secrets that you don't want to expose to the   public, distributing it as a precompiled binary can provide an additional   layer of protection.</li> </ul> <p>In order to provide the best experience for our developers as well as necessary features of the platform, libhal emphasizes prebuilt libraries over header only.</p> <p>Note</p> <p>Why the sudden change from A.4 to this? Supporting header-only made bringing up libhal much easier. The process of implementing prebuilt binaries required adding additional architecture settings, required the use of conan profiles to make the arm-gnu-toolchain available globally for all packages, figuring out how to insert architectural compiler flags and ensure they propogate to all packages took time and was a complex process. And header-only libraries allowed the initial version of libhal to bypass all of this.</p>"},{"location":"contributor_guide/arm_cortex_bring_up/","title":"\ud83d\udd38 Bare-Metal ARM Cortex Target Bring-Up","text":"<p>Info</p> <p>TO BE MOVED TO <code>libhal-armcortex</code> REPO</p> <p>This guide will step you through making a libhal + conan target library for a arm processor microcontroller. Unlike libhal applications that can be executed on a machine running an OS like linux, example Raspberry Pi and Beagle Boards, you cannot just execute the binary.</p> <p>This guide assumes that <code>libhal-library</code> was used as a template and has already updated and changed all of the names from <code>libhal-library</code> to the appropriate library name.</p> <p>In order to build an application that can be loaded and executed onto a microcontroller you only need:</p> <ol> <li>Add <code>libhal-armcortex</code> as a dependency</li> <li>Provide a linker script for each microcontroller</li> <li>Determine minimum compiler flags for each microcontroller</li> <li>Provide a library component for that microcontroller</li> </ol> <p>The rest can be handled by the <code>arm-gnu-embedded-toolchain</code>'s <code>crt0</code> implementation, the <code>arm-gnu-embedded-toolchain</code> conan package and the <code>libhal-armcortex</code> conan package.</p>"},{"location":"contributor_guide/arm_cortex_bring_up/#adding-the-libhal-armcortex-dependency","title":"Adding the <code>libhal-armcortex</code> dependency","text":"<p>Simply add <code>libhal-armcortex</code> to your <code>requirements()</code> method:</p> <pre><code>def requirements(self):\n    # ...\n    self.requires(\"libhal-armcortex/[^1.0.1]\")\n</code></pre>"},{"location":"contributor_guide/arm_cortex_bring_up/#writing-the-linker-scripts","title":"Writing the linker scripts","text":""},{"location":"contributor_guide/arm_cortex_bring_up/#setup-linker-script-directory","title":"Setup linker script directory","text":"<p>Create a <code>linker_scripts</code> directory at the root of the library package. Add <code>linker_scripts/*</code> directory to the export sources in the package <code>conanfile.py</code>, like so:</p> <pre><code>exports_sources = \"include/*\", \"linker_scripts/*\", \"tests/*\", \"LICENSE\"\n</code></pre>"},{"location":"contributor_guide/arm_cortex_bring_up/#finding-linker-scripts-info","title":"Finding linker scripts info","text":"<p>Lets consider the <code>lpc4074</code> microcontroller. What you'll need to figure out is:</p> <ol> <li>Flash memory address &amp; size</li> <li>Ram memory address &amp; size</li> </ol> <p>These sections are part of whats called the \"memory map\". Most modern day systems use a system called \"Memory-mapped I/O\" which means that the system uses the same address space to address both memory and I/O devices. In this case we simply want to find the addresses of the flash memory and ram memory. This information can be found in the data sheet or user manual of the chip.</p> <p>The LPC40 series of microcontrollers will be used for this example: The memory map can be found on page 52 of the <code>LPC408X_7X.pdf</code> data sheet or page 14 of the <code>UM10562.pdf</code> user manual.</p> <p></p> <p> Figure 1. LPC40xx Memory Map </p> <p>Here you can see that flash starts at address <code>0x00000000</code> for all sizes of flash memory. The SRAM locations all start at <code>0x10000000</code> for all sizes of SRAM. This chart does not provide which chips have which ram and flash sizes.</p> <p>Looking through the data sheet and searching for terms like \"part numbers\", \"ordering options\", or even just the number 512 (the maximum flash size), eventually this section will appear:</p> <p></p> <p> Figure 2. LPC40xx Part Ordering Info part 1 </p> <p></p> <p> Figure 3. LPC40xx Part Ordering Info part 2 </p> <p>Now all of the information to write the linker scripts is available:</p> lpc4072.ldlpc4074.ldlpc4076.ldlpc4078.ldlpc4088.ld <pre><code>__flash = 0x00000000;\n__flash_size = 64K;\n__ram = 0x10000000;\n__ram_size = 16K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <pre><code>__flash = 0x00000000;\n__flash_size = 128K;\n__ram = 0x10000000;\n__ram_size = 32K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <pre><code>__flash = 0x00000000;\n__flash_size = 256K;\n__ram = 0x10000000;\n__ram_size = 64K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <pre><code>__flash = 0x00000000;\n__flash_size = 512K;\n__ram = 0x10000000;\n__ram_size = 64K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <pre><code>__flash = 0x00000000;\n__flash_size = 512K;\n__ram = 0x10000000;\n__ram_size = 64K;\n\nINCLUDE \"libhal-armcortex/standard.ld\"\n</code></pre> <p>Question</p> <p>You may be wondering why the RAM size is 64kB and not 96kB for some of the linker scripts and thats due to the fact that the LPC40xx series has a dual SRAM architecture. To keep this simple, only the largest RAM block is supported.</p> <p>The linker script only needs 4 lines as <code>libhal-armcortex</code> provides a standard linker script for ARM microcontrollers supporting 1 flash memory and 1 ram device. Defining the <code>__flash</code>, <code>__flash_size</code>, <code>__ram</code>, and <code>__ram_size</code> linker script variables is all that is needed to make a usable linker script.</p> <p>There are plans to support dual flash, dual ram and other varieties of flash and ram combinations in the future in <code>libhal-armcortex</code>.</p> <p>Warning</p> <p>Many of the microcontrollers come in different packages and may have some differences in the number of peripherals they support, pins they have and performance. The linker script does not need to worry about such differences and thus, a linker script should NOT be made for every possible chip variety in the series but for the common flash sizes and ram sizes for each.</p>"},{"location":"contributor_guide/arm_cortex_bring_up/#compiler-flags","title":"Compiler flags","text":""},{"location":"contributor_guide/arm_cortex_bring_up/#processor-flags","title":"Processor flags","text":"<p>The data sheet will include information about the processor. The compiler flag will match the following based on the CPU:</p> <ul> <li><code>-mcpu=cortex-m0</code></li> <li><code>-mcpu=cortex-m0plus</code> (cortex-M0+)</li> <li><code>-mcpu=cortex-m1</code></li> <li><code>-mcpu=cortex-m3</code></li> <li><code>-mcpu=cortex-m4</code></li> <li><code>-mcpu=cortex-m7</code></li> <li><code>-mcpu=cortex-m23</code></li> <li><code>-mcpu=cortex-m33</code></li> <li><code>-mcpu=cortex-m35p</code></li> <li><code>-mcpu=cortex-m55</code></li> <li><code>-mcpu=cortex-m85</code></li> <li><code>-mcpu=cortex-m1.small-multiply</code></li> <li><code>-mcpu=cortex-m0.small-multiply</code></li> <li><code>-mcpu=cortex-m0plus.small-multiply</code></li> </ul>"},{"location":"contributor_guide/arm_cortex_bring_up/#floating-point-support","title":"Floating Point Support","text":"<p>After one of the following to the architecture flags:</p> <ul> <li><code>-mfloat-abi=soft</code>: if the processor is an cortex-m3 or below</li> <li><code>-mfloat-abi=softfp</code>: if the processor is a cortex-m4 and above AND also has   a floating point unit. This can be determined by searching the data sheet.</li> </ul>"},{"location":"contributor_guide/arm_cortex_bring_up/#creating-components-for-the-library","title":"Creating components for the library","text":"<p>libhal target library's split up the library into components, one for each microcontroller variant. For LPC40 that split would look like: <code>libhal::lpc4072</code>, <code>libhal::lpc4074</code>, <code>libhal::lpc4076</code>, <code>libhal::lpc4078</code>, and <code>libhal::lpc4088</code>. When a build system, for example, uses the <code>libhal::lpc4078</code> component, it includes the necessary compiler flags and linker script selection.</p> <p>Along with these components, will be a special generic component named <code>libhal::lpc</code> which does not provide any compiler flags or linker script. This special target is used for applications that want to use their own linker script, or for software running on a host machine like simulations or unit tests.</p> <p>To add components it must be added in the <code>package_info</code> method of the <code>ConanFile</code> package class. Here is what it looks like for the <code>libhal-lpc</code> library. Copy this section and tailor it to your needs.</p> <pre><code>def package_info(self):\n  # Specify, for the component, all requirements of the package\n  requirements_list = [\"libhal::libhal\",\n                       \"libhal-util::libhal-util\",\n                       \"libhal-armcortex::libhal-armcortex\",\n                       \"ring-span-lite::ring-span-lite\"]\n\n  # List of REQUIRED compiler flags for the gnu-arm-embedded-toolchain for some\n  # of the chips. These are determined by the capabilities of the chip.\n  # For example all but the lpc4072 and lpc4074 have hardware floating point\n  # arithmetic support so they ought to use \"float-abi=softfp\" which uses the\n  # floating point hardware BUT is ABI compatible with the software\n  # implementation.\n  m4f_architecture_flags = [\n      \"-mcpu=cortex-m4\",\n      \"-mfloat-abi=softfp\",\n  ]\n\n  # List of REQUIRED compiler flags for the gnu-arm-embedded-toolchain for\n  # some of the chips. These are determined by the capabilities of the chip.\n  # For example the lpc4072 and lpc4074 do not have hardware floating point\n  # arithmetic support so they must use \"float-abi=soft\" for a software\n  # implementation.\n  m4_architecture_flags = [\n      \"-mcpu=cortex-m4\",\n      \"-mfloat-abi=soft\"\n  ]\n\n  # Create a path to the linker_script directory which resides in the\n  # package's package_folder.\n  linker_path = os.path.join(self.package_folder, \"linker_script\")\n\n  # Set the cmake file name\n  self.cpp_info.set_property(\"cmake_file_name\", \"libhal-lpc\")\n  # All the package to be found in anyway with cmake\n  self.cpp_info.set_property(\"cmake_find_mode\", \"both\")\n\n  # Create the special/generic component \"lpc\" and set its component name\n  self.cpp_info.components[\"lpc\"].set_property(\n      \"cmake_target_name\",  \"libhal::lpc\")\n\n  # This is where we add the path to our linker scripts to the set of linker\n  # flags.\n  self.cpp_info.components[\"lpc\"].exelinkflags.append(\"-L\" + linker_path)\n\n  # Add the list of requirements to the generic component\n  self.cpp_info.components[\"lpc\"].requires = requirements_list\n\n  # Helper function for creating components\n  def create_component(self, component, flags):\n\n      link_script = \"-Tlibhal-lpc/\" + component + \".ld\"\n      component_name = \"libhal::\" + component\n      self.cpp_info.components[component].set_property(\n          \"cmake_target_name\", component_name)\n      # Make the special component the only requirement for the component,\n      # inheriting all of the transitive dependencies.\n      self.cpp_info.components[component].requires = [\"lpc\"]\n      # Add the link script and flags to the component's linker flags and\n      # compiler flags\n      self.cpp_info.components[component].exelinkflags.append(link_script)\n      self.cpp_info.components[component].exelinkflags.extend(flags)\n      # Add flags to the cflags &amp; cxxflags to ensure that each compilation unit\n      # Knows the instruction set and float ABI\n      self.cpp_info.components[component].cflags = flags\n      self.cpp_info.components[component].cxxflags = flags\n\n  # Create the components for each chip.\n  create_component(self, \"lpc4072\", m4_architecture_flags)\n  create_component(self, \"lpc4074\", m4_architecture_flags)\n  create_component(self, \"lpc4076\", m4f_architecture_flags)\n  create_component(self, \"lpc4078\", m4f_architecture_flags)\n  create_component(self, \"lpc4088\", m4f_architecture_flags)\n</code></pre>"},{"location":"contributor_guide/arm_cortex_bring_up/#verifying","title":"Verifying","text":""},{"location":"contributor_guide/arm_cortex_bring_up/#creating-the-package","title":"Creating the package","text":"<p>Run <code>conan create .</code> in the folder with the <code>conanfile.py</code> recipe in it. The test package and build stages should show something like this during the cmake phase:</p> <pre><code>-- Conan: Component target declared 'libhal::lpc'\n-- Conan: Component target declared 'libhal::lpc4072'\n-- Conan: Component target declared 'libhal::lpc4074'\n-- Conan: Component target declared 'libhal::lpc4076'\n-- Conan: Component target declared 'libhal::lpc4078'\n-- Conan: Component target declared 'libhal::lpc4088'\n</code></pre>"},{"location":"contributor_guide/arm_cortex_bring_up/#testing-out-a-demo","title":"Testing out a demo","text":"<p>Create a demo and have it require the library. In this case the demo <code>conafile.py</code> may include:</p> <pre><code>from conan import ConanFile\nfrom conan.tools.cmake import CMake, cmake_layout\n\n\nclass Lpc40xxDemos(ConanFile):\n    settings = \"compiler\", \"build_type\"\n    generators = \"CMakeToolchain\", \"CMakeDeps\", \"VirtualBuildEnv\"\n\n    def requirements(self):\n        self.requires(\"libhal-lpc/1.1.4\") # &lt;-- change this\n        self.requires(\"libhal-util/[^1.0.0]\") # &lt;-- update this if necessary\n        self.tool_requires(\"gnu-arm-embedded-toolchain/11.3.0\")\n        self.tool_requires(\"cmake-arm-embedded/0.1.1\")\n\n    def layout(self):\n        cmake_layout(self)\n\n    def build(self):\n        cmake = CMake(self)\n        cmake.configure()\n        cmake.build()\n</code></pre> <p>Change the library name to the library you are creating.</p> <pre><code>self.tool_requires(\"gnu-arm-embedded-toolchain/11.3.0\")\nself.tool_requires(\"cmake-arm-embedded/0.1.1\")\n</code></pre> <p>The above two requirements are required to download and install the toolchain/compiler and the cmake toolchain/helper files. The project should compile if everything was done correctly.</p>"},{"location":"contributor_guide/library_guides/","title":"\ud83d\udd39 Library Development Guide","text":"<p>Info</p> <p>Documentation coming soon...</p>"},{"location":"contributor_guide/organization/","title":"\ud83d\uddc3\ufe0f Organization","text":"<p>This section will explain the different parts/repos of libhal organization and ecosystem and how they are organized.</p>"},{"location":"contributor_guide/organization/#target-libraries","title":"Target Libraries","text":"<p>Target libraries depend on processor/OS libraries. The target libraries will include drivers for peripherals contained within their chip packages or, in the case of development boards and SBC (single board computers), these can also contain drivers external to the main chip. Processor/OS libraries contain APIs specific to those platforms for doing such things as handling interrupt service routines, initializing memory and more.</p> <pre><code>flowchart LR\n    libhal\n    subgraph processor/OS\n      libriscvmcu\n      libarmcortex\n      libhal-linux\n    end\n    subgraph arm-targets\n      liblpc40xx\n      libstm32f10x\n    end\n    subgraph riscv-targets\n      libgv32f10x\n      libsifive\n    end\n    subgraph linux-targets\n      libhal-linux-generic\n      libraspi\n    end\n\n    libhal--&gt;libhal-linux\n    libhal--&gt;libriscvmcu\n    libhal--&gt;libarmcortex\n\n    libarmcortex--&gt;liblpc40xx\n    libarmcortex--&gt;libstm32f10x\n\n    libriscvmcu--&gt;libgv32f10x\n    libriscvmcu--&gt;libsifive\n\n    libhal-linux--&gt;libhal-linux-generic\n    libhal-linux--&gt;libraspi</code></pre>"},{"location":"contributor_guide/organization/#device-libraries","title":"Device Libraries","text":"<p>Device driver libraries have a very simple relationship tree. Device libraries just need the libhal interfaces to work. The implementations of those interfaces will come from a target library in the application.</p> <pre><code>flowchart TD\n    libhal\n    libhal--&gt;libhal-soft\n    libhal--&gt;libmpu\n    libhal--&gt;libesp8266\n    libhal--&gt;libdrv\n    libhal--&gt;libwii\n    libhal--&gt;liballegro-micro\n    libhal--&gt;libdisplay-ssd\n    libhal--&gt;libled-apa-sk\n    libhal--&gt;libmatrix</code></pre>"},{"location":"contributor_guide/organization/#typical-application","title":"Typical Application","text":"<p>Lets consider an application such as \"Pong\". A game of pong where we use an LED matrix and two Wii controllers using the STM32F103 microcontroller.</p> <pre><code>flowchart LR\n    libhal--&gt;libmatrix--&gt;app\n    libhal--&gt;libarmcortex--&gt;libstm32f10x --&gt;app\n    libhal--&gt;libwii--&gt;app</code></pre> <p>The <code>conanfile.txt</code> would look something like this:</p> <pre><code>[requires]\nlibstm32f10x/1.1.0\nlibmatrix/1.0.2\nlibwii/1.5.2\n\n[generators]\nCMakeToolchain\nCMakeDeps\nVirtualRunEnv\n</code></pre>"},{"location":"contributor_guide/organization/#application-libraries","title":"Application Libraries","text":"<p>Application libraries are effectively applications with no specific dependency on a particular target. The point of a Application library is to deploy a fully fledged application, but with customizable drivers. For example, the pong game mentioned earlier doesn't require a wii controller or a LED matrix specifically. You could take a <code>hal::display</code> interface (not currently available) and some <code>pong::gamepad</code> interface defined by the Application library that the developer can implement themselves. Then the pong Application can take your display, gamepad and additional information like, \"paddle size\" and \"font size\" and use it to generate a game of pong. The developer gets the opportunity to choose which parts they want for each. Maybe they want a very large TFT display or they want to use a LED matrix. Maybe they want to use a Stadia controller or maybe they want to make a controller out of capacitive sensors and bananas. The choices are endless.</p>"},{"location":"contributor_guide/organization/#finding-drivers","title":"\ud83d\udd0d Finding Drivers","text":"<p>To find drivers you can look in three locations</p> <ul> <li>libhal organization</li> <li>conan center index</li> <li>libhal driver index \u274c</li> </ul> <p>Example</p> <p>libhal driver index is not available currently and is key to finding drivers around the ecosystem.</p> <p>Search for the name of the device or target you are interested with with the prefix <code>lib</code> in front of it. Try not to be too specific though. For example, the <code>stm32f103c8t6</code> microcontroller target library drivers will be in the package <code>libstm32f10x</code>. The <code>mpu6050</code> accelerometer will be in <code>libmpu</code>.</p>"},{"location":"contributor_guide/organization/#reference-material","title":"\ud83d\udcd1 Reference Material","text":"<p>Reference material can be found in the <code>datasheets/</code> and <code>schematic/</code> folders. The layout of these directories match that <code>demos/</code>, where the first layer of folders are named after the microcontroller or board they describe.</p> <p>These folders are updated with relevant documents for easy access for our developers and contributors.</p>"},{"location":"contributor_guide/philosophy/","title":"\ud83d\udcdc Design Philosophy","text":"<p>These are the core design tenets that <code>libhal</code> and libraries extending it must seek to achieve with every design choice, line written, and architecture change made.</p>"},{"location":"contributor_guide/philosophy/#d1-multi-targeted","title":"D.1 Multi Targeted","text":"<p><code>libhal</code> and the libraries that extend it, should work anywhere. So long as the appropriate compiler or cross compiler is used, the driver should do as it is intended. The exception is <code>target</code> libraries which are designated to execute for a particular target. Even so, those <code>target</code> libraries MUST be unit testable on any host machine.</p>"},{"location":"contributor_guide/philosophy/#d2-light-weight","title":"D.2 Light Weight","text":"<p><code>libhal</code> should keep its interfaces and utility code light weight, meaning such things do not allocate, and if they do only once, do not perform long/length copies, unless a copy was the desired operation,</p>"},{"location":"contributor_guide/philosophy/#d3-general","title":"D.3 General","text":"<p><code>libhal</code> interfaces should be general, meaning that they do not include APIs, or configuration settings that are uncommon in most targets or specific to a particular target.</p>"},{"location":"contributor_guide/philosophy/#d4-minimalist","title":"D.4 Minimalist","text":"<p><code>libhal</code> aims to be as simple as possible and no simpler. Interfaces, utility functions, and libraries should be straight forward for most programmers to understand with added complexity only when it is necessary and no other options exist.</p>"},{"location":"contributor_guide/philosophy/#d5-safe-reliable","title":"D.5 Safe &amp; Reliable","text":"<p><code>libhal</code> and its style guide aim to use patterns, techniques, and documentation to help reduce safety issues and improve reliability.</p>"},{"location":"contributor_guide/philosophy/#d6-tested-testable","title":"D.6 Tested &amp; Testable","text":"<p><code>libhal</code> code should be as testable and unit tested.</p>"},{"location":"contributor_guide/philosophy/#d7-compiled-quickly","title":"D.7 Compiled Quickly","text":"<p><code>libhal</code> code should build fast and eliminate/replace any unnecessary dependencies that cause compile times to be long.</p>"},{"location":"contributor_guide/philosophy/#d8-portable","title":"D.8 Portable","text":"<p><code>libhal</code> code should not require or depend on any OS or target specific code or behaviors. <code>libhal</code> is designed to work anywhere and should not rely on OS.</p>"},{"location":"contributor_guide/style/","title":"\ud83c\udfa8 Style Guide","text":""},{"location":"contributor_guide/style/#s0-code-guidelines","title":"S.0 Code Guidelines","text":"<p>All guides follow the C++ Core Guidelines.</p>"},{"location":"contributor_guide/style/#s1-formatting","title":"S.1 Formatting","text":"<ul> <li>Code shall follow libhal's   <code>.clang-format</code>   file, which uses the Mozilla C++ style format as a base with some adjustments.</li> <li>Code shall follow libhal's   <code>.naming.style</code>   file, which is very similar to the standard library naming convention:</li> <li>CamelCase for template parameters.</li> <li>CAP_CASE for MACROs (avoid MACROs in general).</li> <li>lowercase snake_case for everything else.</li> <li>prefix <code>p_</code> for function parameters.</li> <li>prefix <code>m_</code> for private/protected class member.</li> <li>Refrain from variable names with abbreviations where it can be helped. <code>adc</code>,   <code>pwm</code>, and <code>i2c</code> are extremely common so it is fine to leave them as   abbreviations. Most people know the abbreviations more than the words that   make them up. But words like <code>cnt</code> should be <code>count</code> and <code>cdl</code> and <code>cdh</code>   should be written out as <code>clock_divider_low</code> and <code>clock_divider_high</code>.   Registers do get a pass if they directly reflect the names in the data sheet   which will make looking them up easier in the future.</li> <li>Use <code>#pragma once</code> as the include guard for headers.</li> <li>Every file must end with a newline character.</li> <li>Every line in a file must stay within a 80 character limit.</li> <li>Exceptions to this rule are allowed. Use <code>// NOLINT</code> in these cases.</li> <li>Radix for bit manipulation:</li> <li>Only use binary (<code>0b1000'0011</code>) or hex (<code>0x0FF0</code>) for bit manipulation.</li> <li>Never use decimal or octal as this is harder to reason about for most     programmers.</li> <li>Every public API must be documented with the doxygen style comments (CI will   ensure that every public API is documented fully).</li> <li>Include the C++ header version of C headers such as <code>&lt;cstdint&gt;</code> vs   <code>&lt;stdint.h&gt;</code>.</li> </ul>"},{"location":"contributor_guide/style/#s2-refrain-from-performing-manual-bit-manipulation","title":"S.2 Refrain from performing manual bit manipulation","text":"<p>Use <code>hal::bit</code> from <code>libhal-util</code> library to perform bitwise operations operations.</p>"},{"location":"contributor_guide/style/#s3-refrain-from-using-macros","title":"S.3 Refrain from using MACROS","text":"<p>Only use macros if something cannot be done without using them. Usually macros can be replaced with <code>constexpr</code> or const variables or function calls. A case where macros are the only way is for HAL_CHECK() since there is no way to automatically generate the boiler plate for returning if a function returns and error in C++ and thus a macro is needed here to prevent possible mistakes in writing out the boilerplate.</p> <p>Only use preprocessor <code>#if</code> and the like if it is impossible to use <code>if constexpr</code> to achieve the same behavior.</p>"},{"location":"contributor_guide/style/#s4-never-include-c-stream-libraries","title":"S.4 Never include C++ stream libraries","text":"<p>Applications incur an automatic 150kB space penalty for including any of the ostream headers that also statically generate the global <code>std::cout</code> and the like objects. This happens even if the application never uses any part of <code>&lt;iostream&gt;</code> library.</p>"},{"location":"contributor_guide/style/#s5-refrain-from-memory-allocations","title":"S.5 Refrain from memory allocations","text":"<p>Interfaces and drivers should refrain from APIs that force memory allocations or implementations that allocate memory from heap. This means avoiding STL libraries that allocate such as <code>std::string</code> or <code>std::vector</code>.</p> <p>Many embedded system applications, especially the real time ones, do not allow dynamic memory allocations. There are many reasons for this that can be found MISRA C++ and AutoSAR.</p>"},{"location":"contributor_guide/style/#s6-drivers-should-not-log-to-stdout-or-stdin","title":"S.6 Drivers should not log to STDOUT or STDIN","text":"<p>Peripheral drivers must NOT log to stdout or stderr. This means no calls to</p> <ul> <li><code>std::printf</code></li> <li><code>std::cout</code></li> <li><code>std::print</code> (C++26's version of print based on <code>std::format</code>)</li> </ul> <p>Consider using the file I/O libraries in C, C++, python or some other language. Would you, as a developer, ever imagine that opening, reading, writing, or closing a file would (write?) to your console? Especially if there did not exist a way to turn off logging. Most users would be very upset as this would not seem like the role of the file I/O library to spam the console. This gets even worse if a particular application has thousands of files and each operation is logging.</p> <p>The role of logging should be held by the application developer, not their drivers or helper functions, unless the purpose of the helper functions or driver is to write to console.</p>"},{"location":"contributor_guide/style/#s7-drivers-should-not-purposefully-halt-or-terminate-the-application","title":"S.7 Drivers should not purposefully halt OR terminate the application","text":"<p>Drivers are not entitled to halt the execution of the application and thus any code block that would effectively end or halt the execution of the program without giving control back to the application are prohibited.</p> <p>As an example drivers should never call:   - <code>std::abort()</code>   - <code>std::exit()</code>   - <code>std::terminate()</code>   - any of their variants</p> <p>This includes placing an infinite loop block in a driver.</p> <p>An application should have control over how their application ends. A driver should report severe errors to the application and let the application decide the next steps. If a particular operation cannot be executed as intended, then <code>hal::new_error()</code> should be called.</p> <p>Constructors would be the only valid place to put an exit statement, because they cannot return errors only themselves.</p> <p>The solution to this is to use a factory function like so:</p> Device Driver LibraryPeripheral Driver Library <pre><code>class device_driver {\n  public:\n    result&lt;device_driver&gt; create(/* ... */) {\n      // Perform operations that may fail here\n      return device_driver(/* ... */);\n    }\n\n  private:\n    device_driver(/* ... */) {\n      // Constructors should never fail and thus any work done here must not\n      // fail.\n    }\n};\n</code></pre> <pre><code>class peripheral_driver {\n  public:\n    // Since peripherals are constrained and have a finite set of values\n    // This also ensures that the driver is only constructed once and afterwards\n    // simply returns back a reference to that object.\n    template&lt;size_t PortNumber&gt;\n    // NOTE: Returns a reference not an object.\n    //       Objects are owned by the create function\n    result&lt;peripheral_driver&amp;&gt; create(/* ... */) {\n      // Perform operations that may fail here\n      static peripheral_driver driver(/* ... */);\n      return driver;\n    }\n\n  private:\n    peripheral_driver(/* ... */) {\n      // ...\n    }\n};\n</code></pre>"},{"location":"contributor_guide/style/#s8-drivers-should-not-pollute-the-global-namespace","title":"S.8 Drivers should not pollute the global namespace","text":"<p>All drivers must be within the <code>hal</code> namespace or within their own bespoke namespace.</p> <p>Inclusion of a C header file full of register map structures is not allowed as it pollutes the global namespace and tends to result in name collisions.</p> <p>Care should be taken to ensure that the <code>hal</code> namespace is also as clean as possible by placing structures, enums, const data, and any other symbols into the driver's class's namespace like so:</p> <pre><code>namespace hal::target\n{\nclass target {\n  struct register_map {\n    std::uint32_t control1;\n    std::uint32_t control2;\n    std::uint32_t data;\n    std::uint32_t status;\n    // ..\n  };\n\n  struct control1_register {\n    static constexpr auto channel_enable = hal::bit::range::from&lt;0, 7&gt;();\n    static constexpr auto peripheral_enable = hal::bit::range::from&lt;8&gt;();\n    // ...\n  };\n\n  // ...\n};\n}\n</code></pre>"},{"location":"contributor_guide/style/#s9-interface-should-follow-the-public-private-api-scheme","title":"S.9 Interface should follow the public private API Scheme","text":"<p>See private virtual method for more details. Rationale can be found within that link as well.</p>"},{"location":"contributor_guide/style/#s10-avoid-using-bool","title":"S.10 Avoid using <code>bool</code>","text":""},{"location":"contributor_guide/style/#s101-as-an-object-member","title":"S.10.1 As an object member","text":"<p><code>bool</code> has very poor information density and takes up 8-bits per entry. If only one <code>bool</code> is needed, then a bool is a fine object member. If multiple <code>bool</code>s are needed, then use a <code>std::bitset</code> along with static <code>constexpr</code> index positions in order to keep the density down to the lowest amount possible.</p>"},{"location":"contributor_guide/style/#s102-as-a-parameter","title":"S.10.2 As a parameter","text":"<p>See the article \"Clean code: The curse of a boolean parameter\" for details as to why <code>bool</code> parameters are awful.</p> <p><code>bool</code> is fine if it is the only parameter and it acts as a lexical switch, for example:</p> <pre><code>// This is fine because it reads as set \"LED\" voltage \"level\" to \"FALSE\"\nled.level(false);\n// This is fine because it reads as set \"LED\" voltage \"level\" to \"TRUE\"\nled.level(true);\n</code></pre>"},{"location":"contributor_guide/style/#s11-integrating-third-party-libraries-by-source","title":"S.11 Integrating third party libraries by source","text":"<p>In general, third party libraries should NOT be integrated into a library by source. It should be depended upon using a package manager. But in some cases third party libraries must be included by source. In these cases, the third party libraries should be committed into a project, without modifications, into the <code>include/&lt;library_name&gt;/third_party</code> directory. After that commit, the third party libraries can be used by and integrated into the library code base, in a following commit.</p> <p>If a third party library is modified, that library must have a section at the top of the file with the following description:</p> <pre><code>/**\n * [libhal] modifications to this file are as follows:\n *\n *    1. mod 1\n *    2. mod 2\n *    3. mod 3\n *    4. mod 4\n */\n\n/**\n * &lt;LICENSE GOES HERE!&gt;\n */\n</code></pre> <p>Care must be taken to ensure that third party libraries do not conflict with the licenses of libhal libraries and permit direct integration as well as modification.</p> <p>Rationale: Makes keeping track of changes and the history of files easier to manage.</p>"},{"location":"contributor_guide/style/#s12-avoid-stdatomic","title":"S.12 Avoid <code>std::atomic</code>","text":"<p>Avoid using <code>std::atomic</code> because of portability issues across devices in architectures. Especially when <code>std::atomic</code> is not fully supported by the compiler.</p> <p>Info</p> <p><code>target</code> and <code>processor</code> libraries are allowed to use <code>std::atomic</code> if it is available with their cross compiler and toolchain. In this case, the we can know which target devices the software is running on, either the target itself, which we already know can support it, or on a host machine for unit testing, which is very likely to have a compiler that supports atomics.</p>"},{"location":"contributor_guide/style/#s13-avoid-thread","title":"S.13 Avoid <code>&lt;thread&gt;</code>","text":"<p>Embedded system compilers tend to not provide an implementation of <code>&lt;thread&gt;</code> because the choice of which threading model or multi-threading operating system is left to the developer.</p> <p>In general, <code>#include &lt;thread&gt;</code> will almost never work when cross compiling.</p>"},{"location":"contributor_guide/vscode_setup/","title":"\ud83d\udcbb VSCode Setup","text":""},{"location":"contributor_guide/vscode_setup/#add-conan2p-to-includes-path","title":"Add <code>~/.conan2/p</code> to includes path","text":"<p>TDB</p>"},{"location":"contributor_guide/vscode_setup/#setting-the-python-interpreter","title":"Setting the <code>python</code> interpreter","text":"<p>TDB</p>"},{"location":"contributor_guide/vscode_setup/#setting-up-vscode-debugger","title":"Setting up VSCode Debugger","text":"<p>Info</p> <p>Still under investigation...</p>"},{"location":"project_information/about/","title":"About","text":"<p>The world of embedded systems is written almost entirely in C and C++. More and more of the embedded world move away from C and towards C++. This has to do with the many benefits of C++ such as type safety, compile time features, meta-programming, multi-paradigm and much more. When these features are used correctly, they can result in smaller binary sizes and higher performance code than in C.</p> <p>But a problem that embedded C++ software suffers is that there isn't a consistent and common API for embedded libraries. Looking around, you will find that each hardware vendor has their own set of libraries and tools for their specific products. If you write a driver on top of their libraries, you will find that your code will only work for that specific platform/product. In some cases you may also be limited to just their toolchain. You as the developer are locked in to this one specific setup. And if you move to another platform, you must do the work of rewriting all of your code again.</p> <p>libhal seeks to solve this issue by creating a set of generic interfaces for embedded system concepts such as serial communication (UART), analog to digital conversion (ADC), inertial measurement units (IMU), pulse width modulation (PWM) and much more. The advantage of building a system on top of libhal is that higher level drivers can be used with any target platform whether it is a stm32, a nxp micro controller, a RISC-V, or is on an embedded linux.</p> <p>This project is inspired by the work of Rust's embedded_hal and follows many of the same design goals.</p> <p>libhal's design goals:</p> <ol> <li>Serve as a foundation for building an ecosystem of platform agnostic drivers.</li> <li>Must abstract away device specific details like registers and bitmaps.</li> <li>Must be generic across devices such that any platform can be supported.</li> <li>Must be minimal for boosting performance and reducing size costs.</li> <li>Must be composable such that higher level drivers can build on top of these.</li> <li>Be accessible through package mangers so that developers can easily pick and    choose which drivers they want to use.</li> </ol>"},{"location":"project_information/about/#software-copyrights","title":"Software Copyrights","text":"<p>This source code is licensed under the Apache License 2.0 as described in the LICENSE file.</p>"},{"location":"project_information/about/#third-party-library-licenses","title":"Third Party Library Licenses","text":"<ul> <li>Boost.LEAF, BOOST license</li> <li>tl-function-ref/1.0.0, CC0</li> </ul>"},{"location":"project_information/status/","title":"\ud83d\udfe2 Library Status \ud83d\udd34","text":"<p>Repo</p> <p>CI State</p> <p>Coverage</p> <p>Latest Version</p> libhal/libhal-__platform__ libhal/libhal-stm32f1 libhal/libhal-esp8266 libhal/libhal-__device__ libhal/libhal-mpu libhal/libhal-pca libhal/libhal-rmd libhal/libhal-tmp libhal/libhal-mock libhal/libhal-soft libhal/libhal-lpc40 libhal/libhal-util libhal/libhal libhal/libhal-armcortex libhal/libhal-canrouter libhal/libhal-micromod libhal/libhal-mpl libhal/libhal-freertos"},{"location":"user_guide/configuration/","title":"\ud83c\udf9a\ufe0f Configuration","text":""},{"location":"user_guide/configuration/#halon_error_callback","title":"<code>hal::on_error_callback</code>","text":"<p>Libhal provides a simple mechanism for handling calling a function when an error occurs. The error handler is defined as follows:</p> <pre><code>using error_handler = void(void);\ninline error_handler* on_error_callback = nullptr;\n</code></pre> <p>The <code>on_error_callback</code> is a pointer to a function that takes no arguments and returns no value. If this variable is set to something other than <code>nullptr</code>, then the function it points to is called before the error object is returned. <code>hal::new_error()</code> must be used to get this behavior. Calling <code>boost::leaf::new_error</code> will bypass this behavior.</p> <p>This error handler is useful for logging when errors occur. It allows developers to capture information about the state of your program at the time of the error, which can be helpful for debugging.</p> <p>Most importantly, the error handler is very useful for generating a stack trace. A stack trace provides a snapshot of the call stack at a specific point in time. This can be invaluable for understanding the sequence of function calls that led to an error. However, generating a stack trace is only possible at this depth in the call stack, which is why the error handler is so important.</p> <p>To use the error handler, you simply need to define a function that matches the <code>error_handler</code> type, and then assign the address of this function to <code>on_error_callback</code>. Here's an example:</p> <pre><code>void my_error_handler() {\n    // Code to execute when an error occurs\n}\n\nint main() {\n    hal::on_error_callback = &amp;my_error_handler;\n\n    // Rest of your code\n}\n</code></pre> <p>In this example, <code>my_error_handler</code> will be called whenever an error occurs in your code. You can put any code you want in this function to handle the error in a way that makes sense for your application.</p> <p>Note that this pointer is global and care should be taken when modifying it.</p>"},{"location":"user_guide/debugging/","title":"\ud83c\udfaf Debugging Code with PyOCD","text":""},{"location":"user_guide/debugging/#introduction","title":"Introduction","text":"<p>PyOCD is an open-source Python package for programming and debugging Arm Cortex-M microcontrollers using CMSIS-DAP. It's a highly flexible and easy-to-use tool, but it's important to note that it only supports ARM processors.</p> <p>PyOCD stands out for its user-friendly approach compared to other On-Chip Debugging (OCD) tools like OpenOCD, despite being slightly limited in terms of the range of processors it supports.</p> <p>For the full documentation for PyOCD see https://pyocd.io/.</p>"},{"location":"user_guide/debugging/#installation","title":"Installation","text":"<p>To install PyOCD, run the following command in your terminal:</p> <pre><code>python3 -m pip install pyocd\n</code></pre>"},{"location":"user_guide/debugging/#connecting-a-debugger-to-your-device","title":"Connecting a Debugger to your Device","text":"<p>Connect the debugger (STLinkV2) to your MicroMod Carrier board using the STLink to SWD connector adapter. Before connecting and powering everything check that the the ribbon connector is connected to the port with the glowing LED. That is the correct connection. Using the incorrect connection could cause part damage.</p> <p>If you are using another type of device with different connections follow this guide. A connection to ground (<code>GND</code>) must be made between the debugger and the development board in order for the devices to communicate.</p> <p>Danger</p> <p>DOUBLE AND TRIPLE CHECK YOUR CONNECTIONS! Incorrect connects can result in breaking a board, debugger or possible your computer.</p> Connecting SWDConnecting JTAG <p>Connect jumpers from <code>GND</code>, <code>SWDIO</code> and <code>SWDCLK</code> to the pins on the board. If the board supports both <code>SWD</code> and <code>JTAG</code> like many arm cortex boards do, then connect the pins in the following way: <code>SWDIO</code> --&gt; <code>TMS</code> and <code>SWDCLK</code> --&gt; <code>TCK</code>.</p> <p>Connect jumpers from the <code>GND</code>, <code>TDI</code>, <code>TMS</code>, <code>TCK</code>, and <code>TDO</code> pins on the JTAG debugger to the headers on the development board of the same name.</p>"},{"location":"user_guide/debugging/#connecting-to-device-using-pyocd","title":"Connecting to device using PyOCD","text":"<p>The following commands will use <code>pyocd</code> and your debugger to connect to your target platform.</p> lpc40stm32f1 <pre><code>pyocd gdbserver --target=lpc4088 --persist\n</code></pre> <pre><code>pyocd gdbserver --target=stm32f103rc --persist\n</code></pre> <p>To find all of the available platforms use <code>pyocd list --targets</code>.</p>"},{"location":"user_guide/debugging/#using-arm-none-eabi-gdb","title":"Using arm-none-eabi-gdb","text":"<p><code>arm-none-eabi-gdb</code> is a version of GDB (GNU Debugger) configured for debugging Arm Cortex-M devices.</p> <p>To start a GDB debugging session, open an additional terminal or terminal window. Then execute the following command:</p> <pre><code>arm-none-eabi-gdb -ex \"target remote :3333\" -tui path/to/yourfile.elf\n</code></pre> <ul> <li><code>-tui</code>: GDB TUI provides a text window interface for debugging. To start GDB   in TUI mode, use the <code>-tui</code> option</li> <li><code>-ex \"target remote :3333\"</code>: <code>-ex</code> executes a GDB command. And the command   <code>target remote :3333</code> connects to a remote gdb server, in this case, the pyocd   server (with default port <code>:3333</code>).</li> </ul>"},{"location":"user_guide/debugging/#starting-the-debugging-process","title":"Starting the Debugging Process","text":"<p>Here is a cheat sheet for using GDB Cheat Sheet.</p> <p>A typical first breakpoint for a program is to set a breakpoint on main.</p> <pre><code>b main\n</code></pre> <p>Next you will want to reset the program back to the start and halt the CPU using the following command.</p> <pre><code>monitor reset halt\n</code></pre> <p>To begin running through the program use the <code>continue</code> or <code>c</code> command.</p> <pre><code>c\n</code></pre> <p>At this point you should see the source code of your <code>main.cpp</code> show up. Now you can step through your code and set breakpoints using <code>step</code>, <code>next</code>, <code>finish</code> and <code>continue</code>, <code>break</code>, etc.</p> <p>Typically you would use the <code>run</code> command to start the code. When performing firmware testing, the <code>run</code> command is not needed as the code is already \"running\" on the remote microcontroller.</p> <p>Info</p> <p>On boards with a factory bootloader, when you start debugging, you will notice that you cannot see the source code lines in the gdb shell. This is because the bootloader instructions are not associated with any addresses in your code, thus you will not see source code. This is fine. Continue with the guide. The LPC40xx family of microcontrollers has such a bootloader.</p>"},{"location":"user_guide/debugging/#stepping-through-code","title":"Stepping Through Code","text":"<p>Once in a GDB session, you can step through your code using the following commands:</p> <ul> <li><code>next</code> or <code>n</code>: Executes the next line in the source code. If the line contains   a function call, it treats the entire function as one instruction and executes   it in one go.</li> <li><code>step</code> or <code>s</code>: Executes the next line, but if it contains a function call,   <code>step</code> will go into that function so you can continue debugging inside it.</li> <li><code>finish</code>: Runs until the current function is finished.</li> <li><code>continue</code> or <code>c</code>: Continues execution until the next breakpoint or   watchpoint.</li> <li><code>until lineno</code>: Continues execution until a line number greater than the   current one is reached. Useful for loops.</li> </ul> <p>Remember that you can use the <code>help</code> command in GDB to get information about any other command.</p>"},{"location":"user_guide/debugging/#inspecting-variables-and-registers","title":"Inspecting Variables and Registers","text":"<p>You can inspect the state of your program by examining variables and registers:</p> <ul> <li><code>print variable</code> or <code>p variable</code>: Prints the current value of the specified   variable.</li> <li><code>info registers</code>: Shows the current state of all CPU registers.</li> <li><code>info register regname</code>: Shows the current state of a specific CPU register.</li> <li><code>print gpio_reg-&gt;CTRL</code>: Shows the value of a register</li> </ul> <p>Tip</p> <p>If you get an error like:</p> <pre><code>Cannot access memory at address ???\n</code></pre> <p>This happens because GDB is limiting access to memory that is known at link time and is apart of the binary's structure. But if a user wants to access peripheral memory not associated with RAM or Flash memory then they can execute this command:</p> <pre><code>set mem inaccessible-by-default off\n</code></pre>"},{"location":"user_guide/debugging/#setting-breakpoints-and-watchpoints","title":"Setting Breakpoints and Watchpoints","text":"<p>Breakpoints allow you to pause program execution at a particular point, and watchpoints let you pause execution whenever a particular variable changes:</p> <ul> <li><code>break function</code> or <code>b function</code>: Sets a breakpoint at the beginning of the   specified function.</li> <li><code>break filename:lineno</code> or <code>b filename:lineno</code>: Sets a breakpoint at a   specific line in a specific file.</li> <li><code>watch variable</code>: Sets a watchpoint on a variable. The program will stop   executing whenever the variable's value changes.</li> <li><code>info breakpoints</code>: Lists all the breakpoints that are currently set.</li> <li><code>delete n</code>: Deletes breakpoint number <code>n</code>. Use <code>info breakpoints</code> to see   breakpoint numbers.</li> <li><code>delete</code>: Deletes all breakpoints if used without a number.</li> </ul>"},{"location":"user_guide/debugging/#flashing-a-device-using-gdb","title":"Flashing a Device using GDB","text":"<p>In GDB, you can also use the <code>load</code> command to flash your device. The <code>load</code> command automatically uses the target specified when you started the GDB session.</p> <pre><code>(gdb) load\n</code></pre> <p>This command will load the program onto your device.</p> <p>You can build the elf file in another terminal, then run <code>load</code> again to update the program. It may or may not reset the core back to the start so <code>monitor reset halt</code> may be needed.</p>"},{"location":"user_guide/error_handling/","title":"\ud83e\udea4 Error Handling in libhal using Boost.LEAF","text":"<p>Libhal uses Boost.LEAF for error handling. Boost.LEAF is a lightweight error handling library for C++11. It is designed for maximum efficiency and does not require dynamic memory allocations, even with heavy payloads. It can be used with or without exception handling and supports multi-thread programming.</p>"},{"location":"user_guide/error_handling/#basic-concepts","title":"Basic Concepts","text":"<p>Boost.LEAF introduces a few key concepts for error handling:</p> <ul> <li> <p>Error Objects: These are instances of any type that you want to associate   with an error. They can be error codes, strings, or any other type of object   that provides information about the error.</p> </li> <li> <p>Context: This is a scope where error objects can be loaded and associated   with a specific error. It is usually local to a <code>try_handle_all</code>,   <code>try_handle_some</code>, or <code>try_catch</code> scope.</p> </li> <li> <p>Error ID: This is a unique identifier for an error. It is generated when   an error is reported using <code>new_error</code> or <code>exception</code>.</p> </li> </ul>"},{"location":"user_guide/error_handling/#error-handling-process","title":"Error Handling Process","text":"<p>The error handling process in Boost.LEAF involves the following steps:</p> <ol> <li> <p>Detecting an Error: When an error is detected in your code, you can    report it by calling <code>new_error</code> or <code>exception</code>. These functions generate a    new error ID and return it. You can also pass any number of error objects to    these functions to associate them with the error.</p> </li> <li> <p>Loading Error Objects: Error objects can be loaded into an active context    using the <code>load</code> function. These objects become associated with a specific    error ID. If storage is not available, the error objects are discarded.</p> </li> <li> <p>Handling Errors: When an error is reported, it is forwarded up the call    stack until it reaches an error-handling scope. This scope probes the context    for any error objects associated with the error ID and processes a list of    user-provided error handlers. The first handler that can be supplied with the    available error objects is called to handle the error.</p> </li> </ol>"},{"location":"user_guide/error_handling/#boostleaf-aliases","title":"Boost.LEAF Aliases","text":"<p>libhal creates aliases for a few of the APIs in Boost.LEAF to shorten their names and use the <code>hal</code> namespace. The mapping can be found in libhal/error.hpp.</p> <p>Including <code>libhal/error.hpp</code> will pull in all of the Boost.LEAF libraries, so if you prefer to use them directly, you can do so.</p>"},{"location":"user_guide/error_handling/#example","title":"Example","text":"<p>Here is an example of how you can use Boost.LEAF for error handling in libhal:</p> <pre><code>#include &lt;libhal/error.hpp&gt;\n\nenum class error_code\n{\n    bad_command_line = 1,\n    open_error,\n    read_error,\n    size_error,\n    eof_error,\n    output_error\n};\n\nhal::result&lt;void&gt; do_something()\n{\n    // Some operation that may fail...\n    if (/* failure condition */)\n    {\n        return hal::new_error(open_error, leaf::e_errno{errno});\n    }\n\n    return {};\n}\n\nint main(int argc, char const *argv[])\n{\n    return hal::attempt_all(\n        []() -&gt; hal::result&lt;int&gt;\n        {\n            HAL_CHECK(do_something());\n            return 0;\n        },\n        [](hal::match&lt;error_code, open_error&gt;, leaf::e_errno const &amp;errn)\n        {\n            // Do something here\n            return 2;\n        },\n        []()\n        {\n            // Unknown error, handle it here\n            return 6;\n        });\n}\n</code></pre> <p>In this example, <code>do_something</code> is a function that may fail. If it fails, it reports an error by calling <code>new_error</code> and associates the error with an <code>open_error</code> error code and the system <code>errno</code>. The <code>main</code> function calls <code>do_something</code> and handles any errors that it reports. It uses <code>try_handle_all</code> to handle all errors and</p> <p>provides two error handlers. The first handler handles <code>open_error</code> errors and includes the system <code>errno</code>. The second handler handles any other errors.</p> <p>Please note that this is a basic example. Boost.LEAF provides many more features for error handling, such as error object composition, error object accumulation, and error object matching. You can use these features to create more sophisticated error handling systems.</p> <p>For more information, please refer to the Boost.LEAF documentation.</p>"},{"location":"user_guide/error_handling/#ram-usage-when-using-an-rtos","title":"RAM Usage when using an RTOS","text":"<p>To be written...</p>"},{"location":"user_guide/error_handling/#error-types-in-libhal","title":"Error Types in libhal","text":"<p>To be written...</p>"},{"location":"user_guide/fundamentals/","title":"\ud83e\uddf1 Fundamentals of libhal","text":"<p>At its core, libhal is a set of interfaces that correspond to hardware devices and peripherals. These interfaces use runtime polymorphism to decouple application logic from driver implementation details. This decoupling enables applications to run on any platform device that has the necessary components available.</p>"},{"location":"user_guide/fundamentals/#types-of-libraries","title":"Types of Libraries","text":"<p>In libhal, libraries are categorized into platform, utility, device, process, and application/operating system libraries.</p> <ul> <li>Processor Libraries: Contain the driver implementations for specific   processor. Generally, these libraries are not direct dependencies in an   application. These are depended upon by platform libraries, which use them to   make their own drivers work.</li> <li>Platform Libraries: Contain the driver implementations for specific   platforms. Every application that uses libhal will need one of these libraries   in order to work on any hardware.</li> <li>Utility Libraries: Software libraries to make writing libhal code easier.</li> <li>Device Libraries: Libraries containing drivers for specific hardware   devices or modules, such as a sensor, display, or a motor controller. They are   generally platform agnostic and should be usable on any system that can   support the driver requirements, memory requirements and performance   requirements.</li> <li>Process Libraries: Code that performs some work. This work usually   requires one or more drivers in order to work. This is similar to an   application on a device like a desktop computer or smartphone, but on an   embedded system. These processes can be called multiple times to perform work   or be used as the function for a thread.</li> <li>Application Libraries: Full applications that typically handle and take   over the whole system.</li> <li>RTOS Libraries: RTOS stands for Real Time Operating System and using these   libraries will enable multi-tasking and multi-threading capability to the   application.</li> <li>Software Libraries: These libraries are purely software-based and do not   directly interact with hardware. They provide useful utilities, data   structures, algorithms, and other software components that can be used across   different parts of an application. Examples might include an efficient   circular buffer implementation, a data structure for facilitating cross-driver   communication, or a driver that performs a specific algorithm on data. These   libraries are platform-agnostic and can be used in any application that meets   their requirements.</li> </ul>"},{"location":"user_guide/fundamentals/#interfaces","title":"Interfaces","text":"<p>Interfaces are the basic building blocks of libhal and enable the flexibility needed to be portable and flexible. An interface is a contract of functions that an implementing class must adhere to. Any software that implements (inherits) an interface must provide implementations for each function in the interface, otherwise the compiler will generate a compiler error.</p> <p>Not all libraries will implement an interface. Some drivers are</p>"},{"location":"user_guide/fundamentals/#driver-types","title":"Driver Types","text":"<ul> <li>Peripheral Drivers: Drivers for a platform that is embedded within the   platform or development board and therefore cannot be removed from the chip   and is fixed in number.</li> <li>Device Drivers: Drivers for devices external to a platform. In order to   communicate with such a device the platform must have the necessary peripherals   and peripheral drivers to operate correctly.</li> <li>Soft Drivers: Drivers that do not have any specific underlying hardware   associated with them. They are used to emulate, give context to, or alter the   behavior of interfaces.</li> </ul>"},{"location":"user_guide/fundamentals/#concrete-drivers","title":"Concrete Drivers","text":"<p>In libhal, not all drivers are designed to implement an interface. These drivers, referred to as \"Concrete Drivers\", are unique in that they typically do not contain virtual functions and cannot be passed in a generic form. Despite this, they play a crucial role in the library due to their specific functionality and support for certain hardware components.</p> <p>Concrete Drivers are fully realized classes that provide direct, specific functionality. They are designed to interact with a particular piece of hardware or perform a specific task, and their methods provide a direct interface to that hardware or task. Because they do not implement an interface, they cannot be used polymorphically like other drivers in libhal. However, their specificity allows them to provide robust, efficient, and direct control over their associated hardware.</p> <p>These drivers are particularly useful in scenarios where a specific piece of hardware or a specific task does not neatly fit into one of the existing libhal interfaces, or when the overhead of virtual functions is not desirable. Despite not conforming to a specific interface, Concrete Drivers adhere to the same design principles as other components of libhal, ensuring consistency and reliability across the library.</p> <p>In libhal, not all drivers are designed to implement an interface. These drivers, referred to as \"Concrete Drivers\", are unique in that they typically do not contain virtual functions and cannot be passed in a generic form. Despite this, they play a crucial role in the library due to their specific functionality and support for certain hardware components.</p> <p>Note that this isn't a distinct type outside of the list of Driver types mentioned above. Concrete drivers can be a peripheral, device and soft driver. They simply do not implement an interface.</p>"},{"location":"user_guide/fundamentals/#multi-interface-support","title":"Multi-Interface Support","text":"<p>Many Concrete Drivers can actually support multiple interfaces at once. For example, a driver for the RMD-X6 smart motor can act as a servo, a motor, a temperature sensor (for itself), a voltage sensor (for the bus it is connected to), a current sensor (for how much current it's consuming), and a rotation sensor (for its output shaft's position). To create these drivers from the concrete driver, an adaptor class must be used. These adaptor classes take the concrete class and use its methods in order to implement the interface APIs.</p>"},{"location":"user_guide/fundamentals/#adaptor-factory-functions","title":"Adaptor Factory Functions","text":"<p>In libhal, there is a common language policy for adaptors. To create them you must call a factory function called <code>make_&lt;name of interface&gt;()</code> and it will return a <code>hal::result&lt;adaptor_object&gt;</code>. There is an overload for every driver that implements a particular interface. For example, in order to generate a servo from an RMD X6 servo object, it would look like this:</p> <pre><code>auto smart_servo_driver = HAL_CHECK(make_servo(rmd_x6_driver));\n</code></pre> <p>This approach allows for a consistent and efficient way to create adaptors for various interfaces from a single concrete driver. It ensures that the concrete driver can be utilized to its full potential, providing access to all its capabilities through the appropriate interfaces.</p>"},{"location":"user_guide/fundamentals/#return-types-halresultt-and-halstatus","title":"Return Types <code>hal::result&lt;T&gt;</code> and <code>hal::status</code>","text":"<p><code>hal::result&lt;T&gt;</code> is an alias for the <code>boost::leaf::result&lt;T&gt;</code> type. This type can either be the value T or an error. <code>hal::status</code> is simply a concise alias for the type <code>boost::leaf::result&lt;void&gt;</code>. See Boost.LEAF for more details about it and how it works.</p> <p><code>HAL_CHECK()</code> is a macro that takes an expression that evaluates to a <code>hal::result</code>.</p>"},{"location":"user_guide/interfaces/","title":"\ud83d\udd17 Interfaces in Software Development and libhal","text":"<p>In software development, an interface is a shared boundary across which two separate components of a computer program exchange information. The exchange can be between software, computer hardware, peripheral devices, humans, and combinations of these. Technically, it refers to a software component (a class, a module, etc.) that encapsulates a specific functionality and that can be used by other components.</p> <p>Interfaces work by specifying the methods that a class must implement, without including the implementation of the methods themselves. This allows different classes to implement the same interface in different ways, providing a level of abstraction between the interface and the implementation.</p> <p>In the context of libhal (Hardware Abstraction Layer Library), interfaces are used to define a standard way of interacting with different types of hardware. This makes the software portable because it can interact with the hardware through the interface, without needing to know the specifics of how the hardware is implemented. This means that if the underlying hardware changes, only the implementation of the interface needs to change, not the software that uses it.</p>"},{"location":"user_guide/interfaces/#driver-types-in-libhal","title":"Driver Types in libhal","text":""},{"location":"user_guide/interfaces/#digital","title":"Digital","text":"Input PinOutput PinInterrupt Pin <p>See API: <code>hal::input_pin</code></p> <p>The Input Pin interface (<code>hal::input_pin</code>) in libhal is used for reading the state of a digital input pin. This is useful in situations where you need to determine if the voltage on a pin is HIGH or LOW.</p> <p>In the libhal library, the Input Pin interface provides methods to configure the input pin according to the settings supplied and to read the state of the input pin.</p> <p>See API: <code>hal::output_pin</code></p> <p>The Output Pin interface in libhal is used for controlling the state of a digital output pin. This is useful in situations where you need to send a control signal or turn on or off an LED.</p> <p>In the libhal library, the Output Pin interface provides methods to configure the output pin according to the settings supplied, to set the state of the pin, and to read the current state of the output pin.</p> <p>See API: <code>hal::interrupt_pin</code></p> <p>The Interrupt Pin interface in libhal is used for automatically calling a function when a pin's state has transitioned. This is useful in situations where you need to respond to changes in the state of a pin.</p> <p>In the libhal library, the Interrupt Pin interface provides methods to configure the interrupt pin according to the settings supplied and to set the callback for when the interrupt occurs.</p>"},{"location":"user_guide/interfaces/#analog","title":"Analog","text":"ADC (Analog-to-Digital Converter)DAC (Digital-to-Analog Converter)PWM (Pulse Width Modulation) <p>See API: <code>hal::adc</code></p> <p>The ADC interface in libhal is used to convert an analog signal into a digital one. This is useful in situations where the hardware device is producing an analog signal, such as a sensor reading, but the software works with digital values.</p> <p>In the libhal library, the ADC interface provides methods to read the voltage from the ADC as a percentage of the reference voltage.</p> <p>See API: <code>hal::dac</code></p> <p>The DAC interface in libhal is used to convert a digital signal into an analog one. This is useful in situations where the software is producing digital values, but the hardware device requires an analog signal.</p> <p>In the libhal library, the DAC interface provides methods to write a voltage to the DAC, as a percentage of the reference voltage.</p> <p>See API: <code>hal::pwm</code></p> <p>The PWM interface in libhal is used to control the waveform generation of a square wave and its properties such as frequency and duty cycle. PWM is used for power control like motor control, lighting, transmitting signals to servos, sending telemetry and much more.</p> <p>In the libhal library, the PWM interface provides methods to set the PWM waveform frequency and duty cycle.</p>"},{"location":"user_guide/interfaces/#time-timers","title":"Time &amp; Timers","text":"TimerSteady Clock <p>See API: <code>hal::timer</code></p> <p>The Timer interface in libhal is used for scheduling events to occur after a specified amount of time. This is useful in situations where you need to perform an action after a certain amount of time has passed.</p> <p>In the libhal library, the Timer interface provides methods to check if the timer is running, cancel a scheduled event, and schedule a new event.</p> <p>See API: <code>hal::steady_clock</code></p> <p>The Steady Clock interface in libhal is used for a steady clock mechanism. This clock is steady meaning that subsequent calls to get the uptime of this clock cannot decrease as physical time moves forward and the time between ticks of this clock are constant and defined by the clock's frequency.</p> <p>In the libhal library, the Steady Clock interface provides methods to get the operating frequency of the steady clock and to get the current value of the steady clock.</p> <p>This completes the descriptions for all the interfaces in the libhal library. Each of these interfaces provides a way to interact with different types of hardware in a consistent and portable way, making it easier to write embedded software that can run on different platforms.</p>"},{"location":"user_guide/interfaces/#serial-communication-protocols","title":"Serial Communication Protocols","text":"SPI (Serial Peripheral Interface)I2C (Inter-Integrated Circuit)SerialCAN (Controller Area Network) <p>See API: <code>hal::spi</code></p> <p>The SPI interface in libhal is used for communication over a Serial Peripheral Interface (SPI). This is a synchronous serial communication interface specification used for short-distance communication, primarily in embedded systems.</p> <p>In the libhal library, the SPI interface provides methods to configure the SPI bus and perform an SPI transaction.</p> <p>See API: <code>hal::i2c</code></p> <p>The I2C interface in libhal is used for communication over an Inter-Integrated Circuit (I2C) bus. This is a multi-master, multi-slave, packet switched, single-ended, serial computer bus invented by Philips Semiconductor.</p> <p>In the libhal library, the I2C interface provides methods to configure the I2C bus and perform an I2C transaction.</p> <p>See API: <code>hal::serial</code></p> <p>The Serial interface in libhal is used for hardware that implements a serial protocol like UART, RS232, RS485, and others that use a similar communication protocol but may use different voltage schemes.</p> <p>In the libhal library, the Serial interface provides methods to configure the serial to match the settings supplied, to write data to the transmitter line of the serial port, to copy bytes from the working buffer into the passed buffer, and to flush the working buffer.</p> <p>Unfortunately, I encountered an error while trying to access the Steady Clock interface file in the libhal repository. I'll try again to retrieve its content.</p> <p>See API: <code>hal::can</code></p> <p>The CAN interface in libhal is used for communication over a Controller Area Network (CAN bus). This is a robust vehicle bus standard designed to allow microcontrollers and devices to communicate with each other's applications without a host computer.</p> <p>In the libhal library, the CAN interface provides methods to configure the CAN bus, send a CAN message, and set a message reception handler.</p>"},{"location":"user_guide/interfaces/#actuators","title":"Actuators","text":"MotorServo <p>See API: <code>hal::motor</code></p> <p>The Motor interface in libhal is used for controlling an open loop rotational actuator. This can represent a variety of things such as a driver for a motor controller IC like the DRV8801, a driver for a motor with an integrated controller &amp; serial interface, a unidirectional motor controlled by a single transistor, or a servo with open loop motor control.</p> <p>In the libhal library, the Motor driver provides methods to apply power to the motor. The power applied is a percentage of the total available power.</p> <p>See API: <code>hal::servo</code></p> <p>The Servo interface in libhal is used for controlling a closed loop position controlled rotational actuator. Servos are devices that can rotate to a specified position.</p> <p>In the libhal library, the Servo interface provides methods to set the position of the servo's output shaft.</p>"},{"location":"user_guide/interfaces/#sensors","title":"Sensors","text":"Temperature SensorAccelerometerGyroscopeMagnetometerDistance SensorRotation Sensor <p>See API: <code>hal::temperature_sensor</code></p> <p>The Temperature Sensor interface in libhal is used for reading the current temperature measured by a device. This is useful in situations where you need to monitor the temperature of a device or environment.</p> <p>In the libhal library, the Temperature Sensor interface provides a method to read the current temperature.</p> <p>See API: <code>hal::accelerometer</code></p> <p>The Accelerometer interface in libhal is used for sensing acceleration. Accelerometers are devices that measure the rate of change of velocity with respect to time (acceleration).</p> <p>In the libhal library, the Accelerometer interface provides methods to read the acceleration sensed by the device in the X, Y, and Z axes.</p> <p>Accelerometers are commonly used to determine orientation or tilt of an object.</p> <p>See API: <code>hal::gyroscope</code></p> <p>The Gyroscope interface in libhal is used for sensing angular velocity. Gyroscopes are devices that measure the rotational speed around an axis.</p> <p>In the libhal library, the Gyroscope interface provides methods to read the angular velocity sensed by the device in the X, Y, and Z axes.</p> <p>See API: <code>hal::magnetometer</code></p> <p>The Magnetometer interface in libhal is used for sensing magnetic field strength. Magnetometers are devices that measure the strength and direction of a magnetic field.</p> <p>In the libhal library, the Magnetometer interface provides methods to read the magnetic field strength sensed by the device in the X, Y, and Z axes.</p> <p>Such devices are commonly used as a compass in order to provide heading information to a device.</p> <p>See API: <code>hal::distance_sensor</code></p> <p>The Distance Sensor interface in libhal is used for sensing linear distance. Distance sensors can be used in a variety of applications, such as measuring the distance to an object or determining the position of an object.</p> <p>In</p> <p>the libhal library, the Distance Sensor interface provides methods to read the current distance measured by the device.</p> <p>See API: <code>hal::rotation_sensor</code></p> <p>The Rotation Sensor interface in libhal is used for sensing a single axis of rotation. Rotation sensors can be used in a variety of applications, such as measuring the rotation to an object or determining the angular position of an object.</p> <p>In the libhal library, the Rotation Sensor interface provides methods to read the current angle, in degrees, measured by the device.</p> \u23f3 Current Sensor\u23f3 Voltage Sensor\u23f3 GPS <p>API not available yet</p> <p>A Current Sensor driver in libhal would be used for sensing electrical current. Current sensors are devices that detect the current of current flowing through a circuit.</p> <p>In the libhal library, the Current Sensor interface provides methods to read the current as a unit of <code>amperes</code>.</p> <p>API not available yet</p> <p>A Voltage Sensor driver in libhal would be used for sensing electrical voltage. Voltage sensors are devices that can measure the voltage potential difference between two points in an electrical circuit. When available, the Voltage Sensor driver would provide methods to read the voltage sensed by the device.</p> <p>In the libhal library, the Voltage Sensor interface provides methods to read the current as a unit of <code>volts</code>.</p> <p>API not available yet</p> <p>A GPS (Global Positioning System) driver in libhal would be used for receiving and interpreting GPS signals, which provide geolocation and time information to a GPS receiver anywhere on or near the Earth. When available, the GPS driver would provide methods to read the current location, speed, time, and other relevant data from the GPS signals.</p> <p>In the libhal library, the GPS interface provides methods to read location in longitude and latitude, get the current time, and get velocity.</p> <p>NOTE: that more investigation is needed to determine what fields make sense for this sensor and if it should be broken up into multiple interfaces like <code>hal::geolocation</code>, <code>hal::heading</code>, <code>hal::clock</code> and <code>hal::velocity</code>.</p>"},{"location":"user_guide/interfaces/#the-myth-about-virtual-understanding-dynamic-polymorphism-in-c","title":"The Myth about Virtual: Understanding Dynamic Polymorphism in C++","text":"<p>There's a common misconception in the C++ community that dynamic polymorphism inherently requires dynamic memory (heap memory), and that it's slower or more memory-intensive than other forms of polymorphism. This is not necessarily true. Let's debunk these myths.</p>"},{"location":"user_guide/interfaces/#dynamic-polymorphism-and-dynamic-memory","title":"Dynamic Polymorphism and Dynamic Memory","text":"<p>Dynamic polymorphism in C++ is achieved through virtual functions, which allow us to override functions in derived classes. This provides a way to use a base class pointer or reference to call the appropriate function based on the actual object type at runtime.</p> <p>While it's true that dynamic memory can be used in conjunction with dynamic polymorphism (for instance, when creating objects of derived classes and storing them in base class pointers), it's not a requirement. You can have dynamic polymorphism without dynamic memory.</p> <p>Consider a scenario where you have a base class <code>Base</code> and a derived class <code>Derived</code>. If you have a function that takes a reference to <code>Base</code>, you can pass an instance of <code>Derived</code> to that function without needing to allocate <code>Derived</code> on the heap:</p> <pre><code>void someFunction(Base&amp; baseRef) {\n    baseRef.someVirtualFunction();\n}\n\nDerived derived;\nsomeFunction(derived);  // No dynamic memory involved\n</code></pre> <p>In this case, <code>someFunction</code> will call the correct version of <code>someVirtualFunction</code> based on the actual type of the object, even though it's passed as a reference to <code>Base</code>. This is dynamic polymorphism in action, without any dynamic memory.</p>"},{"location":"user_guide/interfaces/#performance-of-dynamic-polymorphism","title":"Performance of Dynamic Polymorphism","text":"<p>Another myth is that dynamic polymorphism is slower than other forms of polymorphism, such as using a struct with function pointers (akin to C-style interfaces). In reality, the performance difference is negligible in most cases.</p> <p>When a virtual function is called, the compiler needs to look up the function address in the virtual table (vtable) of the object. This is essentially a pointer dereference, which is the same operation needed to call a function through a function pointer in a struct. Therefore, the performance of these two approaches is comparable.</p>"},{"location":"user_guide/interfaces/#memory-overhead-of-virtual-polymorphism","title":"Memory Overhead of Virtual Polymorphism","text":"<p>The memory overhead of dynamic polymorphism is also often overstated. Each class with virtual functions has a vtable, which is essentially a static array of function pointers. This vtable is shared among all instances of the class, so it doesn't increase the per-instance memory overhead.</p> <p>The vtable does increase the size of the binary, but the increase is usually small. Each vtable entry is just a function pointer. For a class hierarchy with a reasonable number of virtual functions, this overhead is typically negligible.</p> <p>In addition to the function pointers, the vtable contains two more pointers: one for the parent class's vtable (for supporting inheritance) and one for Run-Time Type Information (RTTI, used for <code>dynamic_cast</code> and <code>typeid</code>). These are fixed overheads per class, not per object.</p> <p>In conclusion, while dynamic polymorphism in C++ does have some overhead, it's often smaller than people think. It doesn't inherently require dynamic memory, its performance is comparable to other forms of polymorphism, and its memory overhead is typically small. Therefore, it's a powerful tool for creating flexible and reusable code in C++.</p>"},{"location":"user_guide/policy/","title":"\u2696\ufe0f Policies &amp; FAQ","text":""},{"location":"user_guide/policy/#1-ensuring-consistency-across-platforms","title":"1. Ensuring Consistency Across Platforms","text":"<p>To maintain a consistent interface across platforms, libhal adopts:</p> <ol> <li>Clearly articulated rules and interface API documentation. This ensures every    potential input produces a predictable behavior.</li> <li>Testing mechanisms that ensure adherence to these standards.</li> </ol> <p>While libhal covers the documentation aspect, our CI integration doesn't yet encompass all testing facets, simulated or real-world. We are in the process of designing a compliance test suitable both for device testing and CI inclusion. Presently, the onus is on manual testing and meticulous inspection.</p> <p>Regarding unit tests: Although beneficial for purely software libraries, they're not always feasible for embedded systems. Once you mock components like i2c or input pins, the actual device testing veers towards simulation. This method is viable post verifying the device compatibility, solidifying the code behavior through unit tests. High-level conceptual and application codes can harness such tests, but unit testing often misaligns with low-level drivers.</p>"},{"location":"user_guide/policy/#2-driver-development-in-libhal","title":"2. Driver Development in libhal","text":"<p>How are these drivers created? Do new products gain immediate support?</p> <p>Our developers craft code by hand. Fully automated firmware driver solutions either fall short on efficiency or fail to span multiple devices. However, for devices adhering to standards like NMEA or JEDEC, automation holds potential. We're also considering tools that process SVD files into bit mask ranges, assuming no licensing complications arise.</p>"},{"location":"user_guide/policy/#3-oems-stance-on-libhal-software","title":"3. OEM's Stance on libhal Software","text":"<p>Does libhal have defenses against potential vendor objections?</p> <p>Using OEM-developed SDKs can be tricky due to restrictive licensing. For instance, SDKs from NXP or STM mandate their code only run on their specific devices. Some chips might mirror the architecture of another, but licensing can inhibit cross-utilization.</p> <p>Our safeguard? Any software we integrate is crafted by our engineers, strictly based on publicly accessible OEM manuals. We're mindful of potential exceptions and will handle them case-by-case.</p>"},{"location":"user_guide/policy/#4-vendor-sdk-utilization-in-libhal","title":"4. Vendor SDK Utilization in libhal","text":"<p>How does libhal tackle licensed APIs? What does it mean for the end developer?</p> <p>Currently, libhal steers clear of SDKs with confining licenses or those misaligned with Apache 2.0 or its equivalents. This includes licenses from NXP and STM. However, SDKs from Espressif Systems (with Apache 2.0) are potentially usable.</p>"},{"location":"user_guide/policy/#5-dealing-with-devices-lacking-public-manuals","title":"5. Dealing with Devices Lacking Public Manuals","text":"<p>Devices without public user manuals typically don't get a libhal library. Here's why:</p> <ol> <li>It risks unintentional exposure of proprietary device information.</li> <li>Without a manual, the code operates like a black box, turning debugging into    a reverse-engineering puzzle.</li> </ol> <p>We can craft drivers for such devices, but their source code would remain confidential. Libhal predominantly focuses on fostering open-source libraries.</p>"},{"location":"api/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <ul> <li>class accelerometer Acceleration sensing hardware abstraction interface. <ul> <li>struct read_t Result from reading the accelerometer. </li> </ul> </li> <li>class adc Analog to Digital Converter (ADC) hardware abstraction interface. <ul> <li>struct read_t Result from reading the adc. </li> </ul> </li> <li>struct bit_limits Similar to std::numeric_limits&lt;T&gt; except that this object can give properties of integral types of arbitrary bit widths. </li> <li>struct bit_mask Represents a bit mask of contiguous bits. </li> <li>class bit_modify </li> <li>class bit_value </li> <li>struct byte_mask Helper for generating byte position masks. </li> <li>class can Controller Area Network (CAN bus) hardware abstraction interface. <ul> <li>struct message_t A CAN message. </li> <li>struct send_t Feedback from sending data over the CAN BUS. </li> <li>struct settings Generic settings for a can peripheral. </li> </ul> </li> <li>class can_router Route CAN messages received on the can bus to callbacks based on ID. <ul> <li>struct route </li> </ul> </li> <li>namespace cortex_m libhal drivers for the ARM Cortex-M series of processors <ul> <li>class dwt_counter A counter with a frequency fixed to the CPU clock rate. </li> <li>class interrupt Cortex M series interrupt controller. <ul> <li>class exception_number represents an interrupt request number along with helper functions for setting up the interrupt controller registers. </li> </ul> </li> <li>class systick_timer SysTick driver for the ARM Cortex Mx series chips. </li> </ul> </li> <li>class dac Digital to Analog Converter (DAC) hardware abstraction interface. <ul> <li>struct write_t Feedback from writing a voltage to the dac. </li> </ul> </li> <li>class distance_sensor Linear distance hardware abstraction interface. <ul> <li>struct read_t Result from sampling the distance sensor. </li> </ul> </li> <li>namespace error Error objects, templates, and constants. <ul> <li>struct invalid_option_t Used for defining static_asserts that should always fail, but only if the static_assert line is hit via <code>if constexpr</code> control block. Prefer to NOT use this directly but to use<code>invalid_option</code> instead.</li> </ul> </li> <li>namespace esp8266 libhal compatible libraries for the esp8266 device and microcontroller <ul> <li>class at AT Command network driver for the esp8266 . <ul> <li>struct read_t </li> <li>struct socket_config </li> <li>struct write_t </li> </ul> </li> </ul> </li> <li>class gyroscope Angular velocity sensing hardware abstraction interface. <ul> <li>struct read_t Result from reading the gyroscope. </li> </ul> </li> <li>class i2c Inter-integrated Circuit (I2C) hardware abstract interface. <ul> <li>struct settings Generic settings for a standard I2C device. </li> <li>struct transaction_t Feedback from performing a transaction on the i2c bus.</li> </ul> </li> <li>class input_pin Digital input pin hardware abstraction interface. <ul> <li>struct level_t Input pin level reading structure. </li> <li>struct settings Generic settings for input pins. </li> </ul> </li> <li>class interrupt_pin Digital interrupt pin hardware abstraction. <ul> <li>struct settings Generic settings for interrupt pins. </li> </ul> </li> <li>namespace literals Namespace containing user defined literals for the hal standard units. </li> <li>namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP <ul> <li>class adc Analog to digital converter. <ul> <li>struct channel Channel specific information. </li> </ul> </li> <li>class can <ul> <li>struct port </li> </ul> </li> <li>class clock Allows user code to manipulate and retrieve the various system clocks speeds. <ul> <li>struct configuration Clock configuration object. <ul> <li>struct cpu_t cpu clock control config struct </li> <li>struct pll_t phase locked loops config struct </li> <li>struct spifi_t spifi clock control config struct </li> <li>struct usb_t usb clock control config struct </li> </ul> </li> </ul> </li> <li>class i2c <ul> <li>struct bus_info </li> </ul> </li> <li>class input_pin Input pin implementation for the lpc40xx. </li> <li>class interrupt_pin Interrupt pin implementation for the lpc40xx. </li> <li>class output_pin Output pin implementation for the lpc40xx. </li> <li>class pin lpc40xx pin multiplexing and control driver used drivers and apps seeking to tune the pins. </li> <li>class power Power control for lpc40xx peripherals. </li> <li>class pwm pwm driver for the lpc40xx series of micro controllers <ul> <li>struct channel Channel specific information. </li> </ul> </li> <li>class spi <ul> <li>struct bus_info Information used to configure the spi bus. </li> </ul> </li> <li>class uart Implementation of the UART peripheral for the LPC40xx family of microcontrollers. <ul> <li>struct port </li> </ul> </li> </ul> </li> <li>class magnetometer Magnetic field strength sensing hardware abstraction interface. <ul> <li>struct read_t Result from reading the accelerometer. </li> </ul> </li> <li>namespace micromod <ul> <li>namespace v1 </li> </ul> </li> <li>namespace mock <ul> <li>struct adc Mock adc implementation for use in unit tests and simulations. </li> <li>struct can Mock can implementation for use in unit tests and simulations. </li> <li>struct dac Mock dac implementation for use in unit tests and simulations with a spy function for write() __    </li> <li>struct input_pin mock input_pin implementation for use in unit tests and simulations. </li> <li>struct interrupt_pin mock interrupt_pin implementation for use in unit tests and simulations. </li> <li>struct motor Mock motor implementation for use in unit tests and simulations with a spy function for power() __    </li> <li>struct output_pin mock output pin for use in unit tests and simulations </li> <li>struct pwm Mock pwm implementation for use in unit tests and simulations with spy functions for frequency() andduty_cycle() . </li> <li>struct steady_clock mock steady_clock implementation for use in unit tests and simulations. </li> <li>struct timer Mock timer implementation for use in unit tests and simulations with spy functions for schedule() , clear(), andis_running() __    </li> <li>struct write_only_spi Mock spi implementation for use in unit tests and simulations with a spy functions for configure() and a record for thetransfer() out data. The record ignores the in buffer and just stores the data being sent so it can be inspected later. </li> </ul> </li> <li>class motor Hardware abstraction for an open loop rotational actuator. <ul> <li>struct power_t Feedback from setting the motor power. </li> </ul> </li> <li>class move_interceptor Use this to perform changes on an object its move constructor is executed. </li> <li>namespace mpl <ul> <li>class mpl3115a2 <ul> <li>struct altitude_read_t </li> <li>struct pressure_read_t </li> <li>struct temperature_read_t </li> </ul> </li> </ul> </li> <li>struct nibble_mask Helper for generating nibble position masks. </li> <li>class output_pin Digital output pin hardware abstraction. <ul> <li>struct level_t Pin level reading structure. </li> <li>struct set_level_t Feedback from setting the pin state. </li> <li>struct settings Generic settings for output pins. </li> </ul> </li> <li>class overflow_counter Extend a counter's count from an arbitrary bit width to 64-bits by detecting overflows in the count. Each detected overflow is added to an overflow counter which is combined with the current count in order create a count up to 64-bits in length. </li> <li>class pwm Pulse Width Modulation (PWM) channel hardware abstraction. <ul> <li>struct duty_cycle_t Feedback setting the pwm duty cycle. </li> <li>struct frequency_t Feedback setting the pwm frequency. </li> </ul> </li> <li>class read_into Non-blocking callable for reading serial data into a buffer. </li> <li>class read_uint32 Read bytes from serial port and convert to integer. </li> <li>class read_upto Discard received bytes until the sequence is found. </li> <li>namespace rmd <ul> <li>class drc Driver for RMD motors equip with the DRC motor drivers. <ul> <li>struct feedback_t </li> </ul> </li> <li>class drc_motor Motor interface adaptor for DRC. </li> <li>class drc_rotation_sensor Rotation sensor adaptor for DRC motors. </li> <li>class drc_servo Servo interface adaptor for DRC. </li> <li>class drc_temperature_sensor Temperature sensor adaptor for DRC motors. </li> <li>class mc_x Driver for RMD series motors equip with the MC-X motor driver. <ul> <li>struct feedback_t </li> </ul> </li> <li>class mc_x_motor Control a mc_x motor driver like ahal::motor . </li> <li>class mc_x_rotation Reports the rotation of the DRC motor. </li> <li>class mc_x_servo Control a mc_x motor driver like ahal::servo . </li> <li>class mc_x_temperature Reports the temperature of the DRC motor. </li> </ul> </li> <li>class rotation_sensor Rotation measuring hardware abstraction interface. <ul> <li>struct read_t Result from reading the rotation sensor. </li> </ul> </li> <li>class serial Hardware abstract interface for the serial communication protocol. <ul> <li>struct flush_t Feedback from performing a flush operation. </li> <li>struct read_t Return type for serial read operations. </li> <li>struct settings Generic settings for a standard serial device. </li> <li>struct write_t Return type for serial write operations. </li> </ul> </li> <li>class servo Hardware abstraction for a closed loop position controlled rotational actuator. <ul> <li>struct position_t Feedback from setting the servo position. </li> <li>struct range_error Error information indicating the range of the servo. </li> </ul> </li> <li>class skip_past Discard received bytes until the sequence is found. </li> <li>namespace soft <ul> <li>class adc_multiplexer A driver for an ADC multiplexer that manages and reads ADC mux pins. This driver is intended to be used with multiplexers that use digital signals. An ADC multiplexer can be used to expand the number of input channels of an ADC. </li> <li>class adc_mux_pin A class that represents a multiplexer pin for ADC. </li> <li>class inert_accelerometer Inert implementation of acceleration sensing hardware. </li> <li>class inert_adc Inert implementation of Analog to Digital Converter (ADC) hardware. </li> <li>class inert_dac Inert implementation of Digital to Analog Converter (DAC) hardware. </li> <li>class inert_distance_sensor Inert implementation of linear distance hardware. </li> <li>class inert_gyroscope Inert implementation of angular velocity sensing hardware. </li> <li>class inert_input_pin Inert implementation of digital input pin hardware. </li> <li>class inert_interrupt_pin Inert implementation of digital interrupt pin hardware. </li> <li>class inert_magnetometer Inert implementation of magnetic field strength sensing hardware. </li> <li>class inert_motor Inert implementation of open loop motorized actuator hardware. </li> <li>class inert_output_pin Inert implementation of digital output pin hardware. </li> <li>class inert_pwm Inert implementation of Pulse Width Modulation (PWM) channel hardware. </li> <li>class inert_rotation_sensor Inert implementation of rotation measuring hardware. </li> <li>class inert_steady_clock Inert implementation of steady clock mechanism. </li> <li>class inert_temperature_sensor Inert implementation of temperature sensing hardware. </li> <li>class inert_timer Inert implementation of timer hardware. </li> <li>class input_pin_inverter </li> <li>class minimum_speed_i2c A i2c wrapper to ensure that the lowesti2c device frequency is used. </li> <li>class output_pin_inverter </li> <li>class rc_servo Generic RC servo driver. <ul> <li>struct settings Information about the RC servo needed to control it properly. </li> </ul> </li> </ul> </li> <li>class spi Serial peripheral interface (SPI) communication protocol hardware abstract interface. <ul> <li>struct settings Generic settings for a standard SPI device. </li> <li>struct transfer_t Feedback from performing a transfer on the spi bus. </li> </ul> </li> <li>class spy_handler Helper utility for making mocks for class functions that return status. </li> <li>class static_callable General class which will be used to allow for signature to be used and then split by the below class. </li> <li>class static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt; Specialization of static_callable with the return type and arguments split up. </li> <li>class static_list static_list is a non-owning non-allocating doubly linked list container with O(1) memory utilization. <ul> <li>class item Item/node within the static linked list. </li> <li>class item_iterator Iterator for the static list. </li> </ul> </li> <li>class steady_clock Hardware abstraction interface for a steady clock mechanism. <ul> <li>struct frequency_t Result from requesting the operating frequency of the steady clock. </li> <li>struct uptime_t Result from calling uptime. </li> </ul> </li> <li>class steady_clock_timeout Timeout object based on hal::steady_clock . </li> <li>namespace stm32f1 <ul> <li>struct clock_tree <ul> <li>struct ahb_t Defines the configuration of the dividers beyond system clock mux. <ul> <li>struct apb1_t Maximum rate of 36 MHz. </li> <li>struct apb2_t <ul> <li>struct adc_t </li> </ul> </li> </ul> </li> <li>struct pll_t Defines the configuration of the PLL. <ul> <li>struct usb_divider_t </li> </ul> </li> <li>struct rtc_t Defines the configuration for the RTC. </li> </ul> </li> <li>class output_pin Output pin implementation for the stm32::f10x. </li> </ul> </li> <li>class stream_fill Non-blocking callable for reading serial data into a buffer. </li> <li>class stream_fill_upto Discard received bytes until the sequence is found. </li> <li>class stream_find Discard received bytes until the sequence is found. </li> <li>class stream_parse Read bytes from stream and convert to integer. </li> <li>class stream_skip Skip number of bytes in a byte stream. </li> <li>class temperature_sensor Temperature sensing hardware abstraction interface. <ul> <li>struct read_t Result from reading the temperature sensor. </li> </ul> </li> <li>class timer Timer hardware abstraction interface. <ul> <li>struct cancel_t Feedback from cancelling a timer. </li> <li>struct is_running_t Feedback after checking if the timer is running. </li> <li>struct out_of_bounds_error Error type indicating that the desired time delay is not achievable with this timer. </li> <li>struct schedule_t Feedback from scheduling a timer. </li> </ul> </li> </ul> </li> <li>class packet_manager </li> <li>struct ranges </li> <li>namespace std </li> </ul>"},{"location":"api/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir libraries <ul> <li>dir include <ul> <li>dir libhal <ul> <li>file accelerometer.hpp </li> <li>file adc.hpp </li> <li>file can.hpp </li> <li>file dac.hpp </li> <li>file distance_sensor.hpp </li> <li>file error.hpp </li> <li>file functional.hpp </li> <li>file gyroscope.hpp </li> <li>file i2c.hpp </li> <li>file input_pin.hpp </li> <li>file interrupt_pin.hpp </li> <li>file magnetometer.hpp </li> <li>file motor.hpp </li> <li>file output_pin.hpp </li> <li>file pwm.hpp </li> <li>file rotation_sensor.hpp </li> <li>file serial.hpp </li> <li>file servo.hpp </li> <li>file spi.hpp </li> <li>file steady_clock.hpp </li> <li>file temperature_sensor.hpp </li> <li>file timeout.hpp Provides the hal::timeout type and utility functions that use that type. </li> <li>file timer.hpp </li> <li>file units.hpp </li> </ul> </li> <li>dir libhal-armcortex <ul> <li>file dwt_counter.hpp </li> <li>file interrupt.hpp </li> <li>file startup.hpp </li> <li>file system_control.hpp </li> <li>file systick_timer.hpp </li> </ul> </li> <li>dir libhal-canrouter <ul> <li>file can_router.hpp </li> </ul> </li> <li>dir libhal-esp8266 <ul> <li>file at.hpp </li> </ul> </li> <li>dir libhal-lpc40 <ul> <li>file adc.hpp </li> <li>file can.hpp </li> <li>file clock.hpp </li> <li>file constants.hpp </li> <li>file i2c.hpp </li> <li>file input_pin.hpp </li> <li>file interrupt_pin.hpp </li> <li>file output_pin.hpp </li> <li>file pin.hpp </li> <li>file power.hpp </li> <li>file pwm.hpp </li> <li>file spi.hpp </li> <li>file uart.hpp </li> </ul> </li> <li>dir libhal-micromod <ul> <li>file micromod.hpp </li> </ul> </li> <li>dir libhal-mock <ul> <li>file adc.hpp </li> <li>file can.hpp </li> <li>file dac.hpp </li> <li>file input_pin.hpp </li> <li>file interrupt_pin.hpp </li> <li>file motor.hpp </li> <li>file output_pin.hpp </li> <li>file pwm.hpp </li> <li>file spi.hpp </li> <li>file steady_clock.hpp </li> <li>file testing.hpp </li> <li>file timer.hpp </li> </ul> </li> <li>dir libhal-mpl <ul> <li>file mpl3115a2.hpp </li> </ul> </li> <li>dir libhal-rmd <ul> <li>file drc.hpp </li> <li>file mc_x.hpp </li> </ul> </li> <li>dir libhal-soft <ul> <li>file adc_mux.hpp </li> <li>file i2c_minimum_speed.hpp </li> <li>file inverter.hpp </li> <li>dir inert_drivers <ul> <li>file inert_accelerometer.hpp </li> <li>file inert_adc.hpp </li> <li>file inert_dac.hpp </li> <li>file inert_distance_sensor.hpp </li> <li>file inert_gyroscope.hpp </li> <li>file inert_input_pin.hpp </li> <li>file inert_interrupt_pin.hpp </li> <li>file inert_magnetometer.hpp </li> <li>file inert_motor.hpp </li> <li>file inert_output_pin.hpp </li> <li>file inert_pwm.hpp </li> <li>file inert_rotation_sensor.hpp </li> <li>file inert_steady_clock.hpp </li> <li>file inert_temperature_sensor.hpp </li> <li>file inert_timer.hpp </li> </ul> </li> <li>file rc_servo.hpp </li> </ul> </li> <li>dir libhal-stm32f1 <ul> <li>file clock.hpp </li> <li>file constants.hpp </li> <li>file output_pin.hpp </li> <li>file pin.hpp </li> </ul> </li> <li>dir libhal-util <ul> <li>file as_bytes.hpp </li> <li>file bit.hpp </li> <li>file bit_limits.hpp </li> <li>file can.hpp </li> <li>file comparison.hpp </li> <li>file enum.hpp </li> <li>file i2c.hpp </li> <li>file input_pin.hpp </li> <li>file interrupt_pin.hpp </li> <li>file map.hpp </li> <li>file math.hpp Compile time generic math utility functions. </li> <li>file move_interceptor.hpp </li> <li>file output_pin.hpp </li> <li>file overflow_counter.hpp </li> <li>file serial.hpp </li> <li>file serial_coroutines.hpp </li> <li>file spi.hpp </li> <li>file static_callable.hpp </li> <li>file static_list.hpp </li> <li>file steady_clock.hpp </li> <li>file streams.hpp </li> <li>file timeout.hpp </li> <li>file to_array.hpp </li> <li>file units.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"api/namespacehal/","title":"Namespace hal","text":"<p>Namespace List &gt; hal</p> <p>The foundation of libhal containing, interfaces, utilities and soft drivers. </p>"},{"location":"api/namespacehal/#namespaces","title":"Namespaces","text":"Type Name namespace cortex_m libhal drivers for the ARM Cortex-M series of processors namespace error Error objects, templates, and constants. namespace esp8266 libhal compatible libraries for the esp8266 device and microcontroller namespace literals Namespace containing user defined literals for the hal standard units. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP namespace micromod namespace mock namespace mpl namespace rmd namespace soft namespace stm32f1"},{"location":"api/namespacehal/#classes","title":"Classes","text":"Type Name class accelerometer Acceleration sensing hardware abstraction interface. class adc Analog to Digital Converter (ADC) hardware abstraction interface. struct bit_limits &lt;BitWidth, int_t&gt;Similar to std::numeric_limits&lt;T&gt; except that this object can give properties of integral types of arbitrary bit widths. struct bit_mask Represents a bit mask of contiguous bits. class bit_modify &lt;T&gt; class bit_value &lt;T&gt; struct byte_mask &lt;ByteIndex&gt;Helper for generating byte position masks. class can Controller Area Network (CAN bus) hardware abstraction interface. class can_router Route CAN messages received on the can bus to callbacks based on ID. class dac Digital to Analog Converter (DAC) hardware abstraction interface. class distance_sensor Linear distance hardware abstraction interface. class gyroscope Angular velocity sensing hardware abstraction interface. class i2c Inter-integrated Circuit (I2C) hardware abstract interface. class input_pin Digital input pin hardware abstraction interface. class interrupt_pin Digital interrupt pin hardware abstraction. class magnetometer Magnetic field strength sensing hardware abstraction interface. class motor Hardware abstraction for an open loop rotational actuator. class move_interceptor &lt;class T&gt;Use this to perform changes on an object its move constructor is executed. struct nibble_mask &lt;NibbleIndex&gt;Helper for generating nibble position masks. class output_pin Digital output pin hardware abstraction. class overflow_counter &lt;CountBitWidth&gt;Extend a counter's count from an arbitrary bit width to 64-bits by detecting overflows in the count. Each detected overflow is added to an overflow counter which is combined with the current count in order create a count up to 64-bits in length. class pwm Pulse Width Modulation (PWM) channel hardware abstraction. class read_into Non-blocking callable for reading serial data into a buffer. class read_uint32 Read bytes from serial port and convert to integer. class read_upto Discard received bytes until the sequence is found. class rotation_sensor Rotation measuring hardware abstraction interface. class serial Hardware abstract interface for the serial communication protocol. class servo Hardware abstraction for a closed loop position controlled rotational actuator. class skip_past Discard received bytes until the sequence is found. class spi Serial peripheral interface (SPI) communication protocol hardware abstract interface. class spy_handler &lt;args_t&gt;Helper utility for making mocks for class functions that return status. class static_callable &lt;class owner_class, reference_designator, typename signature&gt;General class which will be used to allow for signature to be used and then split by the below class. class static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt; &lt;class owner_class, reference_designator, typename return_t, args_t&gt;Specialization of static_callable with the return type and arguments split up. class static_list &lt;class Object&gt;static_list is a non-owning non-allocating doubly linked list container with O(1) memory utilization. class steady_clock Hardware abstraction interface for a steady clock mechanism. class steady_clock_timeout Timeout object based on hal::steady_clock . class stream_fill Non-blocking callable for reading serial data into a buffer. class stream_fill_upto Discard received bytes until the sequence is found. class stream_find Discard received bytes until the sequence is found. class stream_parse &lt;T&gt;Read bytes from stream and convert to integer. class stream_skip Skip number of bytes in a byte stream. class temperature_sensor Temperature sensing hardware abstraction interface. class timer Timer hardware abstraction interface."},{"location":"api/namespacehal/#public-types","title":"Public Types","text":"Type Name typedef float ampere Type for current represented in amps. typedef std::uint8_t byte typedef inplace_function&lt; F, sizeof(std::intptr_t) *2 &gt; callback Definition of a standard libhal owning callback object. typedef float celsius Type for temperature represented in celsius. typedef float degrees Type for angle represented in degrees. typedef void(void) error_handler typedef tl::function_ref&lt; F &gt; function_ref Definition of a non-owning callable object. typedef float g_force typedef float gauss Type for magnetic field represented in gauss. typedef float hertz Type for frequency represented in hertz. enum i2c_operation Set of I2C transaction operations. typedef stdext::inplace_function&lt; F, Capacity &gt; inplace_function Definition of a owning callable object. typedef boost::leaf::match&lt; T, value... &gt; match typedef float meters Type for length represented in meters. enum pin_resistor Set of possible pin mode resistor settings. typedef boost::leaf::result&lt; T &gt; result typedef float rpm Type for rotational velocity represented in RPMs. typedef result&lt; void &gt; status typedef std::chrono::nanoseconds time_duration The standard time durations in libhal std::chrono::nanoseconds. typedef status(void) timeout_function Timeout is a callable object or function that signals to a procedure that the procedure has exceeded its time allotment and should return control to the calling function. typedef float volts Type for voltage represented in volts. typedef result&lt; work_state &gt;() work_function A non-blocking callable that performs work with each call. enum work_state Represents the state of a coroutine or resumable callable."},{"location":"api/namespacehal/#public-attributes","title":"Public Attributes","text":"Type Name constexpr hal::bit_mask byte_m   = = byte_mask&lt;ByteIndex&gt;::valueShorthand for using hal::byte_mask&lt;N&gt;::value . concept convertible_to_bytes   = = requires(T a) { *a.data(); a.size(); } concept enumeration   = = std::is_enum_v&lt;T&gt;concept for enumeration types concept has_work_state   = = requires(T a) { { a.state() } -&gt; std::same_as&lt;work_state&gt;; } constexpr hal::bit_mask nibble_m   = = nibble_mask&lt;NibbleIndex&gt;::valueShorthand for using hal::nibble_mask&lt;N&gt;::value. error_handler * on_error_callback   = = nullptr concept timeout   = = std::convertible_to&lt;T, hal::function_ref&lt;timeout_function&gt;&gt; concept worker   = = std::convertible_to&lt;T, hal::function_ref&lt;work_function&gt;&gt;"},{"location":"api/namespacehal/#public-functions","title":"Public Functions","text":"Type Name constexpr T absolute_value (T p_value) Generic absolute value function that works for integer types. constexpr std::span&lt; const hal::byte &gt; as_bytes (const T * p_address, size_t p_number_of_elements)  constexpr std::span&lt; const hal::byte &gt; as_bytes (const convertible_to_bytes auto &amp; p_container)  constexpr std::span&lt; hal::byte &gt; as_writable_bytes (T * p_address, size_t p_number_of_elements)  constexpr std::span&lt; hal::byte &gt; as_writable_bytes (convertible_to_bytes auto &amp; p_container)  constexpr auto attempt (TryBlock &amp;&amp; p_try_block, H &amp;&amp;... p_handlers)  constexpr auto attempt_all (TryBlock &amp;&amp; p_try_block, H &amp;&amp;... p_handlers)  constexpr auto bit_extract (std::unsigned_integral auto p_value)  constexpr auto bit_extract (bit_mask p_field, std::unsigned_integral auto p_value)  constexpr std::uint16_t bit_width (const can::settings &amp; p_settings)  steady_clock_timeout create_timeout (hal::steady_clock &amp; p_steady_clock, hal::time_duration p_duration) Create a timeout object based on hal::steady_clock . constexpr std::int64_t cycles_per (hertz p_source, hal::time_duration p_duration) Calculate the number of cycles of this frequency within the time duration. This function is meant for timers to determine how many count cycles are needed to reach a particular time duration at this frequency. status delay (timeout auto p_timeout) Delay the execution of the application or thread for a duration of time. void delay (hal::steady_clock &amp; p_steady_clock, hal::time_duration p_duration) Delay execution for a duration of time using a hardware steady_clock . constexpr T distance (T p_left, T p_right) Calculates the distance between two values (L1 Norm or Manhattan distance), the absolute value of their difference. constexpr std::make_unsigned_t&lt; T &gt; distance (T p_left, T p_right) Calculates the distance between two values (L1 Norm or Manhattan distance), the absolute value of their difference. result&lt; std::chrono::nanoseconds &gt; duration_from_cycles (hertz p_source, uint32_t p_cycles) Calculate the amount of time it takes a frequency to oscillate a number of cycles. constexpr bool failed (work_state p_state)  constexpr bool failed (has_work_state auto p_worker)  constexpr bool finished (work_state p_state)  constexpr bool finished (has_work_state auto p_worker)  std::uint64_t future_deadline (hal::steady_clock &amp; p_steady_clock, hal::time_duration p_duration) Function to compute a future timestamp in ticks. consteval T generate_field_of_ones () Generate a mask of 1s at compile time. void halt ()  constexpr bool in_progress (work_state p_state)  constexpr bool in_progress (has_work_state auto p_worker)  constexpr std::optional&lt; std::uint32_t &gt; is_valid (const can::settings &amp; p_settings, hertz p_operating_frequency) Validate configuration settings against an operating frequency. constexpr float map (float p_target, std::pair&lt; float, float &gt; p_input_range, std::pair&lt; float, float &gt; p_output_range) Map an target value [x] from an input range [a,b] to an output range [c,d]. result&lt; T &gt; multiply (T p_lhs, T p_rhs) Perform multiply operation and return an error code <code>std::errc::result_out_of_range</code> if the two values when multiplied would overflow the containing value. auto never_timeout () Create a timeout that will never time out. auto new_error (Item &amp;&amp;... p_item)  std::basic_ostream&lt; CharT, Traits &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; CharT, Traits &gt; &amp; p_ostream, const work_state &amp; p_state)  std::basic_ostream&lt; CharT, Traits &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; CharT, Traits &gt; &amp; p_ostream, const hal::byte &amp; p_byte) print byte type using ostreams constexpr auto operator== (const can::settings &amp; p_lhs, const can::settings &amp; p_rhs)  constexpr auto operator== (const can::message_t &amp; p_lhs, const can::message_t &amp; p_rhs)  constexpr auto operator== (const i2c::settings &amp; p_lhs, const i2c::settings &amp; p_rhs)  constexpr auto operator== (const input_pin::settings &amp; p_lhs, const input_pin::settings &amp; p_rhs)  constexpr auto operator== (const interrupt_pin::settings &amp; p_lhs, const interrupt_pin::settings &amp; p_rhs)  constexpr auto operator== (const output_pin::settings &amp; p_lhs, const output_pin::settings &amp; p_rhs)  constexpr auto operator== (const serial::settings &amp; p_lhs, const serial::settings &amp; p_rhs)  constexpr auto operator== (const spi::settings &amp; p_lhs, const spi::settings &amp; p_rhs)  void print (serial &amp; p_serial, DataArray &amp;&amp; p_data) Write data to serial buffer and drop return value. void print (serial &amp; p_serial, const char * p_format, Parameters... p_parameters) Write formatted string data to serial buffer and drop return value. hal::result&lt; hal::i2c::transaction_t &gt; probe (i2c &amp; p_i2c, hal::byte p_address) probe the i2c bus to see if a device exists hal::result&lt; hal::i2c::transaction_t &gt; read (i2c &amp; p_i2c, hal::byte p_address, std::span&lt; hal::byte &gt; p_data_in, timeout auto p_timeout) read bytes from target device on i2c bus hal::result&lt; hal::i2c::transaction_t &gt; read (i2c &amp; p_i2c, hal::byte p_address, std::span&lt; hal::byte &gt; p_data_in) read bytes from target device on i2c bus result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; read (i2c &amp; p_i2c, hal::byte p_address, timeout auto p_timeout) return array of read bytes from target device on i2c bus result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; read (i2c &amp; p_i2c, hal::byte p_address) return array of read bytes from target device on i2c bus result&lt; std::span&lt; hal::byte &gt; &gt; read (serial &amp; p_serial, std::span&lt; hal::byte &gt; p_data_in, timeout auto p_timeout) Read bytes from a serial port. result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; read (serial &amp; p_serial, timeout auto p_timeout) Read bytes from a serial port and return an array. result&lt; hal::spi::transfer_t &gt; read (spi &amp; p_spi, std::span&lt; hal::byte &gt; p_data_in, hal::byte p_filler=spi::default_filler) Read data from the SPI bus. result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; read (spi &amp; p_spi, hal::byte p_filler=spi::default_filler) Read data from the SPI bus and return a std::array of bytes. constexpr T rounding_division (T p_numerator, T p_denominator) Perform integer division and round the value up if the next decimal place is greater than or equal to 0.5. status success () a readability function for returning successful results; constexpr bool terminated (work_state p_state)  constexpr bool terminated (has_work_state auto p_worker)  auto timeout_generator (hal::steady_clock &amp; p_steady_clock) Generates a function that, when passed a duration, returns a timeout. hal::byte to_8_bit_address (hal::byte p_address, i2c_operation p_operation) noexceptConvert 7-bit i2c address to an 8-bit address. constexpr std::array&lt; char, N+1 &gt; to_array (std::string_view p_view) Convert a string_view into a std::array of N number of characters. constexpr std::string_view to_string (work_state p_state)  result&lt; work_state &gt; try_until (worker auto &amp; p_worker, timeout auto p_timeout) Repeatedly call a worker function until it has reached a terminal state or a timeout has been reached. result&lt; work_state &gt; try_until (worker auto &amp;&amp; p_worker, timeout auto p_timeout) Repeatedly call a worker function until it has reached a terminal state or a timeout has been reached. constexpr auto value (enumeration auto p_enum_value) Helper function to convert an enum to its integral value. constexpr std::chrono::duration&lt; int64_t, Period &gt; wavelength (hertz p_source) Calculates and returns the wavelength in seconds. hal::result&lt; hal::i2c::transaction_t &gt; write (i2c &amp; p_i2c, hal::byte p_address, std::span&lt; const hal::byte &gt; p_data_out, timeout auto p_timeout) write data to a target device on the i2c bus hal::result&lt; hal::i2c::transaction_t &gt; write (i2c &amp; p_i2c, hal::byte p_address, std::span&lt; const hal::byte &gt; p_data_out) write data to a target device on the i2c bus status write (serial &amp; p_serial, std::span&lt; const hal::byte &gt; p_data_out) Write bytes to a serial port. status write (serial &amp; p_serial, std::string_view p_data_out) Write std::span of const char to a serial port. result&lt; hal::spi::transfer_t &gt; write (spi &amp; p_spi, std::span&lt; const hal::byte &gt; p_data_out) Write data to the SPI bus and ignore data sent from peripherals on the bus. result&lt; serial::write_t &gt; write_partial (serial &amp; p_serial, std::span&lt; const hal::byte &gt; p_data_out) Write bytes to a serial port. hal::result&lt; hal::i2c::transaction_t &gt; write_then_read (i2c &amp; p_i2c, hal::byte p_address, std::span&lt; const hal::byte &gt; p_data_out, std::span&lt; hal::byte &gt; p_data_in, timeout auto p_timeout=hal::never_timeout()) write and then read bytes from target device on i2c bus hal::result&lt; hal::i2c::transaction_t &gt; write_then_read (i2c &amp; p_i2c, hal::byte p_address, std::span&lt; const hal::byte &gt; p_data_out, std::span&lt; hal::byte &gt; p_data_in) write and then read bytes from target device on i2c bus result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; write_then_read (i2c &amp; p_i2c, hal::byte p_address, std::span&lt; const hal::byte &gt; p_data_out, timeout auto p_timeout) write and then return an array of read bytes from target device on i2c bus result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; write_then_read (i2c &amp; p_i2c, hal::byte p_address, std::span&lt; const hal::byte &gt; p_data_out) write and then return an array of read bytes from target device on i2c bus result&lt; std::span&lt; hal::byte &gt; &gt; write_then_read (serial &amp; p_serial, std::span&lt; const hal::byte &gt; p_data_out, std::span&lt; hal::byte &gt; p_data_in, timeout auto p_timeout) Perform a write then read transaction over serial. result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; write_then_read (serial &amp; p_serial, std::span&lt; const hal::byte &gt; p_data_out, timeout auto p_timeout) Perform a write then read transaction over serial. result&lt; hal::spi::transfer_t &gt; write_then_read (spi &amp; p_spi, std::span&lt; const hal::byte &gt; p_data_out, std::span&lt; hal::byte &gt; p_data_in, hal::byte p_filler=spi::default_filler) Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI and fill the write line with filler bytes. result&lt; std::array&lt; hal::byte, BytesToRead &gt; &gt; write_then_read (spi &amp; p_spi, std::span&lt; const hal::byte &gt; p_data_out, hal::byte p_filler=spi::default_filler) Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI, fill the write line with filler bytes and return an array of bytes."},{"location":"api/namespacehal/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr static bool equals (std::floating_point auto p_value1, std::floating_point auto p_value2, float p_epsilon=1e-9f) Determines if two values are equal within a relative error."},{"location":"api/namespacehal/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacehal/#typedef-ampere","title":"typedef ampere","text":"<pre><code>using hal::ampere = typedef float;\n</code></pre>"},{"location":"api/namespacehal/#typedef-byte","title":"typedef byte","text":"<pre><code>using hal::byte = typedef std::uint8_t;\n</code></pre> <p>Standard type for bytes in libhal. hal::byte has a number of annoyances that results in more verbose code without much benefit and thus hal::byte was created. </p>"},{"location":"api/namespacehal/#typedef-callback","title":"typedef callback","text":"<p>Definition of a standard libhal owning callback object. <pre><code>using hal::callback = typedef inplace_function&lt;F, sizeof(std::intptr_t) * 2&gt;;\n</code></pre></p> <p>This is an inplace_function with its capacity set to two pointers. Callable objects must fit within the size of two integers to be able to construct this polymorphic callable object.</p> <p>Template parameters:</p> <ul> <li><code>F</code> - function type or call signature </li> </ul>"},{"location":"api/namespacehal/#typedef-celsius","title":"typedef celsius","text":"<pre><code>using hal::celsius = typedef float;\n</code></pre>"},{"location":"api/namespacehal/#typedef-degrees","title":"typedef degrees","text":"<pre><code>using hal::degrees = typedef float;\n</code></pre>"},{"location":"api/namespacehal/#typedef-error_handler","title":"typedef error_handler","text":"<pre><code>using hal::error_handler = typedef void(void);\n</code></pre>"},{"location":"api/namespacehal/#typedef-function_ref","title":"typedef function_ref","text":"<p>Definition of a non-owning callable object. <pre><code>using hal::function_ref = typedef tl::function_ref&lt;F&gt;;\n</code></pre></p> <p>Use this for passing a callable object to a function that the function does not need to store in anyway. Best used for timeouts where a function simply needs the callable during the runtime of the function and when the function is over, the callable is no longer needed.</p> <p>This function is light weight in comparison to std::function, which is allocating, or inplace_function.</p> <p>Template parameters:</p> <ul> <li><code>F</code> - function type or call signature </li> </ul>"},{"location":"api/namespacehal/#typedef-g_force","title":"typedef g_force","text":"<pre><code>using hal::g_force = typedef float;\n</code></pre> <p>Type for acceleration represented in the force applied by gravity at sea level. </p>"},{"location":"api/namespacehal/#typedef-gauss","title":"typedef gauss","text":"<pre><code>using hal::gauss = typedef float;\n</code></pre>"},{"location":"api/namespacehal/#typedef-hertz","title":"typedef hertz","text":"<pre><code>using hal::hertz = typedef float;\n</code></pre>"},{"location":"api/namespacehal/#enum-i2c_operation","title":"enum i2c_operation","text":"<pre><code>enum hal::i2c_operation {\n    write = 0,\n    read = 1\n};\n</code></pre>"},{"location":"api/namespacehal/#typedef-inplace_function","title":"typedef inplace_function","text":"<p>Definition of a owning callable object. <pre><code>using hal::inplace_function = typedef stdext::inplace_function&lt;F, Capacity&gt;;\n</code></pre></p> <p>Use this instead of function_ref when a callable object needs to be stored.</p> <p>Template parameters:</p> <ul> <li><code>F</code> - function type or call signature </li> <li><code>Capacity</code> - storage capacity of the function in bytes. If a callable object has a size greater than the capacity, then attempting to create an inplace function with it will result in a compiler error. </li> </ul>"},{"location":"api/namespacehal/#typedef-match","title":"typedef match","text":"<pre><code>using hal::match = typedef boost::leaf::match&lt;T, value...&gt;;\n</code></pre>"},{"location":"api/namespacehal/#typedef-meters","title":"typedef meters","text":"<pre><code>using hal::meters = typedef float;\n</code></pre>"},{"location":"api/namespacehal/#enum-pin_resistor","title":"enum pin_resistor","text":"<p>Set of possible pin mode resistor settings. <pre><code>enum hal::pin_resistor {\n    none = 0,\n    pull_down,\n    pull_up\n};\n</code></pre></p> <p>See each enumeration to get more details about when and how these should be used. </p>"},{"location":"api/namespacehal/#typedef-result","title":"typedef result","text":"<pre><code>using hal::result = typedef boost::leaf::result&lt;T&gt;;\n</code></pre>"},{"location":"api/namespacehal/#typedef-rpm","title":"typedef rpm","text":"<pre><code>using hal::rpm = typedef float;\n</code></pre>"},{"location":"api/namespacehal/#typedef-status","title":"typedef status","text":"<pre><code>using hal::status = typedef result&lt;void&gt;;\n</code></pre>"},{"location":"api/namespacehal/#typedef-time_duration","title":"typedef time_duration","text":"<pre><code>using hal::time_duration = typedef std::chrono::nanoseconds;\n</code></pre>"},{"location":"api/namespacehal/#typedef-timeout_function","title":"typedef timeout_function","text":"<p>Timeout is a callable object or function that signals to a procedure that the procedure has exceeded its time allotment and should return control to the calling function. <pre><code>using hal::timeout_function = typedef status(void);\n</code></pre></p> <p>Exception:</p> <ul> <li><code>hal::timeout</code> - when the timeout condition has been met. </li> </ul> <p>Returns:</p> <p>status - sets error flag set when timeout condition has been met, otherwise returns success. </p>"},{"location":"api/namespacehal/#typedef-volts","title":"typedef volts","text":"<pre><code>using hal::volts = typedef float;\n</code></pre>"},{"location":"api/namespacehal/#typedef-work_function","title":"typedef work_function","text":"<p>A non-blocking callable that performs work with each call. <pre><code>using hal::work_function = typedef result&lt;work_state&gt;();\n</code></pre></p> <p>Each call to a work_function will perform a set of work. The worker will return a work_state to indicate its current state. Once the worker reaches a terminal state, it MUST perform no additional work and return the terminal state. For example, if a work function failed, it must always return failure and not interact with hardware or other software from that point on. Same will occur for the \"finished\" state.</p> <p>This function can be repeatedly tried until it has reached a terminal state with the try_until() function.</p> <p>Returns:</p> <p>result&lt;work_state&gt; - sets error flag set when an error occurs, otherwise returns work_state enum. </p>"},{"location":"api/namespacehal/#enum-work_state","title":"enum work_state","text":"<pre><code>enum hal::work_state {\n    in_progress,\n    failed,\n    finished\n};\n</code></pre>"},{"location":"api/namespacehal/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespacehal/#variable-byte_m","title":"variable byte_m","text":"<p>Shorthand for using hal::byte_mask&lt;N&gt;::value . <pre><code>constexpr hal::bit_mask hal::byte_m;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>ByteIndex</code> - the byte position to make a mask for </li> </ul>"},{"location":"api/namespacehal/#variable-convertible_to_bytes","title":"variable convertible_to_bytes","text":"<pre><code>concept hal::convertible_to_bytes;\n</code></pre>"},{"location":"api/namespacehal/#variable-enumeration","title":"variable enumeration","text":"<p>concept for enumeration types <pre><code>concept hal::enumeration;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> - enum type </li> </ul>"},{"location":"api/namespacehal/#variable-has_work_state","title":"variable has_work_state","text":"<pre><code>concept hal::has_work_state;\n</code></pre>"},{"location":"api/namespacehal/#variable-nibble_m","title":"variable nibble_m","text":"<p>Shorthand for using hal::nibble_mask&lt;N&gt;::value. <pre><code>constexpr hal::bit_mask hal::nibble_m;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>NibbleIndex</code> - the nibble position to make a mask for </li> </ul>"},{"location":"api/namespacehal/#variable-on_error_callback","title":"variable on_error_callback","text":"<pre><code>error_handler* hal::on_error_callback;\n</code></pre>"},{"location":"api/namespacehal/#variable-timeout","title":"variable timeout","text":"<pre><code>concept hal::timeout;\n</code></pre>"},{"location":"api/namespacehal/#variable-worker","title":"variable worker","text":"<pre><code>concept hal::worker;\n</code></pre>"},{"location":"api/namespacehal/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacehal/#function-absolute_value","title":"function absolute_value","text":"<p>Generic absolute value function that works for integer types. <pre><code>template&lt;typename T typename T&gt;\nconstexpr T hal::absolute_value (\n    T p_value\n) \n</code></pre></p> <p>Preferred this over the C API for rounding numbers such as abs(), labs() and llabs(). This function relieves the need in template code to check the type of the integer and select the correct function to call.</p> <p>NOTE: If p_value is minimum negative number of type T then the resulting return value will be the maximum positive number represented by T. For example, INT32_MIN is 2147483648 where as INT32_MAX is 2147483647. The absolute value of INT32_MIN is 1 greater than INT32_MAX. To prevent overflow, passing INT32_MIN will simply return back INT32_MAX.</p> <p>Template parameters:</p> <ul> <li><code>T</code> - integral type </li> </ul> <p>Parameters:</p> <ul> <li><code>p_value</code> - integer value to be made positive </li> </ul> <p>Returns:</p> <p>constexpr auto - positive representation of the integer </p>"},{"location":"api/namespacehal/#function-as_bytes","title":"function as_bytes","text":"<pre><code>template&lt;typename T typename T&gt;\nconstexpr std::span&lt; const hal::byte &gt; hal::as_bytes (\n    const T * p_address,\n    size_t p_number_of_elements\n) \n</code></pre>"},{"location":"api/namespacehal/#function-as_bytes_1","title":"function as_bytes","text":"<pre><code>constexpr std::span&lt; const hal::byte &gt; hal::as_bytes (\n    const convertible_to_bytes auto &amp; p_container\n) \n</code></pre>"},{"location":"api/namespacehal/#function-as_writable_bytes","title":"function as_writable_bytes","text":"<pre><code>template&lt;typename T typename T&gt;\nconstexpr std::span&lt; hal::byte &gt; hal::as_writable_bytes (\n    T * p_address,\n    size_t p_number_of_elements\n) \n</code></pre>"},{"location":"api/namespacehal/#function-as_writable_bytes_1","title":"function as_writable_bytes","text":"<pre><code>constexpr std::span&lt; hal::byte &gt; hal::as_writable_bytes (\n    convertible_to_bytes auto &amp; p_container\n) \n</code></pre>"},{"location":"api/namespacehal/#function-attempt","title":"function attempt","text":"<pre><code>template&lt;class TryBlock class TryBlock, class... H&gt;\nconstexpr auto hal::attempt (\n    TryBlock &amp;&amp; p_try_block,\n    H &amp;&amp;... p_handlers\n) \n</code></pre>"},{"location":"api/namespacehal/#function-attempt_all","title":"function attempt_all","text":"<pre><code>template&lt;class TryBlock class TryBlock, class... H&gt;\nconstexpr auto hal::attempt_all (\n    TryBlock &amp;&amp; p_try_block,\n    H &amp;&amp;... p_handlers\n) \n</code></pre>"},{"location":"api/namespacehal/#function-bit_extract","title":"function bit_extract","text":"<pre><code>template&lt;bit_mask field&gt;\nconstexpr auto hal::bit_extract (\n    std::unsigned_integral auto p_value\n) \n</code></pre>"},{"location":"api/namespacehal/#function-bit_extract_1","title":"function bit_extract","text":"<pre><code>constexpr auto hal::bit_extract (\n    bit_mask p_field,\n    std::unsigned_integral auto p_value\n) \n</code></pre>"},{"location":"api/namespacehal/#function-bit_width","title":"function bit_width","text":"<pre><code>constexpr std::uint16_t hal::bit_width (\n    const can::settings &amp; p_settings\n) \n</code></pre>"},{"location":"api/namespacehal/#function-create_timeout","title":"function create_timeout","text":"<p>Create a timeout object based on hal::steady_clock . <pre><code>steady_clock_timeout hal::create_timeout (\n    hal::steady_clock &amp; p_steady_clock,\n    hal::time_duration p_duration\n) \n</code></pre></p> <p>NOTE: Multiple timeout objects can be made from a single steady_clock without influencing other timeout objects.</p> <p>Parameters:</p> <ul> <li><code>p_steady_clock</code> - hal::steady_clock implementation </li> <li><code>p_duration</code> - amount of time until timeout </li> </ul> <p>Returns:</p> <p>hal::steady_clock_timeout - timeout object </p>"},{"location":"api/namespacehal/#function-cycles_per","title":"function cycles_per","text":"<p>Calculate the number of cycles of this frequency within the time duration. This function is meant for timers to determine how many count cycles are needed to reach a particular time duration at this frequency. <pre><code>constexpr std::int64_t hal::cycles_per (\n    hertz p_source,\n    hal::time_duration p_duration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_source</code> - source frequency </li> <li><code>p_duration</code> - the amount of time to convert to cycles </li> </ul> <p>Returns:</p> <p>std::int64_t - number of cycles </p>"},{"location":"api/namespacehal/#function-delay","title":"function delay","text":"<p>Delay the execution of the application or thread for a duration of time. <pre><code>inline status hal::delay (\n    timeout auto p_timeout\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Timeout</code> - timeout type </li> </ul> <p>Parameters:</p> <ul> <li><code>p_timeout</code> - callable timeout object </li> </ul> <p>Returns:</p> <p>status - success or failure </p>"},{"location":"api/namespacehal/#function-delay_1","title":"function delay","text":"<p>Delay execution for a duration of time using a hardware steady_clock . <pre><code>void hal::delay (\n    hal::steady_clock &amp; p_steady_clock,\n    hal::time_duration p_duration\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_steady_clock</code> - steady_clock driver </li> <li><code>p_duration</code> - the amount of time to delay for. Zero or negative time duration will delay for one tick of the p_steady_clock. </li> </ul>"},{"location":"api/namespacehal/#function-distance","title":"function distance","text":"<p>Calculates the distance between two values (L1 Norm or Manhattan distance), the absolute value of their difference. <pre><code>template&lt;typename T typename T&gt;\nconstexpr T hal::distance (\n    T p_left,\n    T p_right\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> - integral type of the two values </li> </ul> <p>Parameters:</p> <ul> <li><code>p_left</code> - the first point of the distance calculation </li> <li><code>p_right</code> - the second point of the distance calculation </li> </ul> <p>Returns:</p> <p>constexpr T - absolute value of the difference between the two points. </p>"},{"location":"api/namespacehal/#function-distance_1","title":"function distance","text":"<p>Calculates the distance between two values (L1 Norm or Manhattan distance), the absolute value of their difference. <pre><code>template&lt;std::integral T&gt;\nconstexpr std::make_unsigned_t&lt; T &gt; hal::distance (\n    T p_left,\n    T p_right\n) \n</code></pre></p> <p>NOTE: Values cannot exceed int32_t.</p> <p>Template parameters:</p> <ul> <li><code>T</code> - integral type of the two values </li> </ul> <p>Parameters:</p> <ul> <li><code>p_left</code> - the first point of the distance calculation </li> <li><code>p_right</code> - the second point of the distance calculation </li> </ul> <p>Returns:</p> <p>constexpr T - absolute value of the difference between the two points. </p>"},{"location":"api/namespacehal/#function-duration_from_cycles","title":"function duration_from_cycles","text":"<p>Calculate the amount of time it takes a frequency to oscillate a number of cycles. <pre><code>inline result&lt; std::chrono::nanoseconds &gt; hal::duration_from_cycles (\n    hertz p_source,\n    uint32_t p_cycles\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_source</code> - the frequency to compute the cycles from </li> <li><code>p_cycles</code> - number of cycles within the time duration </li> </ul> <p>Returns:</p> <p>std::chrono::nanoseconds - time duration based on this frequency and the number of cycles </p>"},{"location":"api/namespacehal/#function-failed","title":"function failed","text":"<pre><code>constexpr bool hal::failed (\n    work_state p_state\n) \n</code></pre>"},{"location":"api/namespacehal/#function-failed_1","title":"function failed","text":"<pre><code>constexpr bool hal::failed (\n    has_work_state auto p_worker\n) \n</code></pre>"},{"location":"api/namespacehal/#function-finished","title":"function finished","text":"<pre><code>constexpr bool hal::finished (\n    work_state p_state\n) \n</code></pre>"},{"location":"api/namespacehal/#function-finished_1","title":"function finished","text":"<pre><code>constexpr bool hal::finished (\n    has_work_state auto p_worker\n) \n</code></pre>"},{"location":"api/namespacehal/#function-future_deadline","title":"function future_deadline","text":"<p>Function to compute a future timestamp in ticks. <pre><code>inline std::uint64_t hal::future_deadline (\n    hal::steady_clock &amp; p_steady_clock,\n    hal::time_duration p_duration\n) \n</code></pre></p> <p>This function calculates a future timestamp based on the current uptime of a steady clock and a specified duration.</p> <p>Parameters:</p> <ul> <li><code>p_steady_clock</code> - the steady_clock used to calculate the future duration. Note that this future deadline will only work with this steady clock. </li> <li><code>p_duration</code> The duration for which we need to compute a future timestamp.</li> </ul> <p>Returns:</p> <p>A 64-bit unsigned integer representing the future timestamp in steady clock ticks. The future timestamp is calculated as the sum of the current number of ticks of the clock and the number of ticks equivalent to the specified duration. If the duration corresponds to a ticks_required value less than or equal to 1, it will be set to 1 to ensure at least one tick is waited. </p>"},{"location":"api/namespacehal/#function-generate_field_of_ones","title":"function generate_field_of_ones","text":"<p>Generate a mask of 1s at compile time. <pre><code>template&lt;size_t BitWidth, std::integral T&gt;\nconsteval T hal::generate_field_of_ones () \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>BitWidth</code> - number of 1s in the mask </li> <li><code>T</code> - the type </li> </ul> <p>Returns:</p> <p>consteval uint32_t - mask with 1s at the LSB </p>"},{"location":"api/namespacehal/#function-halt","title":"function halt","text":"<pre><code>inline void hal::halt () \n</code></pre>"},{"location":"api/namespacehal/#function-in_progress","title":"function in_progress","text":"<pre><code>constexpr bool hal::in_progress (\n    work_state p_state\n) \n</code></pre>"},{"location":"api/namespacehal/#function-in_progress_1","title":"function in_progress","text":"<pre><code>constexpr bool hal::in_progress (\n    has_work_state auto p_worker\n) \n</code></pre>"},{"location":"api/namespacehal/#function-is_valid","title":"function is_valid","text":"<p>Validate configuration settings against an operating frequency. <pre><code>constexpr std::optional&lt; std::uint32_t &gt; hal::is_valid (\n    const can::settings &amp; p_settings,\n    hertz p_operating_frequency\n) \n</code></pre></p> <p>The settings and frequency must follow the following rules:</p> <ul> <li>propagation_delay, phase_segment1, phase_segment2 and synchronization_jump_width must be nonzero.</li> <li>synchronization_jump_width must be the lesser between phase_segment1 and phase_segment2.</li> <li>The total bit width must be equal to or greater than 8 Tq/bit; the sum of sync_segment, propagation_delay, phase_segment1 and phase_segment2.</li> <li>The CAN device's operating frequency must be at least 8 times the baud rate to give the minimum.</li> <li>The ratio between the CAN device's operating frequency and the bit width must be close enough to an integer to produce a usable baud rate prescaler.</li> </ul> <p>Parameters:</p> <ul> <li><code>p_settings</code> - settings object to check </li> <li><code>p_operating_frequency</code> - CAN device operating frequency </li> </ul> <p>Returns:</p> <p>std::optional&lt;std::uint32_t&gt; - baud rate prescaler </p>"},{"location":"api/namespacehal/#function-map","title":"function map","text":"<p>Map an target value [x] from an input range [a,b] to an output range [c,d]. <pre><code>constexpr float hal::map (\n    float p_target,\n    std::pair&lt; float, float &gt; p_input_range,\n    std::pair&lt; float, float &gt; p_output_range\n) \n</code></pre></p> <p>Another term for this is an affine transformation which follows this equation:  For example:</p> <p>let x = 5.0 let input_range = [0.0, 10.0] let output_range = [100.0, 200.0] The result will be 150.0</p> <p>Parameters:</p> <ul> <li><code>p_target</code> - target value within p_input_range to be mapped to the output range. </li> <li><code>p_input_range</code> - the input range of p_target </li> <li><code>p_output_range</code> - the output range to map p_target to </li> </ul> <p>Returns:</p> <p>constexpr float - value mapped from input range to the output range. The output is clamped to the output range. </p>"},{"location":"api/namespacehal/#function-multiply","title":"function multiply","text":"<p>Perform multiply operation and return an error code <code>std::errc::result_out_of_range</code> if the two values when multiplied would overflow the containing value. <pre><code>template&lt;typename T typename T&gt;\nresult&lt; T &gt; hal::multiply (\n    T p_lhs,\n    T p_rhs\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> - integer arithmetic type </li> </ul> <p>Parameters:</p> <ul> <li><code>p_lhs</code> - left hand side integer </li> <li><code>p_rhs</code> - right hand side integer </li> </ul> <p>Returns:</p> <p>result&lt;T&gt; - either the resultant or an error <code>std::errc::result_out_of_range</code> </p>"},{"location":"api/namespacehal/#function-never_timeout","title":"function never_timeout","text":"<p>Create a timeout that will never time out. <pre><code>inline auto hal::never_timeout () \n</code></pre></p> <p>Returns:</p> <p>auto - callable that will never return timeout </p>"},{"location":"api/namespacehal/#function-new_error","title":"function new_error","text":"<pre><code>template&lt;class... Item&gt;\ninline auto hal::new_error (\n    Item &amp;&amp;... p_item\n) \n</code></pre>"},{"location":"api/namespacehal/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;class CharT class CharT, class Traits class Traits&gt;\ninline std::basic_ostream&lt; CharT, Traits &gt; &amp; hal::operator&lt;&lt; (\n    std::basic_ostream&lt; CharT, Traits &gt; &amp; p_ostream,\n    const work_state &amp; p_state\n) \n</code></pre>"},{"location":"api/namespacehal/#function-operator_1","title":"function operator&lt;&lt;","text":"<p>print byte type using ostreams <pre><code>template&lt;class CharT class CharT, class Traits class Traits&gt;\ninline std::basic_ostream&lt; CharT, Traits &gt; &amp; hal::operator&lt;&lt; (\n    std::basic_ostream&lt; CharT, Traits &gt; &amp; p_ostream,\n    const hal::byte &amp; p_byte\n) \n</code></pre></p> <p>Meant for unit testing, testing and simulation purposes C++ streams, in general, should not be used for any embedded project that will ever have to be used on an MCU due to its memory cost.</p> <p>Template parameters:</p> <ul> <li><code>CharT</code> - character type </li> <li><code>Traits</code> - ostream traits type </li> </ul> <p>Parameters:</p> <ul> <li><code>p_ostream</code> - the ostream </li> <li><code>p_byte</code> - object to convert to a string </li> </ul> <p>Returns:</p> <p>std::basic_ostream&lt;CharT, Traits&gt;&amp; - reference to the ostream </p>"},{"location":"api/namespacehal/#function-operator_2","title":"function operator==","text":"<pre><code>constexpr auto hal::operator== (\n    const can::settings &amp; p_lhs,\n    const can::settings &amp; p_rhs\n) \n</code></pre>"},{"location":"api/namespacehal/#function-operator_3","title":"function operator==","text":"<pre><code>constexpr auto hal::operator== (\n    const can::message_t &amp; p_lhs,\n    const can::message_t &amp; p_rhs\n) \n</code></pre>"},{"location":"api/namespacehal/#function-operator_4","title":"function operator==","text":"<pre><code>constexpr auto hal::operator== (\n    const i2c::settings &amp; p_lhs,\n    const i2c::settings &amp; p_rhs\n) \n</code></pre>"},{"location":"api/namespacehal/#function-operator_5","title":"function operator==","text":"<pre><code>constexpr auto hal::operator== (\n    const input_pin::settings &amp; p_lhs,\n    const input_pin::settings &amp; p_rhs\n) \n</code></pre>"},{"location":"api/namespacehal/#function-operator_6","title":"function operator==","text":"<pre><code>constexpr auto hal::operator== (\n    const interrupt_pin::settings &amp; p_lhs,\n    const interrupt_pin::settings &amp; p_rhs\n) \n</code></pre>"},{"location":"api/namespacehal/#function-operator_7","title":"function operator==","text":"<pre><code>constexpr auto hal::operator== (\n    const output_pin::settings &amp; p_lhs,\n    const output_pin::settings &amp; p_rhs\n) \n</code></pre>"},{"location":"api/namespacehal/#function-operator_8","title":"function operator==","text":"<pre><code>constexpr auto hal::operator== (\n    const serial::settings &amp; p_lhs,\n    const serial::settings &amp; p_rhs\n) \n</code></pre>"},{"location":"api/namespacehal/#function-operator_9","title":"function operator==","text":"<pre><code>constexpr auto hal::operator== (\n    const spi::settings &amp; p_lhs,\n    const spi::settings &amp; p_rhs\n) \n</code></pre>"},{"location":"api/namespacehal/#function-print","title":"function print","text":"<p>Write data to serial buffer and drop return value. <pre><code>template&lt;typename DataArray typename DataArray&gt;\nvoid hal::print (\n    serial &amp; p_serial,\n    DataArray &amp;&amp; p_data\n) \n</code></pre></p> <p>Only use this with serial ports with infallible write operations, meaning they will never return an error result.</p> <p>Template parameters:</p> <ul> <li><code>DataArray</code> - data array type </li> </ul> <p>Parameters:</p> <ul> <li><code>p_serial</code> - serial port to write data to </li> <li><code>p_data</code> - data to be sent over the serial port </li> </ul>"},{"location":"api/namespacehal/#function-print_1","title":"function print","text":"<p>Write formatted string data to serial buffer and drop return value. <pre><code>template&lt;size_t BufferSize, typename... Parameters&gt;\nvoid hal::print (\n    serial &amp; p_serial,\n    const char * p_format,\n    Parameters... p_parameters\n) \n</code></pre></p> <p>Uses snprintf internally and writes to a local statically allocated an array. This function will never dynamically allocate like how standard std::printf does.</p> <p>This function does NOT include the NULL character when transmitting the data over the serial port.</p> <p>Template parameters:</p> <ul> <li><code>BufferSize</code> - Size of the buffer to allocate on the stack to store the formatted message. </li> <li><code>Parameters</code> - printf arguments </li> </ul> <p>Parameters:</p> <ul> <li><code>p_serial</code> - serial port to write data to </li> <li><code>p_format</code> - printf style null terminated format string </li> <li><code>p_parameters</code> - printf arguments </li> </ul>"},{"location":"api/namespacehal/#function-probe","title":"function probe","text":"<p>probe the i2c bus to see if a device exists <pre><code>inline hal::result&lt; hal::i2c::transaction_t &gt; hal::probe (\n    i2c &amp; p_i2c,\n    hal::byte p_address\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_i2c</code> - i2c driver </li> <li><code>p_address</code> - target address to probe for </li> </ul> <p>Returns:</p> <p>hal::result&lt;hal::i2c::transaction_t&gt; - success or failure </p>"},{"location":"api/namespacehal/#function-read","title":"function read","text":"<p>read bytes from target device on i2c bus <pre><code>inline hal::result&lt; hal::i2c::transaction_t &gt; hal::read (\n    i2c &amp; p_i2c,\n    hal::byte p_address,\n    std::span&lt; hal::byte &gt; p_data_in,\n    timeout auto p_timeout\n) \n</code></pre></p> <p>Shorthand for writing i2c.transfer(...) for read only operations</p> <p>Parameters:</p> <ul> <li><code>p_i2c</code> - i2c driver </li> <li><code>p_address</code> - target address </li> <li><code>p_data_in</code> - buffer to read bytes into from target device </li> <li><code>p_timeout</code> - amount of time to execute the transaction </li> </ul> <p>Returns:</p> <p>hal::result&lt;hal::i2c::transaction_t&gt; - success or failure </p>"},{"location":"api/namespacehal/#function-read_1","title":"function read","text":"<p>read bytes from target device on i2c bus <pre><code>inline hal::result&lt; hal::i2c::transaction_t &gt; hal::read (\n    i2c &amp; p_i2c,\n    hal::byte p_address,\n    std::span&lt; hal::byte &gt; p_data_in\n) \n</code></pre></p> <p>Shorthand for writing i2c.transfer(...) for read only operations, but never times out. Can be used for devices that never perform clock stretching.</p> <p>Parameters:</p> <ul> <li><code>p_i2c</code> - i2c driver </li> <li><code>p_address</code> - target address </li> <li><code>p_data_in</code> - buffer to read bytes into from target device </li> </ul> <p>Returns:</p> <p>hal::result&lt;hal::i2c::transaction_t&gt; - success or failure </p>"},{"location":"api/namespacehal/#function-read_2","title":"function read","text":"<p>return array of read bytes from target device on i2c bus <pre><code>template&lt;size_t BytesToRead&gt;\nresult&lt; std::array&lt; hal::byte , BytesToRead &gt; &gt; hal::read (\n    i2c &amp; p_i2c,\n    hal::byte p_address,\n    timeout auto p_timeout\n) \n</code></pre></p> <p>Eliminates the need to create a buffer and pass it into the read function.</p> <p>Template parameters:</p> <ul> <li><code>BytesToRead</code> - number of bytes to read </li> </ul> <p>Parameters:</p> <ul> <li><code>p_i2c</code> - i2c driver </li> <li><code>p_address</code> - target address </li> <li><code>p_timeout</code> - amount of time to execute the transaction </li> </ul> <p>Returns:</p> <p>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; - array of bytes from target device or an error. </p>"},{"location":"api/namespacehal/#function-read_3","title":"function read","text":"<p>return array of read bytes from target device on i2c bus <pre><code>template&lt;size_t BytesToRead&gt;\nresult&lt; std::array&lt; hal::byte , BytesToRead &gt; &gt; hal::read (\n    i2c &amp; p_i2c,\n    hal::byte p_address\n) \n</code></pre></p> <p>Eliminates the need to create a buffer and pass it into the read function. This operation will never time out and should only be used with devices that never perform clock stretching.</p> <p>Template parameters:</p> <ul> <li><code>BytesToRead</code> - number of bytes to read </li> </ul> <p>Parameters:</p> <ul> <li><code>p_i2c</code> - i2c driver </li> <li><code>p_address</code> - target address </li> </ul> <p>Returns:</p> <p>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; - array of bytes from target device or an error. </p>"},{"location":"api/namespacehal/#function-read_4","title":"function read","text":"<p>Read bytes from a serial port. <pre><code>inline result&lt; std::span&lt; hal::byte &gt; &gt; hal::read (\n    serial &amp; p_serial,\n    std::span&lt; hal::byte &gt; p_data_in,\n    timeout auto p_timeout\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_serial</code> - the serial port that will be read from </li> <li><code>p_data_in</code> - buffer to have bytes from the serial port read into </li> <li><code>p_timeout</code> - timeout callable that indicates when to bail out of the read operation. </li> </ul> <p>Returns:</p> <p>result&lt;std::span&lt;hal::byte&gt;&gt; - return an error if a call to serial::read or delay() returns an error from the serial port or a span with the number of bytes read and a pointer to where the read bytes are. </p>"},{"location":"api/namespacehal/#function-read_5","title":"function read","text":"<p>Read bytes from a serial port and return an array. <pre><code>template&lt;size_t BytesToRead&gt;\nresult&lt; std::array&lt; hal::byte , BytesToRead &gt; &gt; hal::read (\n    serial &amp; p_serial,\n    timeout auto p_timeout\n) \n</code></pre></p> <p>This call eliminates the boiler plate of creating an array and then passing that to the read function.</p> <p>Template parameters:</p> <ul> <li><code>BytesToRead</code> - the number of bytes to be read from the serial port. </li> </ul> <p>Parameters:</p> <ul> <li><code>p_serial</code> - the serial port to be read from </li> <li><code>p_timeout</code> - timeout callable that indicates when to bail out of the read operation. </li> </ul> <p>Returns:</p> <p>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; - return an error if a call to serial::read or delay() returns an error from the serial port or a span with the number of bytes read and a pointer to where the read bytes are. </p>"},{"location":"api/namespacehal/#function-read_6","title":"function read","text":"<p>Read data from the SPI bus. <pre><code>inline result&lt; hal::spi::transfer_t &gt; hal::read (\n    spi &amp; p_spi,\n    std::span&lt; hal::byte &gt; p_data_in,\n    hal::byte p_filler=spi::default_filler\n) \n</code></pre></p> <p>Filler bytes will be placed on the write line.</p> <p>Parameters:</p> <ul> <li><code>p_spi</code> - spi driver </li> <li><code>p_data_in</code> - buffer to receive bytes back from the SPI bus </li> <li><code>p_filler</code> - filler data placed on the bus in place of actual write data. </li> </ul> <p>Returns:</p> <p>result&lt;hal::spi::transfer_t&gt; - success or failure </p>"},{"location":"api/namespacehal/#function-read_7","title":"function read","text":"<p>Read data from the SPI bus and return a std::array of bytes. <pre><code>template&lt;size_t BytesToRead&gt;\nresult&lt; std::array&lt; hal::byte , BytesToRead &gt; &gt; hal::read (\n    spi &amp; p_spi,\n    hal::byte p_filler=spi::default_filler\n) \n</code></pre></p> <p>Filler bytes will be placed on the write line.</p> <p>Template parameters:</p> <ul> <li><code>BytesToRead</code> - Number of bytes to read </li> </ul> <p>Parameters:</p> <ul> <li><code>p_spi</code> - spi driver </li> <li><code>p_filler</code> - filler data placed on the bus in place of actual write data. </li> </ul> <p>Returns:</p> <p>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; - any errors associated with this call </p>"},{"location":"api/namespacehal/#function-rounding_division","title":"function rounding_division","text":"<p>Perform integer division and round the value up if the next decimal place is greater than or equal to 0.5. <pre><code>template&lt;typename T typename T&gt;\nconstexpr T hal::rounding_division (\n    T p_numerator,\n    T p_denominator\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> - integral type of the two operands </li> </ul> <p>Parameters:</p> <ul> <li><code>p_numerator</code> - the value to be divided </li> <li><code>p_denominator</code> - the value to divide the numerator against </li> </ul> <p>Returns:</p> <p>constexpr T - rounded quotient between numerator and denominator. Returns 0 if the denominator is greater than the numerator. </p>"},{"location":"api/namespacehal/#function-success","title":"function success","text":"<p>a readability function for returning successful results; <pre><code>inline status hal::success () \n</code></pre></p> <p>For functions that return <code>status</code>, rather than returning <code>{}</code> to default initialize the status object as \"success\", use this function to make it more clear to the reader.</p> <p>EXAMPLE:  </p> <p>Returns:</p> <p>status - that is always successful </p>"},{"location":"api/namespacehal/#function-terminated","title":"function terminated","text":"<pre><code>constexpr bool hal::terminated (\n    work_state p_state\n) \n</code></pre>"},{"location":"api/namespacehal/#function-terminated_1","title":"function terminated","text":"<pre><code>constexpr bool hal::terminated (\n    has_work_state auto p_worker\n) \n</code></pre>"},{"location":"api/namespacehal/#function-timeout_generator","title":"function timeout_generator","text":"<p>Generates a function that, when passed a duration, returns a timeout. <pre><code>inline auto hal::timeout_generator (\n    hal::steady_clock &amp; p_steady_clock\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_steady_clock</code> - steady_clock driver that must out live the lifetime of the returned lambda. </li> </ul> <p>Returns:</p> <p>auto - a callable that returns a new timeout object each time a time duration is passed to it. </p>"},{"location":"api/namespacehal/#function-to_8_bit_address","title":"function to_8_bit_address","text":"<p>Convert 7-bit i2c address to an 8-bit address. <pre><code>inline hal::byte hal::to_8_bit_address (\n    hal::byte p_address,\n    i2c_operation p_operation\n) noexcept\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_address</code> 7-bit i2c address </li> <li><code>p_operation</code> write or read operation </li> </ul> <p>Returns:</p> <p>hal::byte - 8-bit i2c address </p>"},{"location":"api/namespacehal/#function-to_array","title":"function to_array","text":"<p>Convert a string_view into a std::array of N number of characters. <pre><code>template&lt;size_t N&gt;\nconstexpr std::array&lt; char, N+1 &gt; hal::to_array (\n    std::string_view p_view\n) \n</code></pre></p> <p>Will always ensure that the array is null terminated</p> <p>Template parameters:</p> <ul> <li><code>N</code> - Size of the array </li> </ul> <p>Parameters:</p> <ul> <li><code>p_view</code> - string to be placed into a char array </li> </ul> <p>Returns:</p> <p>constexpr std::array&lt;char, N + 1&gt; - the char array object </p>"},{"location":"api/namespacehal/#function-to_string","title":"function to_string","text":"<pre><code>constexpr std::string_view hal::to_string (\n    work_state p_state\n) \n</code></pre>"},{"location":"api/namespacehal/#function-try_until","title":"function try_until","text":"<p>Repeatedly call a worker function until it has reached a terminal state or a timeout has been reached. <pre><code>inline result&lt; work_state &gt; hal::try_until (\n    worker auto &amp; p_worker,\n    timeout auto p_timeout\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_worker</code> - worker function to repeatedly call </li> <li><code>p_timeout</code> - callable timeout object </li> </ul> <p>Returns:</p> <p>result&lt;work_state&gt; - state of the worker function </p>"},{"location":"api/namespacehal/#function-try_until_1","title":"function try_until","text":"<p>Repeatedly call a worker function until it has reached a terminal state or a timeout has been reached. <pre><code>inline result&lt; work_state &gt; hal::try_until (\n    worker auto &amp;&amp; p_worker,\n    timeout auto p_timeout\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_worker</code> - worker function to repeatedly call </li> <li><code>p_timeout</code> - callable timeout object </li> </ul> <p>Returns:</p> <p>result&lt;work_state&gt; - state of the worker function </p>"},{"location":"api/namespacehal/#function-value","title":"function value","text":"<p>Helper function to convert an enum to its integral value. <pre><code>constexpr auto hal::value (\n    enumeration auto p_enum_value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_enum_value</code> - the enumeration you want to convert into an integral value </li> </ul> <p>Returns:</p> <p>constexpr auto - return the integral value of the enum with the same type as the enumeration. </p>"},{"location":"api/namespacehal/#function-wavelength","title":"function wavelength","text":"<p>Calculates and returns the wavelength in seconds. <pre><code>template&lt;typename Period typename Period&gt;\nconstexpr std::chrono::duration&lt; int64_t, Period &gt; hal::wavelength (\n    hertz p_source\n) \n</code></pre></p> <p>Calculates and returns the wavelength in seconds as a float.</p> <p>Template parameters:</p> <ul> <li><code>Period</code> - desired period (defaults to std::femto for femtoseconds). </li> </ul> <p>Parameters:</p> <ul> <li><code>p_source</code> - source frequency to convert to wavelength </li> </ul> <p>Returns:</p> <p>std::chrono::duration&lt;int64_t, Period&gt; - time based wavelength of the frequency.</p> <p>Template parameters:</p> <ul> <li><code>float_t</code> - float type </li> <li><code>Period</code> - desired period </li> </ul> <p>Parameters:</p> <ul> <li><code>p_source</code> - source frequency to convert to wavelength </li> </ul> <p>Returns:</p> <p>constexpr float - float representation of the time based wavelength of the frequency. </p>"},{"location":"api/namespacehal/#function-write","title":"function write","text":"<p>write data to a target device on the i2c bus <pre><code>inline hal::result&lt; hal::i2c::transaction_t &gt; hal::write (\n    i2c &amp; p_i2c,\n    hal::byte p_address,\n    std::span&lt; const hal::byte &gt; p_data_out,\n    timeout auto p_timeout\n) \n</code></pre></p> <p>Shorthand for writing i2c.transfer(...) for write only operations</p> <p>Parameters:</p> <ul> <li><code>p_i2c</code> - i2c driver </li> <li><code>p_address</code> - target address </li> <li><code>p_data_out</code> - buffer of bytes to write to the target device </li> <li><code>p_timeout</code> - amount of time to execute the transaction </li> </ul> <p>Returns:</p> <p>hal::result&lt;hal::i2c::transaction_t&gt; - success or failure </p>"},{"location":"api/namespacehal/#function-write_1","title":"function write","text":"<p>write data to a target device on the i2c bus <pre><code>inline hal::result&lt; hal::i2c::transaction_t &gt; hal::write (\n    i2c &amp; p_i2c,\n    hal::byte p_address,\n    std::span&lt; const hal::byte &gt; p_data_out\n) \n</code></pre></p> <p>Shorthand for writing i2c.transfer(...) for write only operations, but never times out. Can be used for devices that never perform clock stretching.</p> <p>Parameters:</p> <ul> <li><code>p_i2c</code> - i2c driver </li> <li><code>p_address</code> - target address </li> <li><code>p_data_out</code> - buffer of bytes to write to the target device </li> </ul> <p>Returns:</p> <p>hal::result&lt;hal::i2c::transaction_t&gt; - success or failure </p>"},{"location":"api/namespacehal/#function-write_2","title":"function write","text":"<p>Write bytes to a serial port. <pre><code>inline status hal::write (\n    serial &amp; p_serial,\n    std::span&lt; const hal::byte &gt; p_data_out\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_serial</code> - the serial port that will be written to </li> <li><code>p_data_out</code> - the data to be written out the port </li> </ul> <p>Returns:</p> <p>status - success or failure </p>"},{"location":"api/namespacehal/#function-write_3","title":"function write","text":"<p>Write std::span of const char to a serial port. <pre><code>inline status hal::write (\n    serial &amp; p_serial,\n    std::string_view p_data_out\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_serial</code> - the serial port that will be written to </li> <li><code>p_data_out</code> - chars to be written out the port </li> </ul> <p>Returns:</p> <p>status - success or failure </p>"},{"location":"api/namespacehal/#function-write_4","title":"function write","text":"<p>Write data to the SPI bus and ignore data sent from peripherals on the bus. <pre><code>inline result&lt; hal::spi::transfer_t &gt; hal::write (\n    spi &amp; p_spi,\n    std::span&lt; const hal::byte &gt; p_data_out\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_spi</code> - spi driver </li> <li><code>p_data_out</code> - data to be written to the SPI bus </li> </ul> <p>Returns:</p> <p>result&lt;hal::spi::transfer_t&gt; - success or failure </p>"},{"location":"api/namespacehal/#function-write_partial","title":"function write_partial","text":"<p>Write bytes to a serial port. <pre><code>inline result&lt; serial::write_t &gt; hal::write_partial (\n    serial &amp; p_serial,\n    std::span&lt; const hal::byte &gt; p_data_out\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_serial</code> - the serial port that will be written to </li> <li><code>p_data_out</code> - the data to be written out the port </li> </ul> <p>Returns:</p> <p>result&lt;serial::write_t&gt; - get the results of the uart port write operation. </p>"},{"location":"api/namespacehal/#function-write_then_read","title":"function write_then_read","text":"<p>write and then read bytes from target device on i2c bus <pre><code>inline hal::result&lt; hal::i2c::transaction_t &gt; hal::write_then_read (\n    i2c &amp; p_i2c,\n    hal::byte p_address,\n    std::span&lt; const hal::byte &gt; p_data_out,\n    std::span&lt; hal::byte &gt; p_data_in,\n    timeout auto p_timeout=hal::never_timeout ()\n) \n</code></pre></p> <p>This API simply calls transaction. This API is here for consistency across the other other communication protocols such as SPI and serial.</p> <p>Parameters:</p> <ul> <li><code>p_i2c</code> - i2c driver </li> <li><code>p_address</code> - target address </li> <li><code>p_data_out</code> - buffer of bytes to write to the target device </li> <li><code>p_data_in</code> - buffer to read bytes into from target device </li> <li><code>p_timeout</code> - amount of time to execute the transaction</li> </ul> <p>Returns:</p> <p>hal::result&lt;hal::i2c::transaction_t&gt; - success or failure </p>"},{"location":"api/namespacehal/#function-write_then_read_1","title":"function write_then_read","text":"<p>write and then read bytes from target device on i2c bus <pre><code>inline hal::result&lt; hal::i2c::transaction_t &gt; hal::write_then_read (\n    i2c &amp; p_i2c,\n    hal::byte p_address,\n    std::span&lt; const hal::byte &gt; p_data_out,\n    std::span&lt; hal::byte &gt; p_data_in\n) \n</code></pre></p> <p>This API simply calls transaction. This API is here for consistency across the other other communication protocols such as SPI and serial.</p> <p>This operation will never time out and should only be used with devices that never perform clock stretching.</p> <p>Parameters:</p> <ul> <li><code>p_i2c</code> - i2c driver </li> <li><code>p_address</code> - target address </li> <li><code>p_data_out</code> - buffer of bytes to write to the target device </li> <li><code>p_data_in</code> - buffer to read bytes into from target device</li> </ul> <p>Returns:</p> <p>hal::result&lt;hal::i2c::transaction_t&gt; - success or failure </p>"},{"location":"api/namespacehal/#function-write_then_read_2","title":"function write_then_read","text":"<p>write and then return an array of read bytes from target device on i2c bus <pre><code>template&lt;size_t BytesToRead&gt;\nresult&lt; std::array&lt; hal::byte , BytesToRead &gt; &gt; hal::write_then_read (\n    i2c &amp; p_i2c,\n    hal::byte p_address,\n    std::span&lt; const hal::byte &gt; p_data_out,\n    timeout auto p_timeout\n) \n</code></pre></p> <p>Eliminates the need to create a buffer and pass it into the read function.</p> <p>Template parameters:</p> <ul> <li><code>BytesToRead</code> - number of bytes to read after write </li> </ul> <p>Parameters:</p> <ul> <li><code>p_i2c</code> - i2c driver </li> <li><code>p_address</code> - target address </li> <li><code>p_data_out</code> - buffer of bytes to write to the target device </li> <li><code>p_timeout</code> - amount of time to execute the transaction </li> </ul> <p>Returns:</p> <p>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; </p>"},{"location":"api/namespacehal/#function-write_then_read_3","title":"function write_then_read","text":"<p>write and then return an array of read bytes from target device on i2c bus <pre><code>template&lt;size_t BytesToRead&gt;\nresult&lt; std::array&lt; hal::byte , BytesToRead &gt; &gt; hal::write_then_read (\n    i2c &amp; p_i2c,\n    hal::byte p_address,\n    std::span&lt; const hal::byte &gt; p_data_out\n) \n</code></pre></p> <p>Eliminates the need to create a buffer and pass it into the read function.</p> <p>Template parameters:</p> <ul> <li><code>BytesToRead</code> - number of bytes to read after write </li> </ul> <p>Parameters:</p> <ul> <li><code>p_i2c</code> - i2c driver </li> <li><code>p_address</code> - target address </li> <li><code>p_data_out</code> - buffer of bytes to write to the target device </li> </ul> <p>Returns:</p> <p>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; </p>"},{"location":"api/namespacehal/#function-write_then_read_4","title":"function write_then_read","text":"<p>Perform a write then read transaction over serial. <pre><code>inline result&lt; std::span&lt; hal::byte &gt; &gt; hal::write_then_read (\n    serial &amp; p_serial,\n    std::span&lt; const hal::byte &gt; p_data_out,\n    std::span&lt; hal::byte &gt; p_data_in,\n    timeout auto p_timeout\n) \n</code></pre></p> <p>This is especially useful for devices that use a command and response method of communication.</p> <p>Parameters:</p> <ul> <li><code>p_serial</code> - the serial port to have the transaction occur on </li> <li><code>p_data_out</code> - the data to be written to the port </li> <li><code>p_data_in</code> - a buffer to receive the bytes back from the port </li> <li><code>p_timeout</code> - timeout callable that indicates when to bail out of the read operation. </li> </ul> <p>Returns:</p> <p>status - success or failure or serial::write() returns an error from the serial port or success. </p>"},{"location":"api/namespacehal/#function-write_then_read_5","title":"function write_then_read","text":"<p>Perform a write then read transaction over serial. <pre><code>template&lt;size_t BytesToRead&gt;\nresult&lt; std::array&lt; hal::byte , BytesToRead &gt; &gt; hal::write_then_read (\n    serial &amp; p_serial,\n    std::span&lt; const hal::byte &gt; p_data_out,\n    timeout auto p_timeout\n) \n</code></pre></p> <p>This is especially useful for devices that use a command and response method of communication.</p> <p>Template parameters:</p> <ul> <li><code>BytesToRead</code> - the number of bytes to read back </li> </ul> <p>Parameters:</p> <ul> <li><code>p_serial</code> - the serial port to have the transaction occur on </li> <li><code>p_data_out</code> - the data to be written to the port </li> <li><code>p_timeout</code> - timeout callable that indicates when to bail out of the read operation. </li> </ul> <p>Returns:</p> <p>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; - return an error if a call to serial::read or serial::write() returns an error from the serial port or an array of read bytes. </p>"},{"location":"api/namespacehal/#function-write_then_read_6","title":"function write_then_read","text":"<p>Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI and fill the write line with filler bytes. <pre><code>inline result&lt; hal::spi::transfer_t &gt; hal::write_then_read (\n    spi &amp; p_spi,\n    std::span&lt; const hal::byte &gt; p_data_out,\n    std::span&lt; hal::byte &gt; p_data_in,\n    hal::byte p_filler=spi::default_filler\n) \n</code></pre></p> <p>This utility function that fits the use case of many SPI devices where a transaction is not full duplex. In many spi devices, full duplex means that as data is being written to the SPI bus, the peripheral device is sending data back on the read line. In most cases, the protocol is to write data to the bus, and ignore the read line because the peripheral is not writing anything meaningful to that line, then reading from SPI bus and writing nothing meaningful to the write line as the peripheral is ignoring that line.</p> <p>Parameters:</p> <ul> <li><code>p_spi</code> - spi driver </li> <li><code>p_data_out</code> - bytes to write to the bus </li> <li><code>p_data_in</code> - buffer to receive bytes back from the SPI bus </li> <li><code>p_filler</code> - filler data placed on the bus when the read operation begins. </li> </ul> <p>Returns:</p> <p>result&lt;hal::spi::transfer_t&gt; - success or failure </p>"},{"location":"api/namespacehal/#function-write_then_read_7","title":"function write_then_read","text":"<p>Write data to the SPI bus and ignore data sent from peripherals on the bus then read data from the SPI, fill the write line with filler bytes and return an array of bytes. <pre><code>template&lt;size_t BytesToRead&gt;\nresult&lt; std::array&lt; hal::byte , BytesToRead &gt; &gt; hal::write_then_read (\n    spi &amp; p_spi,\n    std::span&lt; const hal::byte &gt; p_data_out,\n    hal::byte p_filler=spi::default_filler\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>BytesToRead</code> - Number of bytes to read from the bus </li> </ul> <p>Parameters:</p> <ul> <li><code>p_spi</code> - spi driver </li> <li><code>p_data_out</code> - bytes to write to the bus </li> <li><code>p_filler</code> - filler data placed on the bus when the read operation begins. </li> </ul> <p>Returns:</p> <p>result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; </p>"},{"location":"api/namespacehal/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/namespacehal/#function-equals","title":"function equals","text":"<p>Determines if two values are equal within a relative error. <pre><code>static constexpr static bool hal::equals (\n    std::floating_point auto p_value1,\n    std::floating_point auto p_value2,\n    float p_epsilon=1e-9f\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_value1</code> - First value to compare. </li> <li><code>p_value2</code> - Second value to compare. </li> <li><code>p_epsilon</code> - Error margin that the difference is compared to. </li> </ul> <p>Returns:</p> <p>true - difference is less than epsilon </p> <p>Returns:</p> <p>false - difference is more than epsilon </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/accelerometer.hpp</code></p>"},{"location":"api/classhal_1_1accelerometer/","title":"Class hal::accelerometer","text":"<p>ClassList &gt; hal &gt; accelerometer</p> <p>Acceleration sensing hardware abstraction interface. </p> <ul> <li><code>#include &lt;accelerometer.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::soft::inert_accelerometer</p>"},{"location":"api/classhal_1_1accelerometer/#classes","title":"Classes","text":"Type Name struct read_t Result from reading the accelerometer."},{"location":"api/classhal_1_1accelerometer/#public-functions","title":"Public Functions","text":"Type Name result&lt; read_t &gt; read () Read the latest acceleration sensed by the device. virtual ~accelerometer () = default"},{"location":"api/classhal_1_1accelerometer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1accelerometer/#function-read","title":"function read","text":"<p>Read the latest acceleration sensed by the device. <pre><code>inline result&lt; read_t &gt; hal::accelerometer::read () \n</code></pre></p> <p>Returns:</p> <p>result&lt;read_t&gt; - acceleration data </p>"},{"location":"api/classhal_1_1accelerometer/#function-accelerometer","title":"function ~accelerometer","text":"<pre><code>virtual hal::accelerometer::~accelerometer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/accelerometer.hpp</code></p>"},{"location":"api/structhal_1_1accelerometer_1_1read__t/","title":"Struct hal::accelerometer::read_t","text":"<p>ClassList &gt; hal &gt; accelerometer &gt; read_t</p> <p>Result from reading the accelerometer. </p> <ul> <li><code>#include &lt;accelerometer.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1accelerometer_1_1read__t/#public-attributes","title":"Public Attributes","text":"Type Name g_force x Acceleration in the X axis, relative to the device's reference frame. g_force y Acceleration in the Y axis, relative to the device's reference frame. g_force z Acceleration in the Z axis, relative to the device's reference frame."},{"location":"api/structhal_1_1accelerometer_1_1read__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1accelerometer_1_1read__t/#variable-x","title":"variable x","text":"<pre><code>g_force hal::accelerometer::read_t::x;\n</code></pre>"},{"location":"api/structhal_1_1accelerometer_1_1read__t/#variable-y","title":"variable y","text":"<pre><code>g_force hal::accelerometer::read_t::y;\n</code></pre>"},{"location":"api/structhal_1_1accelerometer_1_1read__t/#variable-z","title":"variable z","text":"<pre><code>g_force hal::accelerometer::read_t::z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/accelerometer.hpp</code></p>"},{"location":"api/classhal_1_1adc/","title":"Class hal::adc","text":"<p>ClassList &gt; hal &gt; adc</p> <p>Analog to Digital Converter (ADC) hardware abstraction interface. More...</p> <ul> <li><code>#include &lt;adc.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::lpc40::adc,  hal::mock::adc,  hal::soft::adc_mux_pin,  hal::soft::inert_adc</p>"},{"location":"api/classhal_1_1adc/#classes","title":"Classes","text":"Type Name struct read_t Result from reading the adc."},{"location":"api/classhal_1_1adc/#public-functions","title":"Public Functions","text":"Type Name result&lt; read_t &gt; read () Sample the analog to digital converter and return the result. virtual ~adc () = default"},{"location":"api/classhal_1_1adc/#detailed-description","title":"Detailed Description","text":"<p>Use this interface for devices and peripherals that can convert analog voltage signals into a digital number.</p> <p>ADC peripheral only know the proportion of a voltage signal relative to a Vss (negative reference) and a Vcc (positive reference) and thus cannot describe the voltage directly. </p>"},{"location":"api/classhal_1_1adc/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1adc/#function-read","title":"function read","text":"<p>Sample the analog to digital converter and return the result. <pre><code>inline result&lt; read_t &gt; hal::adc::read () \n</code></pre></p> <p>Returns:</p> <p>result&lt;read_t&gt; - the sampled adc value </p>"},{"location":"api/classhal_1_1adc/#function-adc","title":"function ~adc","text":"<pre><code>virtual hal::adc::~adc () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/adc.hpp</code></p>"},{"location":"api/structhal_1_1adc_1_1read__t/","title":"Struct hal::adc::read_t","text":"<p>ClassList &gt; hal &gt; adc &gt; read_t</p> <p>Result from reading the adc. </p> <ul> <li><code>#include &lt;adc.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1adc_1_1read__t/#public-attributes","title":"Public Attributes","text":"Type Name float sample Sample value of the adc."},{"location":"api/structhal_1_1adc_1_1read__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1adc_1_1read__t/#variable-sample","title":"variable sample","text":"<p>Sample value of the adc. <pre><code>float hal::adc::read_t::sample;\n</code></pre></p> <p>Is guaranteed by the implementing driver to be between 0.0f and +1.0f. The value representing the voltage measured by the ADC from Vss (negative reference) to Vcc (positive reference). For example, if Vss is 0V (gnd) and Vcc is 5V and this value is 0.5f, then the voltage measured is 2.5V. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/adc.hpp</code></p>"},{"location":"api/structhal_1_1bit__limits/","title":"Struct hal::bit_limits","text":"<p>template &lt;size_t BitWidth, std::integral int_t&gt;</p> <p>ClassList &gt; hal &gt; bit_limits</p> <p>Similar to std::numeric_limits&lt;T&gt; except that this object can give properties of integral types of arbitrary bit widths. More...</p> <ul> <li><code>#include &lt;bit_limits.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1bit__limits/#public-static-functions","title":"Public Static Functions","text":"Type Name constexpr int_t max () Get the maximum value available for an integer of <code>BitWidth</code> size and that can be stored within<code>int_t</code> . constexpr int_t min () Get the minimum value available for an integer of <code>BitWidth</code> size and that can be stored within<code>int_t</code> ."},{"location":"api/structhal_1_1bit__limits/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>BitWidth</code> - bit width of the value </li> <li><code>int_t</code> - the containing type. Will generate a compile error if the containing type's bit width is smaller than the BitWidth value. </li> </ul>"},{"location":"api/structhal_1_1bit__limits/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structhal_1_1bit__limits/#function-max","title":"function max","text":"<p>Get the maximum value available for an integer of <code>BitWidth</code> size and that can be stored within<code>int_t</code> . <pre><code>static inline constexpr int_t hal::bit_limits::max () \n</code></pre></p> <p>The final value of the function depends also on the sign of the int type.</p> <p>Returns:</p> <p>constexpr int_t maximum value </p>"},{"location":"api/structhal_1_1bit__limits/#function-min","title":"function min","text":"<p>Get the minimum value available for an integer of <code>BitWidth</code> size and that can be stored within<code>int_t</code> . <pre><code>static inline constexpr int_t hal::bit_limits::min () \n</code></pre></p> <p>The final value of the function depends also on the sign of the int type. Unsigned ints simply return zero.</p> <p>Returns:</p> <p>constexpr int_t minimum value </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/bit_limits.hpp</code></p>"},{"location":"api/structhal_1_1bit__mask/","title":"Struct hal::bit_mask","text":"<p>ClassList &gt; hal &gt; bit_mask</p> <p>Represents a bit mask of contiguous bits. </p> <ul> <li><code>#include &lt;bit.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1bit__mask/#public-attributes","title":"Public Attributes","text":"Type Name std::uint32_t position Where the bit mask starts. std::uint32_t width The number of bits after position contained in the mask."},{"location":"api/structhal_1_1bit__mask/#public-functions","title":"Public Functions","text":"Type Name constexpr bool operator== (const bit_mask &amp; other) Comparison operator between this mask and another. constexpr auto origin () constConvert bit_mask to a integral representation but with bit position at 0. constexpr auto value () constConvert mask to a integral representation."},{"location":"api/structhal_1_1bit__mask/#public-static-functions","title":"Public Static Functions","text":"Type Name consteval bit_mask from () Generate, at compile time, a bit_mask that spans the from position1 to position2. constexpr bit_mask from () Generate, at compile time, a single bit width bit_mask at position. consteval bit_mask from (std::uint32_t position1, std::uint32_t position2) Generate, at compile time, a bit_mask that spans the from position1 to position2. constexpr bit_mask from (std::uint32_t position) Generate, at runtime, a single bit width bit_mask at position."},{"location":"api/structhal_1_1bit__mask/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1bit__mask/#variable-position","title":"variable position","text":"<pre><code>std::uint32_t hal::bit_mask::position;\n</code></pre>"},{"location":"api/structhal_1_1bit__mask/#variable-width","title":"variable width","text":"<pre><code>std::uint32_t hal::bit_mask::width;\n</code></pre>"},{"location":"api/structhal_1_1bit__mask/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1bit__mask/#function-operator","title":"function operator==","text":"<p>Comparison operator between this mask and another. <pre><code>inline constexpr bool hal::bit_mask::operator== (\n    const bit_mask &amp; other\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>other</code> - the other mask to compare against </li> </ul> <p>Returns:</p> <p>true - the masks are the same </p> <p>Returns:</p> <p>false - the masks are not the same </p>"},{"location":"api/structhal_1_1bit__mask/#function-origin","title":"function origin","text":"<p>Convert bit_mask to a integral representation but with bit position at 0. <pre><code>template&lt;std::unsigned_integral T&gt;\ninline constexpr auto hal::bit_mask::origin () const\n</code></pre></p> <p>The integral presentation will have 1 bits starting from the position bit up to bit position + width. All other bits will be 0s.</p> <p>For example:  </p> <p>Template parameters:</p> <ul> <li><code>T</code> - unsigned integral type to hold the bit_mask </li> </ul> <p>Returns:</p> <p>constexpr auto - bit_mask value as an unsigned integer </p>"},{"location":"api/structhal_1_1bit__mask/#function-value","title":"function value","text":"<p>Convert mask to a integral representation. <pre><code>template&lt;std::unsigned_integral T&gt;\ninline constexpr auto hal::bit_mask::value () const\n</code></pre></p> <p>The integral presentation will have 1 bits starting from the position bit up to bit position + width. All other bits will be 0s.</p> <p>For example:  </p> <p>Template parameters:</p> <ul> <li><code>T</code> - unsigned integral type to hold the mask </li> </ul> <p>Returns:</p> <p>constexpr auto - mask value as an unsigned integer </p>"},{"location":"api/structhal_1_1bit__mask/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/structhal_1_1bit__mask/#function-from-14","title":"function from [1/4]","text":"<p>Generate, at compile time, a bit_mask that spans the from position1 to position2. <pre><code>template&lt;std::uint32_t position1, std::uint32_t position2&gt;\nstatic inline consteval bit_mask hal::bit_mask::from () \n</code></pre></p> <p>If position1 is the same position2 then the bit_mask will have length of 1 and the bit position will be the value of position1.</p> <p>position1 and position2 can be in any order so long as they span the distance from the start and end of the bit_mask range.</p> <p>Template parameters:</p> <ul> <li><code>position1</code> - bit position 1 </li> <li><code>position2</code> - bit position 2 </li> </ul> <p>Returns:</p> <p>consteval bit_mask - bit bit_mask represented by the two bit positions </p>"},{"location":"api/structhal_1_1bit__mask/#function-from-24","title":"function from [2/4]","text":"<p>Generate, at compile time, a single bit width bit_mask at position. <pre><code>template&lt;std::uint32_t position&gt;\nstatic inline constexpr bit_mask hal::bit_mask::from () \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>position</code> - the bit to make the bit_mask for </li> </ul> <p>Returns:</p> <p>constexpr bit_mask - bit bit_mask with the position bit set to position </p>"},{"location":"api/structhal_1_1bit__mask/#function-from-34","title":"function from [3/4]","text":"<p>Generate, at compile time, a bit_mask that spans the from position1 to position2. <pre><code>static inline consteval bit_mask hal::bit_mask::from (\n    std::uint32_t position1,\n    std::uint32_t position2\n) \n</code></pre></p> <p>If position1 is the same position2 then the bit_mask will have length of 1 and the bit position will be the value of position1.</p> <p>position1 and position2 can be in any order so long as they span the distance from the start and end of the bit_mask range.</p> <p>Parameters:</p> <ul> <li><code>position1</code> - bit position 1 </li> <li><code>position2</code> - bit position 2 </li> </ul> <p>Returns:</p> <p>consteval bit_mask - bit bit_mask represented by the two bit positions </p>"},{"location":"api/structhal_1_1bit__mask/#function-from-44","title":"function from [4/4]","text":"<p>Generate, at runtime, a single bit width bit_mask at position. <pre><code>static inline constexpr bit_mask hal::bit_mask::from (\n    std::uint32_t position\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>position</code> - the bit to make the bit_mask for </li> </ul> <p>Returns:</p> <p>constexpr bit_mask - bit bit_mask with the position bit set to position </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/bit.hpp</code></p>"},{"location":"api/classhal_1_1bit__modify/","title":"Class hal::bit_modify","text":"<p>template &lt;std::unsigned_integral T&gt;</p> <p>ClassList &gt; hal &gt; bit_modify</p> <p>Inherits the following classes: hal::bit_value</p>"},{"location":"api/classhal_1_1bit__modify/#public-static-attributes-inherited-from-halbit_value","title":"Public Static Attributes inherited from hal::bit_value","text":"<p>See hal::bit_value</p> Type Name constexpr std::uint32_t width   = = sizeof(T) * 8"},{"location":"api/classhal_1_1bit__modify/#public-functions","title":"Public Functions","text":"Type Name constexpr bit_modify (volatile T &amp; p_register_reference)  ~bit_modify ()"},{"location":"api/classhal_1_1bit__modify/#public-functions-inherited-from-halbit_value","title":"Public Functions inherited from hal::bit_value","text":"<p>See hal::bit_value</p> Type Name constexpr bit_value (T p_initial_value=0)  constexpr auto &amp; clear ()  constexpr auto &amp; clear (bit_mask p_field)  constexpr T get ()  constexpr auto &amp; insert (std::unsigned_integral auto p_value)  constexpr auto &amp; insert (bit_mask p_field, std::unsigned_integral auto p_value)  constexpr auto &amp; set ()  constexpr auto &amp; set (bit_mask p_field)  constexpr auto to ()  constexpr auto &amp; toggle ()  constexpr auto &amp; toggle (bit_mask p_field)"},{"location":"api/classhal_1_1bit__modify/#protected-attributes-inherited-from-halbit_value","title":"Protected Attributes inherited from hal::bit_value","text":"<p>See hal::bit_value</p> Type Name T m_value"},{"location":"api/classhal_1_1bit__modify/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1bit__modify/#function-bit_modify","title":"function bit_modify","text":"<pre><code>inline constexpr hal::bit_modify::bit_modify (\n    volatile T &amp; p_register_reference\n) \n</code></pre>"},{"location":"api/classhal_1_1bit__modify/#function-bit_modify_1","title":"function ~bit_modify","text":"<pre><code>inline hal::bit_modify::~bit_modify () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/bit.hpp</code></p>"},{"location":"api/classhal_1_1bit__value/","title":"Class hal::bit_value","text":"<p>template &lt;std::unsigned_integral T&gt;</p> <p>ClassList &gt; hal &gt; bit_value</p> <p>Inherited by the following classes: hal::bit_modify</p>"},{"location":"api/classhal_1_1bit__value/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr std::uint32_t width   = = sizeof(T) * 8"},{"location":"api/classhal_1_1bit__value/#public-functions","title":"Public Functions","text":"Type Name constexpr bit_value (T p_initial_value=0)  constexpr auto &amp; clear ()  constexpr auto &amp; clear (bit_mask p_field)  constexpr T get ()  constexpr auto &amp; insert (std::unsigned_integral auto p_value)  constexpr auto &amp; insert (bit_mask p_field, std::unsigned_integral auto p_value)  constexpr auto &amp; set ()  constexpr auto &amp; set (bit_mask p_field)  constexpr auto to ()  constexpr auto &amp; toggle ()  constexpr auto &amp; toggle (bit_mask p_field)"},{"location":"api/classhal_1_1bit__value/#protected-attributes","title":"Protected Attributes","text":"Type Name T m_value"},{"location":"api/classhal_1_1bit__value/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/classhal_1_1bit__value/#variable-width","title":"variable width","text":"<pre><code>constexpr std::uint32_t hal::bit_value&lt; T &gt;::width;\n</code></pre>"},{"location":"api/classhal_1_1bit__value/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1bit__value/#function-bit_value","title":"function bit_value","text":"<pre><code>inline constexpr hal::bit_value::bit_value (\n    T p_initial_value=0\n) \n</code></pre>"},{"location":"api/classhal_1_1bit__value/#function-clear-12","title":"function clear [1/2]","text":"<pre><code>template&lt;bit_mask field&gt;\ninline constexpr auto &amp; hal::bit_value::clear () \n</code></pre>"},{"location":"api/classhal_1_1bit__value/#function-clear-22","title":"function clear [2/2]","text":"<pre><code>inline constexpr auto &amp; hal::bit_value::clear (\n    bit_mask p_field\n) \n</code></pre>"},{"location":"api/classhal_1_1bit__value/#function-get","title":"function get","text":"<pre><code>inline constexpr T hal::bit_value::get () \n</code></pre>"},{"location":"api/classhal_1_1bit__value/#function-insert-12","title":"function insert [1/2]","text":"<pre><code>template&lt;bit_mask field&gt;\ninline constexpr auto &amp; hal::bit_value::insert (\n    std::unsigned_integral auto p_value\n) \n</code></pre>"},{"location":"api/classhal_1_1bit__value/#function-insert-22","title":"function insert [2/2]","text":"<pre><code>inline constexpr auto &amp; hal::bit_value::insert (\n    bit_mask p_field,\n    std::unsigned_integral auto p_value\n) \n</code></pre>"},{"location":"api/classhal_1_1bit__value/#function-set-12","title":"function set [1/2]","text":"<pre><code>template&lt;bit_mask field&gt;\ninline constexpr auto &amp; hal::bit_value::set () \n</code></pre>"},{"location":"api/classhal_1_1bit__value/#function-set-22","title":"function set [2/2]","text":"<pre><code>inline constexpr auto &amp; hal::bit_value::set (\n    bit_mask p_field\n) \n</code></pre>"},{"location":"api/classhal_1_1bit__value/#function-to","title":"function to","text":"<pre><code>template&lt;std::integral U&gt;\ninline constexpr auto hal::bit_value::to () \n</code></pre>"},{"location":"api/classhal_1_1bit__value/#function-toggle-12","title":"function toggle [1/2]","text":"<pre><code>template&lt;bit_mask field&gt;\ninline constexpr auto &amp; hal::bit_value::toggle () \n</code></pre>"},{"location":"api/classhal_1_1bit__value/#function-toggle-22","title":"function toggle [2/2]","text":"<pre><code>inline constexpr auto &amp; hal::bit_value::toggle (\n    bit_mask p_field\n) \n</code></pre>"},{"location":"api/classhal_1_1bit__value/#protected-attributes-documentation","title":"Protected Attributes Documentation","text":""},{"location":"api/classhal_1_1bit__value/#variable-m_value","title":"variable m_value","text":"<pre><code>T hal::bit_value&lt; T &gt;::m_value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/bit.hpp</code></p>"},{"location":"api/structhal_1_1byte__mask/","title":"Struct hal::byte_mask","text":"<p>template &lt;size_t ByteIndex&gt;</p> <p>ClassList &gt; hal &gt; byte_mask</p> <p>Helper for generating byte position masks. More...</p> <ul> <li><code>#include &lt;bit.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1byte__mask/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr hal::bit_mask value   = { .position = ByteIndex, .width = 8 }Mask value defined at compile time."},{"location":"api/structhal_1_1byte__mask/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>ByteIndex</code> - the byte position to make a mask for </li> </ul>"},{"location":"api/structhal_1_1byte__mask/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/structhal_1_1byte__mask/#variable-value","title":"variable value","text":"<pre><code>constexpr hal::bit_mask hal::byte_mask&lt; ByteIndex &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/bit.hpp</code></p>"},{"location":"api/classhal_1_1can/","title":"Class hal::can","text":"<p>ClassList &gt; hal &gt; can</p> <p>Controller Area Network (CAN bus) hardware abstraction interface. </p> <ul> <li><code>#include &lt;can.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::lpc40::can,  hal::mock::can</p>"},{"location":"api/classhal_1_1can/#classes","title":"Classes","text":"Type Name struct message_t A CAN message. struct send_t Feedback from sending data over the CAN BUS. struct settings Generic settings for a can peripheral."},{"location":"api/classhal_1_1can/#public-types","title":"Public Types","text":"Type Name typedef void(const message_t &amp;p_message) handler Receive handler for can messages. typedef uint32_t id_t Can message ID type trait."},{"location":"api/classhal_1_1can/#public-functions","title":"Public Functions","text":"Type Name status bus_on () Transition the CAN device from \"bus-off\" to \"bus-on\". status configure (const settings &amp; p_settings) Configure this can bus port to match the settings supplied. void on_receive (hal::callback&lt; handler &gt; p_handler) Set the message reception handler. result&lt; send_t &gt; send (const message_t &amp; p_message) Send a can message. virtual ~can () = default"},{"location":"api/classhal_1_1can/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classhal_1_1can/#typedef-handler","title":"typedef handler","text":"<pre><code>using hal::can::handler =  void(const message_t&amp; p_message);\n</code></pre>"},{"location":"api/classhal_1_1can/#typedef-id_t","title":"typedef id_t","text":"<pre><code>using hal::can::id_t =  uint32_t;\n</code></pre>"},{"location":"api/classhal_1_1can/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1can/#function-bus_on","title":"function bus_on","text":"<p>Transition the CAN device from \"bus-off\" to \"bus-on\". <pre><code>inline status hal::can::bus_on () \n</code></pre></p> <p>WARNING: Calling this function when the device is already in \"bus-on\" will have no effect. This function is not necessary to call after creating the CAN driver as the driver should already be \"bus-on\" on creation.</p> <p>Can devices have two counters to determine system health. These two counters are the \"transmit error counter\" and the \"receive error counter\". Transmission errors can occur when the device attempts to communicate on the bus and either does not get an acknowledge or sees an unexpected or erroneous signal on the bus during its own transmission. When transmission errors reach 255 counts, the device will go into the \"bus-off\" state.</p> <p>In the \"bus-off\" state, the CAN peripheral can no longer communicate on the bus. Any calls to <code>send()</code> will throw the error <code>std::errc::network_down</code>. If this occurs, this function must be called to re-enable bus communication.</p> <p>Returns:</p> <p>status - success or failure. In the case this function fails repeatedly, it is advised to simply not use the bus anymore as something is critical wrong and may not be recoverable. </p>"},{"location":"api/classhal_1_1can/#function-configure","title":"function configure","text":"<p>Configure this can bus port to match the settings supplied. <pre><code>inline status hal::can::configure (\n    const settings &amp; p_settings\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_settings</code> - settings to apply to can driver </li> </ul> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::invalid_argument</code> if the settings could not be achieved. </li> </ul>"},{"location":"api/classhal_1_1can/#function-on_receive","title":"function on_receive","text":"<p>Set the message reception handler. <pre><code>inline void hal::can::on_receive (\n    hal::callback &lt; handler &gt; p_handler\n) \n</code></pre></p> <p>All messages received before a message handler is installed are dropped.</p> <p>Parameters:</p> <ul> <li><code>p_handler</code> - this handler will be called when a message has been received. </li> </ul>"},{"location":"api/classhal_1_1can/#function-send","title":"function send","text":"<p>Send a can message. <pre><code>inline result&lt; send_t &gt; hal::can::send (\n    const message_t &amp; p_message\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_message</code> - the message to be sent </li> </ul> <p>Returns:</p> <p>result&lt;send_t&gt; - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::network_down</code> - if the can device is in the \"bus-off\" state. This can happen if a critical fault in the bus has occurred. A call to <code>bus_on()</code> will need to be issued to attempt to talk on the bus again. See <code>bus_on()</code> for more details. </li> </ul>"},{"location":"api/classhal_1_1can/#function-can","title":"function ~can","text":"<pre><code>virtual hal::can::~can () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/can.hpp</code></p>"},{"location":"api/structhal_1_1can_1_1message__t/","title":"Struct hal::can::message_t","text":"<p>ClassList &gt; hal &gt; can &gt; message_t</p> <p>A CAN message. </p> <ul> <li><code>#include &lt;can.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1can_1_1message__t/#public-attributes","title":"Public Attributes","text":"Type Name id_t id ID of the message. bool is_remote_request   = = falseDetermines if the message is a remote request frame. uint8_t length   = = 0The number of valid elements in the payload. std::array&lt; hal::byte, 8 &gt; payload   = {}Message data contents."},{"location":"api/structhal_1_1can_1_1message__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1can_1_1message__t/#variable-id","title":"variable id","text":"<pre><code>id_t hal::can::message_t::id;\n</code></pre>"},{"location":"api/structhal_1_1can_1_1message__t/#variable-is_remote_request","title":"variable is_remote_request","text":"<p>Determines if the message is a remote request frame. <pre><code>bool hal::can::message_t::is_remote_request;\n</code></pre></p> <p>If true, then length and payload are ignored. </p>"},{"location":"api/structhal_1_1can_1_1message__t/#variable-length","title":"variable length","text":"<p>The number of valid elements in the payload. <pre><code>uint8_t hal::can::message_t::length;\n</code></pre></p> <p>Can be between 0 and 8. A length value above 8 should be considered invalid and can be discarded. </p>"},{"location":"api/structhal_1_1can_1_1message__t/#variable-payload","title":"variable payload","text":"<pre><code>std::array&lt;hal::byte, 8&gt; hal::can::message_t::payload;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/can.hpp</code></p>"},{"location":"api/structhal_1_1can_1_1send__t/","title":"Struct hal::can::send_t","text":"<p>ClassList &gt; hal &gt; can &gt; send_t</p> <p>Feedback from sending data over the CAN BUS. More...</p> <ul> <li><code>#include &lt;can.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1can_1_1send__t/#detailed-description","title":"Detailed Description","text":"<p>This structure is currently empty as no feedback has been determined for now. This structure may be expanded in the future. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/can.hpp</code></p>"},{"location":"api/structhal_1_1can_1_1settings/","title":"Struct hal::can::settings","text":"<p>ClassList &gt; hal &gt; can &gt; settings</p> <p>Generic settings for a can peripheral. More...</p> <ul> <li><code>#include &lt;can.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1can_1_1settings/#public-attributes","title":"Public Attributes","text":"Type Name hertz baud_rate   = = 100.0_kHzBus clock rate in hertz. std::uint8_t phase_segment1   = = 3Length of Phase Segment 1 (1qt ... 8qt) std::uint8_t phase_segment2   = = 3Length of Phase Segment 2 (1qt ... 8qt) std::uint8_t propagation_delay   = = 3Propagation Delay (1qt ... 8qt) std::uint8_t synchronization_jump_width   = = 1Synchronization jump width (1qt ... 4qt)"},{"location":"api/structhal_1_1can_1_1settings/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr std::uint8_t sync_segment   = = 1Sync Segment (always 1qt)"},{"location":"api/structhal_1_1can_1_1settings/#detailed-description","title":"Detailed Description","text":"<p>CAN Bit Quanta Timing Diagram of:  </p>"},{"location":"api/structhal_1_1can_1_1settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1can_1_1settings/#variable-baud_rate","title":"variable baud_rate","text":"<pre><code>hertz hal::can::settings::baud_rate;\n</code></pre>"},{"location":"api/structhal_1_1can_1_1settings/#variable-phase_segment1","title":"variable phase_segment1","text":"<p>Length of Phase Segment 1 (1qt ... 8qt) <pre><code>std::uint8_t hal::can::settings::phase_segment1;\n</code></pre></p> <p>Determines the bit rate, phase segment 1 acts as a buffer that can be lengthened to resynchronize with the bit stream via the synchronization_jump_width. Includes propagation delay </p>"},{"location":"api/structhal_1_1can_1_1settings/#variable-phase_segment2","title":"variable phase_segment2","text":"<p>Length of Phase Segment 2 (1qt ... 8qt) <pre><code>std::uint8_t hal::can::settings::phase_segment2;\n</code></pre></p> <p>Determines the bit rate and is like phase segment 1 and occurs after the sampling point. Phase segment 2 can be shortened to resynchronize with the bit stream via the synchronization_jump_width. </p>"},{"location":"api/structhal_1_1can_1_1settings/#variable-propagation_delay","title":"variable propagation_delay","text":"<p>Propagation Delay (1qt ... 8qt) <pre><code>std::uint8_t hal::can::settings::propagation_delay;\n</code></pre></p> <p>Propagation time It is used to compensate for signal delays across the network. </p>"},{"location":"api/structhal_1_1can_1_1settings/#variable-synchronization_jump_width","title":"variable synchronization_jump_width","text":"<p>Synchronization jump width (1qt ... 4qt) <pre><code>std::uint8_t hal::can::settings::synchronization_jump_width;\n</code></pre></p> <p>This is the maximum time by which the bit sampling period may be lengthened or shortened during each cycle to adjust for oscillator mismatch between nodes.</p> <p>This value must be smaller than phase_segment1 and phase_segment2 </p>"},{"location":"api/structhal_1_1can_1_1settings/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/structhal_1_1can_1_1settings/#variable-sync_segment","title":"variable sync_segment","text":"<p>Sync Segment (always 1qt) <pre><code>constexpr std::uint8_t hal::can::settings::sync_segment;\n</code></pre></p> <p>Initial sync transition, the start of a CAN bit </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/can.hpp</code></p>"},{"location":"api/classhal_1_1can__router/","title":"Class hal::can_router","text":"<p>ClassList &gt; hal &gt; can_router</p> <p>Route CAN messages received on the can bus to callbacks based on ID. </p> <ul> <li><code>#include &lt;can_router.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1can__router/#classes","title":"Classes","text":"Type Name struct route"},{"location":"api/classhal_1_1can__router/#public-types","title":"Public Types","text":"Type Name typedef hal::callback&lt; hal::can::handler &gt; message_handler typedef static_list&lt; route &gt;::item route_item"},{"location":"api/classhal_1_1can__router/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr auto noop   = =  {}"},{"location":"api/classhal_1_1can__router/#public-functions","title":"Public Functions","text":"Type Name static_list&lt; route &gt;::item add_message_callback (hal::can::id_t p_id) Add a message route without setting the callback. static_list&lt; route &gt;::item add_message_callback (hal::can::id_t p_id, message_handler p_handler) Set a callback for when messages with a specific ID is received. hal::can &amp; bus () Get a reference to the can peripheral driver. can_router (hal::can &amp; p_can) Construct a new can message router. can_router () = delete can_router (can_router &amp; p_other) = delete can_router (can_router &amp;&amp; p_other) noexcept const static_list&lt; route &gt; &amp; handlers () Get the list of handlers. void operator() (const can::message_t &amp; p_message) Message routing interrupt service handler. can_router &amp; operator= (can_router &amp; p_other) = delete can_router &amp; operator= (can_router &amp;&amp; p_other) noexcept ~can_router ()"},{"location":"api/classhal_1_1can__router/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; can_router &gt; create (hal::can &amp; p_can)"},{"location":"api/classhal_1_1can__router/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classhal_1_1can__router/#typedef-message_handler","title":"typedef message_handler","text":"<pre><code>using hal::can_router::message_handler =  hal::callback&lt;hal::can::handler&gt;;\n</code></pre>"},{"location":"api/classhal_1_1can__router/#typedef-route_item","title":"typedef route_item","text":"<pre><code>using hal::can_router::route_item =  static_list&lt;route&gt;::item;\n</code></pre>"},{"location":"api/classhal_1_1can__router/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/classhal_1_1can__router/#variable-noop","title":"variable noop","text":"<pre><code>constexpr auto hal::can_router::noop;\n</code></pre>"},{"location":"api/classhal_1_1can__router/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1can__router/#function-add_message_callback-12","title":"function add_message_callback [1/2]","text":"<p>Add a message route without setting the callback. <pre><code>static_list &lt; route &gt;::item hal::can_router::add_message_callback (\n    hal::can::id_t p_id\n) \n</code></pre></p> <p>The default callback will do nothing and will drop the message.</p> <p>Parameters:</p> <ul> <li><code>p_id</code> - Associated ID of messages to be stored. </li> </ul> <p>Returns:</p> <p>auto - route item from the linked list that must be stored stored in a variable </p>"},{"location":"api/classhal_1_1can__router/#function-add_message_callback-22","title":"function add_message_callback [2/2]","text":"<p>Set a callback for when messages with a specific ID is received. <pre><code>static_list &lt; route &gt;::item hal::can_router::add_message_callback (\n    hal::can::id_t p_id,\n    message_handler p_handler\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_id</code> - Associated ID of messages to be stored. </li> <li><code>p_handler</code> - callback to be executed when a p_id message is received. </li> </ul> <p>Returns:</p> <p>auto - route item from the linked list that must be stored stored in a variable </p>"},{"location":"api/classhal_1_1can__router/#function-bus","title":"function bus","text":"<p>Get a reference to the can peripheral driver. <pre><code>hal::can &amp; hal::can_router::bus () \n</code></pre></p> <p>Used to send can messages through the same port that the can_router is using.</p> <p>Returns:</p> <p>can&amp; reference to the can peripheral driver </p>"},{"location":"api/classhal_1_1can__router/#function-can_router-14","title":"function can_router [1/4]","text":"<p>Construct a new can message router. <pre><code>explicit hal::can_router::can_router (\n    hal::can &amp; p_can\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_can</code> - can peripheral to route messages for </li> </ul>"},{"location":"api/classhal_1_1can__router/#function-can_router-24","title":"function can_router [2/4]","text":"<pre><code>hal::can_router::can_router () = delete\n</code></pre>"},{"location":"api/classhal_1_1can__router/#function-can_router-34","title":"function can_router [3/4]","text":"<pre><code>hal::can_router::can_router (\n    can_router &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1can__router/#function-can_router-44","title":"function can_router [4/4]","text":"<pre><code>hal::can_router::can_router (\n    can_router &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1can__router/#function-handlers","title":"function handlers","text":"<p>Get the list of handlers. <pre><code>const static_list &lt; route &gt; &amp; hal::can_router::handlers () \n</code></pre></p> <p>Meant for testing purposes or when direct inspection of the map is useful in userspace. Should not be used in by libraries.</p> <p>Returns:</p> <p>const auto&amp; map of all of the can message handlers. </p>"},{"location":"api/classhal_1_1can__router/#function-operator","title":"function operator()","text":"<p>Message routing interrupt service handler. <pre><code>void hal::can_router::operator() (\n    const can::message_t &amp; p_message\n) \n</code></pre></p> <p>Searches the static list and finds the first ID associated with the message and run's that route's callback.</p> <p>Parameters:</p> <ul> <li><code>p_message</code> - message received from the bus </li> </ul>"},{"location":"api/classhal_1_1can__router/#function-operator_1","title":"function operator=","text":"<pre><code>can_router &amp; hal::can_router::operator= (\n    can_router &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1can__router/#function-operator_2","title":"function operator=","text":"<pre><code>can_router &amp; hal::can_router::operator= (\n    can_router &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1can__router/#function-can_router","title":"function ~can_router","text":"<pre><code>hal::can_router::~can_router () \n</code></pre>"},{"location":"api/classhal_1_1can__router/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1can__router/#function-create","title":"function create","text":"<pre><code>static result&lt; can_router &gt; hal::can_router::create (\n    hal::can &amp; p_can\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-canrouter/can_router.hpp</code></p>"},{"location":"api/structhal_1_1can__router_1_1route/","title":"Struct hal::can_router::route","text":"<p>ClassList &gt; hal &gt; can_router &gt; route</p>"},{"location":"api/structhal_1_1can__router_1_1route/#public-attributes","title":"Public Attributes","text":"Type Name message_handler handler   = = noop hal::can::id_t id   = = 0"},{"location":"api/structhal_1_1can__router_1_1route/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1can__router_1_1route/#variable-handler","title":"variable handler","text":"<pre><code>message_handler hal::can_router::route::handler;\n</code></pre>"},{"location":"api/structhal_1_1can__router_1_1route/#variable-id","title":"variable id","text":"<pre><code>hal::can::id_t hal::can_router::route::id;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-canrouter/can_router.hpp</code></p>"},{"location":"api/namespacehal_1_1cortex__m/","title":"Namespace hal::cortex_m","text":"<p>Namespace List &gt; hal &gt; cortex_m</p> <p>libhal drivers for the ARM Cortex-M series of processors </p>"},{"location":"api/namespacehal_1_1cortex__m/#classes","title":"Classes","text":"Type Name class dwt_counter A counter with a frequency fixed to the CPU clock rate. class interrupt Cortex M series interrupt controller. class systick_timer SysTick driver for the ARM Cortex Mx series chips."},{"location":"api/namespacehal_1_1cortex__m/#public-types","title":"Public Types","text":"Type Name typedef void(*)() interrupt_pointer Used specifically for defining an interrupt vector table of addresses. enum irq IRQ numbers for core processor interrupts."},{"location":"api/namespacehal_1_1cortex__m/#public-functions","title":"Public Functions","text":"Type Name void * get_interrupt_vector_table_address () Get the address of the systems interrupt vector table. void initialize_bss_section () Initialize the BSS (uninitialized data section) to all zeros. void initialize_data_section () Initialize the data section of RAM. This should be the first thing called in main() before using any global or statically allocated variables. It can also be called in the startup code before main is called. This is not done by crt0.s (C runtime startup code) because with an OS, when the executable is copied to RAM, the data section is also copied and those same locations can be reused for the application, removing the need to copy the data section. This will also happen if one loads an elf file to an MCU using a debugger. Typically the RAM section, but not BSS, is copied over. But in the case of the MCU without a debugger, the MCU will have to manage coping the contents from ROM to RAM itself. Systems should always assume they haven't been loaded by any means and should set the data section at the start of the application. void initialize_floating_point_unit () Enable the floating point unit coprocessor. void reset () Request reset from CPU. void set_interrupt_vector_table_address (void * p_table_location) Set the address of the systems interrupt vector table. void wait_for_event () Executes WFE instruction. void wait_for_interrupt () Executes WFI instruction."},{"location":"api/namespacehal_1_1cortex__m/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacehal_1_1cortex__m/#typedef-interrupt_pointer","title":"typedef interrupt_pointer","text":"<pre><code>using hal::cortex_m::interrupt_pointer = typedef void (*)();\n</code></pre>"},{"location":"api/namespacehal_1_1cortex__m/#enum-irq","title":"enum irq","text":"<pre><code>enum hal::cortex_m::irq {\n    top_of_stack = 0,\n    reset = 1,\n    nmi = 2,\n    hard_fault = 3,\n    memory_management_fault = 4,\n    bus_fault = 5,\n    usage_fault = 6,\n    reserve7 = 7,\n    reserve8 = 8,\n    reserve9 = 9,\n    reserve10 = 10,\n    sv_call = 11,\n    reserve12 = 12,\n    reserve13 = 13,\n    pend_sv = 14,\n    systick = 15\n};\n</code></pre>"},{"location":"api/namespacehal_1_1cortex__m/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacehal_1_1cortex__m/#function-get_interrupt_vector_table_address","title":"function get_interrupt_vector_table_address","text":"<p>Get the address of the systems interrupt vector table. <pre><code>void * hal::cortex_m::get_interrupt_vector_table_address () \n</code></pre></p> <p>On reset the VTOR register is set to 0x0000'0000 or nullptr.</p> <p>Returns:</p> <p>void* - address within VTOR the interrupt vector table relocation register. </p>"},{"location":"api/namespacehal_1_1cortex__m/#function-initialize_bss_section","title":"function initialize_bss_section","text":"<p>Initialize the BSS (uninitialized data section) to all zeros. <pre><code>inline void hal::cortex_m::initialize_bss_section () \n</code></pre></p> <p>Not required if the C Runtime 0 (crt0.s/.a/.o) is used as a startup routine. </p>"},{"location":"api/namespacehal_1_1cortex__m/#function-initialize_data_section","title":"function initialize_data_section","text":"<pre><code>inline void hal::cortex_m::initialize_data_section () \n</code></pre>"},{"location":"api/namespacehal_1_1cortex__m/#function-initialize_floating_point_unit","title":"function initialize_floating_point_unit","text":"<p>Enable the floating point unit coprocessor. <pre><code>void hal::cortex_m::initialize_floating_point_unit () \n</code></pre></p> <p>WARNING: If the coprocessor does not exist, as it is optional, a UsageFault will occur. Floating point units are only found within Cortex M4 and above processors. </p>"},{"location":"api/namespacehal_1_1cortex__m/#function-reset","title":"function reset","text":"<pre><code>void hal::cortex_m::reset () \n</code></pre>"},{"location":"api/namespacehal_1_1cortex__m/#function-set_interrupt_vector_table_address","title":"function set_interrupt_vector_table_address","text":"<p>Set the address of the systems interrupt vector table. <pre><code>void hal::cortex_m::set_interrupt_vector_table_address (\n    void * p_table_location\n) \n</code></pre></p> <p>The interrupt vector table (IVT) is held in ROM which means that, either the interrupt service routines (ISR) had to be defined at compile time making them immutable at runtime, or that each ISR calls a mutable function pointer which can be changed at runtime.</p> <p>The problem with the first option is that it makes writing and using libraries difficult. Usually requiring updates to the IVT manually by the application designer based on what libraries and drivers the application is using.</p> <p>The second solution has a problem where the additional another layer of indirection increases interrupt latency. A more critical problem of this approach is that many ISRs take advantage of the state of the system when the ISR runs. For example, context switching in an RTOS needs to be able to see the address of where code was when the interrupt occurred and having an additional point of indirection (i.e. calling a function pointer) will change that location from the task to the ISR that called the context switch function. This will usually result in a fault of some sort.</p> <p>Creating an interrupt vector table in RAM and relocating the ISRs there consumes RAM space, but gives great flexibility over the table at runtime.</p> <p>Parameters:</p> <ul> <li><code>p_table_location</code> - address of the interrupt vector table. </li> </ul>"},{"location":"api/namespacehal_1_1cortex__m/#function-wait_for_event","title":"function wait_for_event","text":"<p>Executes WFE instruction. <pre><code>void hal::cortex_m::wait_for_event () \n</code></pre></p> <p>The WFE instruction stops the CPU, reducing power, and wakes up on event. </p>"},{"location":"api/namespacehal_1_1cortex__m/#function-wait_for_interrupt","title":"function wait_for_interrupt","text":"<p>Executes WFI instruction. <pre><code>void hal::cortex_m::wait_for_interrupt () \n</code></pre></p> <p>The WFI instruction stops the CPU, reducing power, and wakes up on interrupt. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-armcortex/dwt_counter.hpp</code></p>"},{"location":"api/classhal_1_1cortex__m_1_1dwt__counter/","title":"Class hal::cortex_m::dwt_counter","text":"<p>ClassList &gt; hal &gt; cortex_m &gt; dwt_counter</p> <p>A counter with a frequency fixed to the CPU clock rate. More...</p> <ul> <li><code>#include &lt;dwt_counter.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::steady_clock</p>"},{"location":"api/classhal_1_1cortex__m_1_1dwt__counter/#public-functions","title":"Public Functions","text":"Type Name dwt_counter (hertz p_cpu_frequency) Construct a new dwt counter object. void register_cpu_frequency (hertz p_cpu_frequency) Inform the driver of the operating frequency of the CPU in order to generate the correct uptime."},{"location":"api/classhal_1_1cortex__m_1_1dwt__counter/#public-functions-inherited-from-halsteady_clock","title":"Public Functions inherited from hal::steady_clock","text":"<p>See hal::steady_clock</p> Type Name frequency_t frequency () Get the operating frequency of the steady clock. uptime_t uptime () Get the current value of the steady clock. virtual ~steady_clock () = default"},{"location":"api/classhal_1_1cortex__m_1_1dwt__counter/#detailed-description","title":"Detailed Description","text":"<p>This driver is supported for Cortex M3 devices and above. </p>"},{"location":"api/classhal_1_1cortex__m_1_1dwt__counter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1cortex__m_1_1dwt__counter/#function-dwt_counter","title":"function dwt_counter","text":"<p>Construct a new dwt counter object. <pre><code>hal::cortex_m::dwt_counter::dwt_counter (\n    hertz p_cpu_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_cpu_frequency</code> - the operating frequency of the CPU </li> </ul>"},{"location":"api/classhal_1_1cortex__m_1_1dwt__counter/#function-register_cpu_frequency","title":"function register_cpu_frequency","text":"<p>Inform the driver of the operating frequency of the CPU in order to generate the correct uptime. <pre><code>void hal::cortex_m::dwt_counter::register_cpu_frequency (\n    hertz p_cpu_frequency\n) \n</code></pre></p> <p>Use this when the CPU's operating frequency has changed and no longer matches the frequency supplied to the constructor. Care should be taken when expecting this function when there is the potentially other parts of the system that depend on this counter's uptime to operate.</p> <p>Parameters:</p> <ul> <li><code>p_cpu_frequency</code> - the operating frequency of the CPU </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-armcortex/dwt_counter.hpp</code></p>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt/","title":"Class hal::cortex_m::interrupt","text":"<p>ClassList &gt; hal &gt; cortex_m &gt; interrupt</p> <p>Cortex M series interrupt controller. </p> <ul> <li><code>#include &lt;interrupt.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#classes","title":"Classes","text":"Type Name class exception_number represents an interrupt request number along with helper functions for setting up the interrupt controller registers."},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr size_t core_interrupts   = = 16The core interrupts that all cortex m3, m4, m7 processors have."},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#public-functions","title":"Public Functions","text":"Type Name void disable () disable interrupt and set the service routine handler to \"nop\". void enable (interrupt_pointer p_handler) enable interrupt and set the service routine handler. interrupt (exception_number p_id) Construct a new interrupt object. bool verify_vector_enabled (interrupt_pointer p_handler) determine if a particular handler has been put into the interrupt vector table."},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#public-static-functions","title":"Public Static Functions","text":"Type Name void disable_interrupts ()  void enable_interrupts ()  const std::span&lt; interrupt_pointer &gt; get_vector_table () Get a reference to interrupt vector table object. void initialize () Initializes the interrupt vector table. void nop () Place holder interrupt that performs no work. void reinitialize () Reinitialize vector table."},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#variable-core_interrupts","title":"variable core_interrupts","text":"<pre><code>constexpr size_t hal::cortex_m::interrupt::core_interrupts;\n</code></pre>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#function-disable","title":"function disable","text":"<p>disable interrupt and set the service routine handler to \"nop\". <pre><code>void hal::cortex_m::interrupt::disable () \n</code></pre></p> <p>If the IRQ is invalid, then nothing happens. </p>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#function-enable","title":"function enable","text":"<p>enable interrupt and set the service routine handler. <pre><code>void hal::cortex_m::interrupt::enable (\n    interrupt_pointer p_handler\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_handler</code> - the interrupt service routine handler to be executed when the hardware interrupt is fired. </li> </ul>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#function-interrupt","title":"function interrupt","text":"<p>Construct a new interrupt object. <pre><code>explicit hal::cortex_m::interrupt::interrupt (\n    exception_number p_id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_id</code> - interrupt to configure </li> </ul>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#function-verify_vector_enabled","title":"function verify_vector_enabled","text":"<p>determine if a particular handler has been put into the interrupt vector table. <pre><code>bool hal::cortex_m::interrupt::verify_vector_enabled (\n    interrupt_pointer p_handler\n) \n</code></pre></p> <p>Generally used by unit testing code.</p> <p>Parameters:</p> <ul> <li><code>p_handler</code> - the handler to check against </li> </ul> <p>Returns:</p> <p>true - the handler is equal to the handler in the table </p> <p>Returns:</p> <p>false - the handler is not at this index in the table </p>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#function-disable_interrupts","title":"function disable_interrupts","text":"<pre><code>static void hal::cortex_m::interrupt::disable_interrupts () \n</code></pre>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#function-enable_interrupts","title":"function enable_interrupts","text":"<pre><code>static void hal::cortex_m::interrupt::enable_interrupts () \n</code></pre>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#function-get_vector_table","title":"function get_vector_table","text":"<p>Get a reference to interrupt vector table object. <pre><code>static const std::span&lt; interrupt_pointer &gt; hal::cortex_m::interrupt::get_vector_table () \n</code></pre></p> <p>Returns:</p> <p>const std::span&lt;interrupt_pointer&gt; - interrupt vector table </p>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#function-initialize","title":"function initialize","text":"<p>Initializes the interrupt vector table. <pre><code>template&lt;size_t VectorCount&gt;\nstatic inline void hal::cortex_m::interrupt::initialize () \n</code></pre></p> <p>This template function does the following: * Statically allocates a 512-byte aligned an interrupt vector table the size of VectorCount. * Set the default handlers for all interrupt vectors to the \"nop\" function which does nothing * Set vector_table span to the statically allocated vector table. * Finally it relocates the system's interrupt vector table away from the hard coded vector table in ROM/Flash memory to the statically allocated table in RAM.</p> <p>Internally, this function checks if it has been called before and will simply return early if so. Making this function safe to call multiple times so long as the VectorCount template parameter is the same with each invocation.</p> <p>Calling this function with differing VectorCount values will result in multiple statically allocated interrupt vector tables, which will simply waste space in RAM. Only the first call is used as the IVT.</p> <p>Template parameters:</p> <ul> <li><code>VectorCount</code> - the number of interrupts available for this system </li> </ul>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#function-nop","title":"function nop","text":"<pre><code>static void hal::cortex_m::interrupt::nop () \n</code></pre>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt/#function-reinitialize","title":"function reinitialize","text":"<p>Reinitialize vector table. <pre><code>template&lt;size_t VectorCount&gt;\nstatic inline void hal::cortex_m::interrupt::reinitialize () \n</code></pre></p> <p>Will reset the entries of the vector table. Careful to not use this after any drivers have already put entries on to the vector table. This will also disable all interrupts currently enabled on the system.</p> <p>Template parameters:</p> <ul> <li><code>VectorCount</code> - the number of interrupts available for this system </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-armcortex/interrupt.hpp</code></p>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/","title":"Class hal::cortex_m::interrupt::exception_number","text":"<p>ClassList &gt; hal &gt; cortex_m &gt; interrupt &gt; exception_number</p> <p>represents an interrupt request number along with helper functions for setting up the interrupt controller registers. </p> <ul> <li><code>#include &lt;interrupt.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint32_t enable_mask_code   = = 0x1FLower 5 bits indicate which bit within the 32-bit word is the enable bit. constexpr uint32_t index_position   = = 5Bits 5 and above represent which 32-bit word in the iser and icer arrays IRQs enable bit resides."},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#public-functions","title":"Public Functions","text":"Type Name constexpr bool default_enabled () constDetermines if the irq is within the range of ARM. constexpr std::uint32_t enable_mask () constreturn a mask with a 1 bit in the enable position for this exception_number . constexpr exception_number (std::uint16_t p_id) construct an exception_number from an int constexpr exception_number (exception_number &amp; p_id) = default constexpr std::uint16_t get_event_number ()  bool is_valid () constdetermines if the irq is within bounds of the interrupt vector table. constexpr exception_number &amp; operator= (exception_number &amp; p_id) = default constexpr std::uint32_t register_index () constthe enable bit for this interrupt resides within one of the 32-bit registers within the \"iser\" and \"icer\" arrays. This function will return the index of which 32-bit register contains the enable bit. constexpr std::uint32_t to_irq_number () const constexpr size_t vector_index () constProvides the index within the IVT."},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#variable-enable_mask_code","title":"variable enable_mask_code","text":"<pre><code>constexpr uint32_t hal::cortex_m::interrupt::exception_number::enable_mask_code;\n</code></pre>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#variable-index_position","title":"variable index_position","text":"<pre><code>constexpr uint32_t hal::cortex_m::interrupt::exception_number::index_position;\n</code></pre>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#function-default_enabled","title":"function default_enabled","text":"<p>Determines if the irq is within the range of ARM. <pre><code>inline constexpr bool hal::cortex_m::interrupt::exception_number::default_enabled () const\n</code></pre></p> <p>Returns:</p> <p>true - irq is enabled by default </p> <p>Returns:</p> <p>false - irq must be enabled to work </p>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#function-enable_mask","title":"function enable_mask","text":"<p>return a mask with a 1 bit in the enable position for this exception_number . <pre><code>inline constexpr std::uint32_t hal::cortex_m::interrupt::exception_number::enable_mask () const\n</code></pre></p> <p>Returns:</p> <p>constexpr std::uint32_t - enable mask </p>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#function-exception_number-12","title":"function exception_number [1/2]","text":"<p>construct an exception_number from an int <pre><code>inline constexpr hal::cortex_m::interrupt::exception_number::exception_number (\n    std::uint16_t p_id\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_id</code> - interrupt request number. If this value is beyond the bounds of the interrupt vector table, meaning it is an invalid exception number, then all operations will do nothing. </li> </ul>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#function-exception_number-22","title":"function exception_number [2/2]","text":"<pre><code>constexpr hal::cortex_m::interrupt::exception_number::exception_number (\n    exception_number &amp; p_id\n) = default\n</code></pre>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#function-get_event_number","title":"function get_event_number","text":"<pre><code>inline constexpr std::uint16_t hal::cortex_m::interrupt::exception_number::get_event_number () \n</code></pre> <p>Returns:</p> <p>constexpr std::uint16_t - the interrupt request number </p>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#function-is_valid","title":"function is_valid","text":"<p>determines if the irq is within bounds of the interrupt vector table. <pre><code>inline bool hal::cortex_m::interrupt::exception_number::is_valid () const\n</code></pre></p> <p>Returns:</p> <p>true - is a valid interrupt for this system </p> <p>Returns:</p> <p>false - this interrupt is beyond the range of valid interrupts </p>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#function-operator","title":"function operator=","text":"<pre><code>constexpr exception_number &amp; hal::cortex_m::interrupt::exception_number::operator= (\n    exception_number &amp; p_id\n) = default\n</code></pre>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#function-register_index","title":"function register_index","text":"<p>the enable bit for this interrupt resides within one of the 32-bit registers within the \"iser\" and \"icer\" arrays. This function will return the index of which 32-bit register contains the enable bit. <pre><code>inline constexpr std::uint32_t hal::cortex_m::interrupt::exception_number::register_index () const\n</code></pre></p> <p>Returns:</p> <p>constexpr std::uint32_t - array index </p>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#function-to_irq_number","title":"function to_irq_number","text":"<pre><code>inline constexpr std::uint32_t hal::cortex_m::interrupt::exception_number::to_irq_number () const\n</code></pre>"},{"location":"api/classhal_1_1cortex__m_1_1interrupt_1_1exception__number/#function-vector_index","title":"function vector_index","text":"<p>Provides the index within the IVT. <pre><code>inline constexpr size_t hal::cortex_m::interrupt::exception_number::vector_index () const\n</code></pre></p> <p>Returns:</p> <p>constexpr size_t - the index position </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-armcortex/interrupt.hpp</code></p>"},{"location":"api/classhal_1_1cortex__m_1_1systick__timer/","title":"Class hal::cortex_m::systick_timer","text":"<p>ClassList &gt; hal &gt; cortex_m &gt; systick_timer</p> <p>SysTick driver for the ARM Cortex Mx series chips. More...</p> <ul> <li><code>#include &lt;systick_timer.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::timer</p>"},{"location":"api/classhal_1_1cortex__m_1_1systick__timer/#public-types","title":"Public Types","text":"Type Name enum std::uint8_t clock_source Defines the set of clock sources for the SysTick timer."},{"location":"api/classhal_1_1cortex__m_1_1systick__timer/#public-functions","title":"Public Functions","text":"Type Name void register_cpu_frequency (hertz p_frequency, clock_source p_source=clock_source::processor) Inform the driver of the operating frequency of the CPU in order to generate the correct uptime. systick_timer (hertz p_frequency, clock_source p_source=clock_source::processor) Construct a new systick_timer timer object. ~systick_timer () Destroy the system timer object."},{"location":"api/classhal_1_1cortex__m_1_1systick__timer/#public-functions-inherited-from-haltimer","title":"Public Functions inherited from hal::timer","text":"<p>See hal::timer</p> Type Name result&lt; cancel_t &gt; cancel () Stops a scheduled event from happening. result&lt; is_running_t &gt; is_running () Determine if the timer is currently running. result&lt; schedule_t &gt; schedule (hal::callback&lt; void(void)&gt; p_callback, hal::time_duration p_delay) Schedule an callback be be executed after the delay time. virtual ~timer () = default"},{"location":"api/classhal_1_1cortex__m_1_1systick__timer/#detailed-description","title":"Detailed Description","text":"<p>Available in all ARM Cortex M series processors. Provides a generic and simple timer for every platform using these processor. </p>"},{"location":"api/classhal_1_1cortex__m_1_1systick__timer/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classhal_1_1cortex__m_1_1systick__timer/#enum-clock_source","title":"enum clock_source","text":"<pre><code>enum hal::cortex_m::systick_timer::clock_source {\n    external = 0,\n    processor = 1\n};\n</code></pre>"},{"location":"api/classhal_1_1cortex__m_1_1systick__timer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1cortex__m_1_1systick__timer/#function-register_cpu_frequency","title":"function register_cpu_frequency","text":"<p>Inform the driver of the operating frequency of the CPU in order to generate the correct uptime. <pre><code>void hal::cortex_m::systick_timer::register_cpu_frequency (\n    hertz p_frequency,\n    clock_source p_source=clock_source::processor\n) \n</code></pre></p> <p>Use this when the CPU's operating frequency has changed and no longer matches the frequency supplied to the constructor. Care should be taken when expecting this function when there is the potentially other parts of the system that depend on this counter's uptime to operate.</p> <p>This will clear any ongoing scheduled events as the timing will no longer be valid.</p> <p>Parameters:</p> <ul> <li><code>p_frequency</code> - the clock source's frequency </li> <li><code>p_source</code> - the source of the clock to the systick timer </li> </ul>"},{"location":"api/classhal_1_1cortex__m_1_1systick__timer/#function-systick_timer","title":"function systick_timer","text":"<p>Construct a new systick_timer timer object. <pre><code>hal::cortex_m::systick_timer::systick_timer (\n    hertz p_frequency,\n    clock_source p_source=clock_source::processor\n) \n</code></pre></p> <p>PRECONDITION: Interrupt vector table must be initialized before creating an instance of this object.</p> <p>Parameters:</p> <ul> <li><code>p_frequency</code> - the clock source's frequency </li> <li><code>p_source</code> - the source of the clock to the systick timer </li> </ul>"},{"location":"api/classhal_1_1cortex__m_1_1systick__timer/#function-systick_timer_1","title":"function ~systick_timer","text":"<p>Destroy the system timer object. <pre><code>hal::cortex_m::systick_timer::~systick_timer () \n</code></pre></p> <p>Stop the timer and disable the interrupt service routine. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-armcortex/systick_timer.hpp</code></p>"},{"location":"api/classhal_1_1dac/","title":"Class hal::dac","text":"<p>ClassList &gt; hal &gt; dac</p> <p>Digital to Analog Converter (DAC) hardware abstraction interface. More...</p> <ul> <li><code>#include &lt;dac.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::mock::dac,  hal::soft::inert_dac</p>"},{"location":"api/classhal_1_1dac/#classes","title":"Classes","text":"Type Name struct write_t Feedback from writing a voltage to the dac."},{"location":"api/classhal_1_1dac/#public-functions","title":"Public Functions","text":"Type Name result&lt; write_t &gt; write (float p_percentage) Set the output voltage of the DAC. virtual ~dac () = default"},{"location":"api/classhal_1_1dac/#detailed-description","title":"Detailed Description","text":"<p>Use this interface for devices and peripherals that can create arbitrary analog voltages between a defined Vss (negative reference) and Vcc (positive reference) voltage. </p>"},{"location":"api/classhal_1_1dac/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1dac/#function-write","title":"function write","text":"<p>Set the output voltage of the DAC. <pre><code>inline result&lt; write_t &gt; hal::dac::write (\n    float p_percentage\n) \n</code></pre></p> <p>The input value <code>p_percentage</code> is a 32-bit floating point value from 0.0f to +1.0f.</p> <p>The floating point value is linearly proportional to the output voltage relative to the Vss and Vcc such that if Vss is 0V (gnd) and Vcc is 5V then 0.0 is 0V, 0.25 is 1.25V, 0.445 is 2.225V and 1.0 is 5V.</p> <p>This function clamps the input value between 0.0f and 1.0f and thus values passed to driver implementations are guaranteed to be within this range. Callers of this function do not need to clamp their values before passing them into this function as it would be redundant. The rationale for doing this at the interface layer is that it allows callers and driver implementors to omit redundant clamping code, reducing code bloat.</p> <p>Parameters:</p> <ul> <li><code>p_percentage</code> - value from 0.0f to +1.0f representing the proportion of the output voltage from the Vss to Vcc. </li> </ul> <p>Returns:</p> <p>result&lt;write_t&gt; - success or failure </p>"},{"location":"api/classhal_1_1dac/#function-dac","title":"function ~dac","text":"<pre><code>virtual hal::dac::~dac () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/dac.hpp</code></p>"},{"location":"api/structhal_1_1dac_1_1write__t/","title":"Struct hal::dac::write_t","text":"<p>ClassList &gt; hal &gt; dac &gt; write_t</p> <p>Feedback from writing a voltage to the dac. More...</p> <ul> <li><code>#include &lt;dac.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1dac_1_1write__t/#detailed-description","title":"Detailed Description","text":"<p>This structure is currently empty as no feedback has been determined for now. This structure may be expanded in the future. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/dac.hpp</code></p>"},{"location":"api/classhal_1_1distance__sensor/","title":"Class hal::distance_sensor","text":"<p>ClassList &gt; hal &gt; distance_sensor</p> <p>Linear distance hardware abstraction interface. More...</p> <ul> <li><code>#include &lt;distance_sensor.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::soft::inert_distance_sensor</p>"},{"location":"api/classhal_1_1distance__sensor/#classes","title":"Classes","text":"Type Name struct read_t Result from sampling the distance sensor."},{"location":"api/classhal_1_1distance__sensor/#public-functions","title":"Public Functions","text":"Type Name result&lt; read_t &gt; read () Read the current distance measured by the device. virtual ~distance_sensor () = default"},{"location":"api/classhal_1_1distance__sensor/#detailed-description","title":"Detailed Description","text":"<p>Examples of distance encoder are:</p> <ul> <li>Linear Potentiometers</li> <li>LIDAR or TOF (time of flight) sensor</li> <li>Ultrasonic range finder</li> <li>Infrared Distance Sensors</li> <li>Linear Quadrature Encoders</li> <li>Linear Incremental Encoders</li> <li>Linear Absolute Encoders</li> <li>Linear Magnetic Encoders</li> </ul> <p>Distance sensors can be relative or absolute. Relative position means that the sensor can only see changes in rotation from where measurement started. In other words, at application start, relative encoders will start at 0. Absolute encoders know their position at all times. At application start, the absolute encoder will be able to determine its exact orientation relative to a frame of reference when read.</p> <p>Examples of relative rotation sensors are:</p> <ul> <li>Quadrature Encoders</li> <li>Incremental Encoders</li> </ul> <p>Examples of absolute rotation sensors are:</p> <ul> <li>Potentiometers</li> <li>Absolute Encoders</li> <li>Rotary Magnetic Encoders</li> <li>IMUs</li> </ul> <p>Distance sensors can also be finite or infinite. Finite meaning that the angle that can be reported is a fixed amount for the device. Infinite means that the encoder can continue rotating and adding more to its angle reading forever. Infinite rotation sensors tend to not have a physical stop that limits how much they can be rotated.</p> <p>Examples of finite rotation sensors are:</p> <ul> <li>Potentiometers</li> <li>Absolute Encoders</li> <li>IMUs</li> </ul> <p>Examples of infinite rotation sensors are:</p> <ul> <li>Rotary Magnetic Encoders</li> <li>Quadrature Encoders</li> <li>Incremental Encoders</li> </ul> <p>This interface does not provide a means to determine these attributes of a rotation sensor as this is an application architecture decision. Drivers that implement this interface should document what kind of distance sensor it is such that a developer can determine its applicability to their application. The context of which sensor ought to be used for an application is solely known at architecture definition time and software should not be expected to at runtime, if the right type of rotation sensor was passed into the object. </p>"},{"location":"api/classhal_1_1distance__sensor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1distance__sensor/#function-read","title":"function read","text":"<p>Read the current distance measured by the device. <pre><code>inline result&lt; read_t &gt; hal::distance_sensor::read () \n</code></pre></p> <p>Returns:</p> <p>result&lt;read_t&gt; - distance data </p>"},{"location":"api/classhal_1_1distance__sensor/#function-distance_sensor","title":"function ~distance_sensor","text":"<pre><code>virtual hal::distance_sensor::~distance_sensor () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/distance_sensor.hpp</code></p>"},{"location":"api/structhal_1_1distance__sensor_1_1read__t/","title":"Struct hal::distance_sensor::read_t","text":"<p>ClassList &gt; hal &gt; distance_sensor &gt; read_t</p> <p>Result from sampling the distance sensor. </p> <ul> <li><code>#include &lt;distance_sensor.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1distance__sensor_1_1read__t/#public-attributes","title":"Public Attributes","text":"Type Name meters distance Encoder distance measurement in meters."},{"location":"api/structhal_1_1distance__sensor_1_1read__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1distance__sensor_1_1read__t/#variable-distance","title":"variable distance","text":"<pre><code>meters hal::distance_sensor::read_t::distance;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/distance_sensor.hpp</code></p>"},{"location":"api/namespacehal_1_1error/","title":"Namespace hal::error","text":"<p>Namespace List &gt; hal &gt; error</p> <p>Error objects, templates, and constants. </p>"},{"location":"api/namespacehal_1_1error/#classes","title":"Classes","text":"Type Name struct invalid_option_t &lt;options&gt;Used for defining static_asserts that should always fail, but only if the static_assert line is hit via <code>if constexpr</code> control block. Prefer to NOT use this directly but to use<code>invalid_option</code> instead."},{"location":"api/namespacehal_1_1error/#public-attributes","title":"Public Attributes","text":"Type Name constexpr bool invalid_option   = = invalid_option_t&lt;options...&gt;::valueHelper definition to simplify the usage of invalid_option_t ."},{"location":"api/namespacehal_1_1error/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespacehal_1_1error/#variable-invalid_option","title":"variable invalid_option","text":"<p>Helper definition to simplify the usage of invalid_option_t . <pre><code>constexpr bool hal::error::invalid_option;\n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>options</code> ignored by the application but needed to create a non-trivial specialization of this class which allows its usage in static_assert. </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/error.hpp</code></p>"},{"location":"api/structhal_1_1error_1_1invalid__option__t/","title":"Struct hal::error::invalid_option_t","text":"<p>template &lt;auto... options&gt;</p> <p>ClassList &gt; hal &gt; error &gt; invalid_option_t</p> <p>Used for defining static_asserts that should always fail, but only if the static_assert line is hit via <code>if constexpr</code> control block. Prefer to NOT use this directly but to use<code>invalid_option</code> instead.More...</p> <ul> <li><code>#include &lt;error.hpp&gt;</code></li> </ul> <p>Inherits the following classes: std::false_type</p>"},{"location":"api/structhal_1_1error_1_1invalid__option__t/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>options</code> ignored by the application but needed to create a non-trivial specialization of this class which allows its usage in static_assert. </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/error.hpp</code></p>"},{"location":"api/namespacehal_1_1esp8266/","title":"Namespace hal::esp8266","text":"<p>Namespace List &gt; hal &gt; esp8266</p> <p>libhal compatible libraries for the esp8266 device and microcontroller</p>"},{"location":"api/namespacehal_1_1esp8266/#classes","title":"Classes","text":"Type Name class at AT Command network driver for the esp8266 . <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-esp8266/at.hpp</code></p>"},{"location":"api/classhal_1_1esp8266_1_1at/","title":"Class hal::esp8266::at","text":"<p>ClassList &gt; hal &gt; esp8266 &gt; at</p> <p>AT Command network driver for the esp8266 .More...</p> <ul> <li><code>#include &lt;at.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1esp8266_1_1at/#classes","title":"Classes","text":"Type Name struct read_t struct socket_config struct write_t"},{"location":"api/classhal_1_1esp8266_1_1at/#public-types","title":"Public Types","text":"Type Name typedef hal::function_ref&lt; hal::timeout_function &gt; deadline enum std::uint8_t socket_type"},{"location":"api/classhal_1_1esp8266_1_1at/#public-functions","title":"Public Functions","text":"Type Name hal::status connect_to_ap (std::string_view p_ssid, std::string_view p_password, deadline p_timeout)  hal::status connect_to_server (socket_config p_config, deadline p_timeout)  hal::status disconnect_from_ap (deadline p_timeout)  hal::status disconnect_from_server (deadline p_timeout)  hal::result&lt; bool &gt; is_connected_to_ap (deadline p_timeout)  hal::result&lt; bool &gt; is_connected_to_server (deadline p_timeout)  hal::status reset (deadline p_timeout)  hal::result&lt; read_t &gt; server_read (std::span&lt; hal::byte &gt; p_data)  hal::result&lt; write_t &gt; server_write (std::span&lt; const hal::byte &gt; p_data, deadline p_timeout)  hal::status set_ip_address (std::string_view p_ip, deadline p_timeout)"},{"location":"api/classhal_1_1esp8266_1_1at/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; at &gt; create (hal::serial &amp; p_serial, deadline p_timeout)  result&lt; at &amp; &gt; initialize (hal::serial &amp; p_serial, deadline p_timeout)"},{"location":"api/classhal_1_1esp8266_1_1at/#detailed-description","title":"Detailed Description","text":"<p>The esp8266::at driver can be used to connect to a WiFi access points (AP) and sending network traffic using TCP and UDP over IP. </p>"},{"location":"api/classhal_1_1esp8266_1_1at/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classhal_1_1esp8266_1_1at/#typedef-deadline","title":"typedef deadline","text":"<pre><code>using hal::esp8266::at::deadline =  hal::function_ref&lt;hal::timeout_function&gt;;\n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at/#enum-socket_type","title":"enum socket_type","text":"<pre><code>enum hal::esp8266::at::socket_type {\n    tcp,\n    udp\n};\n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1esp8266_1_1at/#function-connect_to_ap","title":"function connect_to_ap","text":"<pre><code>hal::status hal::esp8266::at::connect_to_ap (\n    std::string_view p_ssid,\n    std::string_view p_password,\n    deadline p_timeout\n) \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at/#function-connect_to_server","title":"function connect_to_server","text":"<pre><code>hal::status hal::esp8266::at::connect_to_server (\n    socket_config p_config,\n    deadline p_timeout\n) \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at/#function-disconnect_from_ap","title":"function disconnect_from_ap","text":"<pre><code>hal::status hal::esp8266::at::disconnect_from_ap (\n    deadline p_timeout\n) \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at/#function-disconnect_from_server","title":"function disconnect_from_server","text":"<pre><code>hal::status hal::esp8266::at::disconnect_from_server (\n    deadline p_timeout\n) \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at/#function-is_connected_to_ap","title":"function is_connected_to_ap","text":"<pre><code>hal::result&lt; bool &gt; hal::esp8266::at::is_connected_to_ap (\n    deadline p_timeout\n) \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at/#function-is_connected_to_server","title":"function is_connected_to_server","text":"<pre><code>hal::result&lt; bool &gt; hal::esp8266::at::is_connected_to_server (\n    deadline p_timeout\n) \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at/#function-reset","title":"function reset","text":"<pre><code>hal::status hal::esp8266::at::reset (\n    deadline p_timeout\n) \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at/#function-server_read","title":"function server_read","text":"<pre><code>hal::result&lt; read_t &gt; hal::esp8266::at::server_read (\n    std::span&lt; hal::byte &gt; p_data\n) \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at/#function-server_write","title":"function server_write","text":"<pre><code>hal::result&lt; write_t &gt; hal::esp8266::at::server_write (\n    std::span&lt; const hal::byte &gt; p_data,\n    deadline p_timeout\n) \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at/#function-set_ip_address","title":"function set_ip_address","text":"<pre><code>hal::status hal::esp8266::at::set_ip_address (\n    std::string_view p_ip,\n    deadline p_timeout\n) \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1esp8266_1_1at/#function-create","title":"function create","text":"<pre><code>static result&lt; at &gt; hal::esp8266::at::create (\n    hal::serial &amp; p_serial,\n    deadline p_timeout\n) \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at/#function-initialize","title":"function initialize","text":"<pre><code>template&lt;unsigned id&gt;\nstatic result&lt; at &amp; &gt; hal::esp8266::at::initialize (\n    hal::serial &amp; p_serial,\n    deadline p_timeout\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-esp8266/at.hpp</code></p>"},{"location":"api/structhal_1_1esp8266_1_1at_1_1read__t/","title":"Struct hal::esp8266::at::read_t","text":"<p>ClassList &gt; hal &gt; esp8266 &gt; at &gt; read_t</p>"},{"location":"api/structhal_1_1esp8266_1_1at_1_1read__t/#public-attributes","title":"Public Attributes","text":"Type Name std::span&lt; hal::byte &gt; data"},{"location":"api/structhal_1_1esp8266_1_1at_1_1read__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1esp8266_1_1at_1_1read__t/#variable-data","title":"variable data","text":"<pre><code>std::span&lt;hal::byte&gt; hal::esp8266::at::read_t::data;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-esp8266/at.hpp</code></p>"},{"location":"api/structhal_1_1esp8266_1_1at_1_1socket__config/","title":"Struct hal::esp8266::at::socket_config","text":"<p>ClassList &gt; hal &gt; esp8266 &gt; at &gt; socket_config</p>"},{"location":"api/structhal_1_1esp8266_1_1at_1_1socket__config/#public-attributes","title":"Public Attributes","text":"Type Name std::string_view domain std::uint16_t port   = = 80 socket_type type   = = socket_type::tcp"},{"location":"api/structhal_1_1esp8266_1_1at_1_1socket__config/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1esp8266_1_1at_1_1socket__config/#variable-domain","title":"variable domain","text":"<pre><code>std::string_view hal::esp8266::at::socket_config::domain;\n</code></pre>"},{"location":"api/structhal_1_1esp8266_1_1at_1_1socket__config/#variable-port","title":"variable port","text":"<pre><code>std::uint16_t hal::esp8266::at::socket_config::port;\n</code></pre>"},{"location":"api/structhal_1_1esp8266_1_1at_1_1socket__config/#variable-type","title":"variable type","text":"<pre><code>socket_type hal::esp8266::at::socket_config::type;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-esp8266/at.hpp</code></p>"},{"location":"api/structhal_1_1esp8266_1_1at_1_1write__t/","title":"Struct hal::esp8266::at::write_t","text":"<p>ClassList &gt; hal &gt; esp8266 &gt; at &gt; write_t</p>"},{"location":"api/structhal_1_1esp8266_1_1at_1_1write__t/#public-attributes","title":"Public Attributes","text":"Type Name std::span&lt; const hal::byte &gt; data"},{"location":"api/structhal_1_1esp8266_1_1at_1_1write__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1esp8266_1_1at_1_1write__t/#variable-data","title":"variable data","text":"<pre><code>std::span&lt;const hal::byte&gt; hal::esp8266::at::write_t::data;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-esp8266/at.hpp</code></p>"},{"location":"api/classhal_1_1gyroscope/","title":"Class hal::gyroscope","text":"<p>ClassList &gt; hal &gt; gyroscope</p> <p>Angular velocity sensing hardware abstraction interface. </p> <ul> <li><code>#include &lt;gyroscope.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::soft::inert_gyroscope</p>"},{"location":"api/classhal_1_1gyroscope/#classes","title":"Classes","text":"Type Name struct read_t Result from reading the gyroscope."},{"location":"api/classhal_1_1gyroscope/#public-functions","title":"Public Functions","text":"Type Name result&lt; read_t &gt; read () Read the latest angular velocity sensed by the device. virtual ~gyroscope () = default"},{"location":"api/classhal_1_1gyroscope/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1gyroscope/#function-read","title":"function read","text":"<p>Read the latest angular velocity sensed by the device. <pre><code>inline result&lt; read_t &gt; hal::gyroscope::read () \n</code></pre></p> <p>Returns:</p> <p>result&lt;read_t&gt; - angular velocity data </p>"},{"location":"api/classhal_1_1gyroscope/#function-gyroscope","title":"function ~gyroscope","text":"<pre><code>virtual hal::gyroscope::~gyroscope () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/gyroscope.hpp</code></p>"},{"location":"api/structhal_1_1gyroscope_1_1read__t/","title":"Struct hal::gyroscope::read_t","text":"<p>ClassList &gt; hal &gt; gyroscope &gt; read_t</p> <p>Result from reading the gyroscope. </p> <ul> <li><code>#include &lt;gyroscope.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1gyroscope_1_1read__t/#public-attributes","title":"Public Attributes","text":"Type Name rpm x Angular velocity in the X axis, relative to the device's reference frame. rpm y Angular velocity in the Y axis, relative to the device's reference frame. rpm z Angular velocity in the Z axis, relative to the device's reference frame."},{"location":"api/structhal_1_1gyroscope_1_1read__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1gyroscope_1_1read__t/#variable-x","title":"variable x","text":"<pre><code>rpm hal::gyroscope::read_t::x;\n</code></pre>"},{"location":"api/structhal_1_1gyroscope_1_1read__t/#variable-y","title":"variable y","text":"<pre><code>rpm hal::gyroscope::read_t::y;\n</code></pre>"},{"location":"api/structhal_1_1gyroscope_1_1read__t/#variable-z","title":"variable z","text":"<pre><code>rpm hal::gyroscope::read_t::z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/gyroscope.hpp</code></p>"},{"location":"api/classhal_1_1i2c/","title":"Class hal::i2c","text":"<p>ClassList &gt; hal &gt; i2c</p> <p>Inter-integrated Circuit (I2C) hardware abstract interface. More...</p> <ul> <li><code>#include &lt;i2c.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::lpc40::i2c,  hal::soft::minimum_speed_i2c</p>"},{"location":"api/classhal_1_1i2c/#classes","title":"Classes","text":"Type Name struct settings Generic settings for a standard I2C device. struct transaction_t Feedback from performing a transaction on the i2c bus."},{"location":"api/classhal_1_1i2c/#public-functions","title":"Public Functions","text":"Type Name status configure (const settings &amp; p_settings) Configure i2c to match the settings supplied. result&lt; transaction_t &gt; transaction (hal::byte p_address, std::span&lt; const hal::byte &gt; p_data_out, std::span&lt; hal::byte &gt; p_data_in, hal::function_ref&lt; hal::timeout_function &gt; p_timeout) perform an i2c transaction with another device on the bus. The type of transaction depends on values of input parameters. This function will block until the entire transfer is finished. virtual ~i2c () = default"},{"location":"api/classhal_1_1i2c/#detailed-description","title":"Detailed Description","text":"<p>Also known as Two Wire Interface (TWI) communication protocol. This is a very commonly used protocol for communication with sensors and peripheral devices because it only requires two connections SDA (data signal) and SCL (clock signal). This is possible because the protocol for I2C is addressable. </p>"},{"location":"api/classhal_1_1i2c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1i2c/#function-configure","title":"function configure","text":"<p>Configure i2c to match the settings supplied. <pre><code>inline status hal::i2c::configure (\n    const settings &amp; p_settings\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_settings</code> - settings to apply to i2c driver </li> </ul> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::invalid_argument</code> if the settings could not be achieved. </li> </ul>"},{"location":"api/classhal_1_1i2c/#function-transaction","title":"function transaction","text":"<p>perform an i2c transaction with another device on the bus. The type of transaction depends on values of input parameters. This function will block until the entire transfer is finished. <pre><code>inline result&lt; transaction_t &gt; hal::i2c::transaction (\n    hal::byte p_address,\n    std::span&lt; const hal::byte &gt; p_data_out,\n    std::span&lt; hal::byte &gt; p_data_in,\n    hal::function_ref &lt; hal::timeout_function &gt; p_timeout\n) \n</code></pre></p> <p>Performing Write, Read and Write-Then-Read transactions depends on which span for data_out and data_in are set to null.</p> <ul> <li>For write transactions, pass p_data_in as an empty span <code>std::span&lt; hal::byte &gt;{}</code> and pass a buffer to p_data_out.</li> <li>For read transactions, pass p_data_out as an empty span <code>std::span&lt;const  hal::byte &gt;{}</code> and pass a buffer to p_data_in.</li> <li>For write-then-read transactions, pass a buffer for both p_data_in p_data_out.</li> <li>If both p_data_in and p_data_out are empty, simply do nothing and return success.</li> </ul> <p>In the event of arbitration loss, this function will wait for the bus to become free and try again. Arbitration loss means that during the address phase of a transaction 1 or more i2c bus controllers attempted to perform an transaction and one of the i2c bus controllers, that isn't this one won out.</p> <p>Parameters:</p> <ul> <li><code>p_address</code> 7-bit address of the device you want to communicate with. To perform a transaction with a 10-bit address, this parameter must be the address upper byte of the 10-bit address OR'd with 0b1111'0000 (the 10-bit address indicator). The lower byte of the address must be contained in the first byte of the p_data_out span. </li> <li><code>p_data_out</code> data to be written to the addressed device. Set to nullptr with length zero in order to skip writing. </li> <li><code>p_data_in</code> buffer to store read data from the addressed device. Set to nullptr with length 0 in order to skip reading. </li> <li><code>p_timeout</code> callable which notifies the i2c driver that it has run out of time to perform the transaction and must stop and return control to the caller. </li> </ul> <p>Returns:</p> <p>result&lt;transaction_t&gt; - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::io_error</code> indicates that the i2c lines were put into an invalid state during the transaction due to interference, misconfiguration of the i2c peripheral or the addressed device or something else. </li> <li><code>std::errc::no_such_device_or_address</code> indicates that no devices on the bus acknowledge the address in this transaction, which could mean that the device is not connected to the bus, is not powered, not available to respond, broken or many other possible outcomes. </li> <li><code>std::errc::timed_out</code> if the transaction exceeded its time allotment indicated by p_timeout. </li> </ul>"},{"location":"api/classhal_1_1i2c/#function-i2c","title":"function ~i2c","text":"<pre><code>virtual hal::i2c::~i2c () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/i2c.hpp</code></p>"},{"location":"api/structhal_1_1i2c_1_1settings/","title":"Struct hal::i2c::settings","text":"<p>ClassList &gt; hal &gt; i2c &gt; settings</p> <p>Generic settings for a standard I2C device. </p> <ul> <li><code>#include &lt;i2c.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1i2c_1_1settings/#public-attributes","title":"Public Attributes","text":"Type Name hertz clock_rate   = = 100.0_kHzThe serial clock rate in hertz."},{"location":"api/structhal_1_1i2c_1_1settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1i2c_1_1settings/#variable-clock_rate","title":"variable clock_rate","text":"<pre><code>hertz hal::i2c::settings::clock_rate;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/i2c.hpp</code></p>"},{"location":"api/structhal_1_1i2c_1_1transaction__t/","title":"Struct hal::i2c::transaction_t","text":"<p>ClassList &gt; hal &gt; i2c &gt; transaction_t</p> <p>Feedback from performing a transaction on the i2c bus.More...</p> <ul> <li><code>#include &lt;i2c.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1i2c_1_1transaction__t/#detailed-description","title":"Detailed Description","text":"<p>This structure is currently empty as no feedback has been determined for now. This structure may be expanded in the future. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/i2c.hpp</code></p>"},{"location":"api/classhal_1_1input__pin/","title":"Class hal::input_pin","text":"<p>ClassList &gt; hal &gt; input_pin</p> <p>Digital input pin hardware abstraction interface. More...</p> <ul> <li><code>#include &lt;input_pin.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::lpc40::input_pin,  hal::mock::input_pin,  hal::soft::inert_input_pin,  hal::soft::input_pin_inverter</p>"},{"location":"api/classhal_1_1input__pin/#classes","title":"Classes","text":"Type Name struct level_t Input pin level reading structure. struct settings Generic settings for input pins."},{"location":"api/classhal_1_1input__pin/#public-functions","title":"Public Functions","text":"Type Name status configure (const settings &amp; p_settings) Configure the input pin to match the settings supplied. result&lt; level_t &gt; level () Read the state of the input pin. virtual ~input_pin () = default"},{"location":"api/classhal_1_1input__pin/#detailed-description","title":"Detailed Description","text":"<p>Use this to read a pin and determine if the voltage on it is HIGH or LOW. </p>"},{"location":"api/classhal_1_1input__pin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1input__pin/#function-configure","title":"function configure","text":"<p>Configure the input pin to match the settings supplied. <pre><code>inline status hal::input_pin::configure (\n    const settings &amp; p_settings\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_settings</code> - settings to apply to input pin </li> </ul> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::invalid_argument</code> if the settings could not be achieved. </li> </ul>"},{"location":"api/classhal_1_1input__pin/#function-level","title":"function level","text":"<p>Read the state of the input pin. <pre><code>inline result&lt; level_t &gt; hal::input_pin::level () \n</code></pre></p> <p>Returns:</p> <p>result&lt;bool&gt; - true indicates HIGH voltage level and false indicates LOW voltage level </p>"},{"location":"api/classhal_1_1input__pin/#function-input_pin","title":"function ~input_pin","text":"<pre><code>virtual hal::input_pin::~input_pin () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/input_pin.hpp</code></p>"},{"location":"api/structhal_1_1input__pin_1_1level__t/","title":"Struct hal::input_pin::level_t","text":"<p>ClassList &gt; hal &gt; input_pin &gt; level_t</p> <p>Input pin level reading structure. </p> <ul> <li><code>#include &lt;input_pin.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1input__pin_1_1level__t/#public-attributes","title":"Public Attributes","text":"Type Name bool state Measured state of the pin."},{"location":"api/structhal_1_1input__pin_1_1level__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1input__pin_1_1level__t/#variable-state","title":"variable state","text":"<pre><code>bool hal::input_pin::level_t::state;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/input_pin.hpp</code></p>"},{"location":"api/structhal_1_1input__pin_1_1settings/","title":"Struct hal::input_pin::settings","text":"<p>ClassList &gt; hal &gt; input_pin &gt; settings</p> <p>Generic settings for input pins. </p> <ul> <li><code>#include &lt;input_pin.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1input__pin_1_1settings/#public-attributes","title":"Public Attributes","text":"Type Name pin_resistor resistor   = = pin_resistor::pull_upPull resistor for an input pin."},{"location":"api/structhal_1_1input__pin_1_1settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1input__pin_1_1settings/#variable-resistor","title":"variable resistor","text":"<pre><code>pin_resistor hal::input_pin::settings::resistor;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/input_pin.hpp</code></p>"},{"location":"api/classhal_1_1interrupt__pin/","title":"Class hal::interrupt_pin","text":"<p>ClassList &gt; hal &gt; interrupt_pin</p> <p>Digital interrupt pin hardware abstraction. More...</p> <ul> <li><code>#include &lt;interrupt_pin.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::lpc40::interrupt_pin,  hal::mock::interrupt_pin,  hal::soft::inert_interrupt_pin</p>"},{"location":"api/classhal_1_1interrupt__pin/#classes","title":"Classes","text":"Type Name struct settings Generic settings for interrupt pins."},{"location":"api/classhal_1_1interrupt__pin/#public-types","title":"Public Types","text":"Type Name typedef void(bool p_state) handler Interrupt pin handler. enum trigger_edge The condition in which an interrupt it's triggered."},{"location":"api/classhal_1_1interrupt__pin/#public-functions","title":"Public Functions","text":"Type Name status configure (const settings &amp; p_settings) Configure the interrupt pin to match the settings supplied. void on_trigger (hal::callback&lt; handler &gt; p_callback) Set the callback for when the interrupt occurs. virtual ~interrupt_pin () = default"},{"location":"api/classhal_1_1interrupt__pin/#detailed-description","title":"Detailed Description","text":"<p>Use this to automatically call a function when a pin's state has transitioned.</p> <p>The transition states are:</p> <ul> <li>falling edge: the pin reads a transitions from HIGH to LOW</li> <li>rising edge: the pin reads a transitions from LOW to HIGH</li> <li>both: the pin reads any state change </li> </ul>"},{"location":"api/classhal_1_1interrupt__pin/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classhal_1_1interrupt__pin/#typedef-handler","title":"typedef handler","text":"<p>Interrupt pin handler. <pre><code>using hal::interrupt_pin::handler =  void(bool p_state);\n</code></pre></p> <p>param p_state - if true state of the pin when the interrupt was triggered was HIGH, otherwise LOW </p>"},{"location":"api/classhal_1_1interrupt__pin/#enum-trigger_edge","title":"enum trigger_edge","text":"<pre><code>enum hal::interrupt_pin::trigger_edge {\n    falling = 0,\n    rising = 1,\n    both = 2\n};\n</code></pre>"},{"location":"api/classhal_1_1interrupt__pin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1interrupt__pin/#function-configure","title":"function configure","text":"<p>Configure the interrupt pin to match the settings supplied. <pre><code>inline status hal::interrupt_pin::configure (\n    const settings &amp; p_settings\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_settings</code> - settings to apply to interrupt pin </li> </ul> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::invalid_argument</code> if the settings could not be achieved. </li> </ul>"},{"location":"api/classhal_1_1interrupt__pin/#function-on_trigger","title":"function on_trigger","text":"<p>Set the callback for when the interrupt occurs. <pre><code>inline void hal::interrupt_pin::on_trigger (\n    hal::callback &lt; handler &gt; p_callback\n) \n</code></pre></p> <p>Any state transitions before this function is called are lost.</p> <p>Parameters:</p> <ul> <li><code>p_callback</code> - function to execute when the trigger condition occurs. </li> </ul>"},{"location":"api/classhal_1_1interrupt__pin/#function-interrupt_pin","title":"function ~interrupt_pin","text":"<pre><code>virtual hal::interrupt_pin::~interrupt_pin () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/interrupt_pin.hpp</code></p>"},{"location":"api/structhal_1_1interrupt__pin_1_1settings/","title":"Struct hal::interrupt_pin::settings","text":"<p>ClassList &gt; hal &gt; interrupt_pin &gt; settings</p> <p>Generic settings for interrupt pins. </p> <ul> <li><code>#include &lt;interrupt_pin.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1interrupt__pin_1_1settings/#public-attributes","title":"Public Attributes","text":"Type Name pin_resistor resistor   = = pin_resistor::pull_upPull resistor for an interrupt pin. trigger_edge trigger   = = trigger_edge::risingThe trigger condition that will signal the system to run the callback."},{"location":"api/structhal_1_1interrupt__pin_1_1settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1interrupt__pin_1_1settings/#variable-resistor","title":"variable resistor","text":"<p>Pull resistor for an interrupt pin. <pre><code>pin_resistor hal::interrupt_pin::settings::resistor;\n</code></pre></p> <p>In general, it is highly advised to either set the pull resistor to something other than \"none\" or to attach an external pull up resistor to the interrupt pin in order to prevent random interrupt from firing. </p>"},{"location":"api/structhal_1_1interrupt__pin_1_1settings/#variable-trigger","title":"variable trigger","text":"<pre><code>trigger_edge hal::interrupt_pin::settings::trigger;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/interrupt_pin.hpp</code></p>"},{"location":"api/namespacehal_1_1literals/","title":"Namespace hal::literals","text":"<p>Namespace List &gt; hal &gt; literals</p> <p>Namespace containing user defined literals for the hal standard units. </p>"},{"location":"api/namespacehal_1_1literals/#public-functions","title":"Public Functions","text":"Type Name consteval ampere operator\"\"_A (long double p_value) noexcept consteval celsius operator\"\"_C (long double p_value) noexcept consteval celsius operator\"\"_F (long double p_value) noexcept consteval hertz operator\"\"_GHz (long double p_value) noexcept consteval hertz operator\"\"_Hz (long double p_value) noexcept consteval celsius operator\"\"_K (long double p_value) noexcept consteval hertz operator\"\"_MHz (long double p_value) noexcept consteval volts operator\"\"_V (long double p_value) noexcept consteval degrees operator\"\"_deg (long double p_value) noexcept consteval rpm operator\"\"_deg_per_sec (long double p_value) noexcept consteval g_force operator\"\"_g (long double p_value) noexcept consteval meters operator\"\"_inch (long double p_value) noexcept consteval ampere operator\"\"_kA (long double p_value) noexcept consteval hertz operator\"\"_kHz (long double p_value) noexcept consteval volts operator\"\"_kV (long double p_value) noexcept consteval meters operator\"\"_km (long double p_value) noexcept consteval meters operator\"\"_m (long double p_value) noexcept consteval ampere operator\"\"_mA (long double p_value) noexcept consteval volts operator\"\"_mV (long double p_value) noexcept consteval meters operator\"\"_miles (long double p_value) noexcept consteval meters operator\"\"_mm (long double p_value) noexcept consteval rpm operator\"\"_rpm (long double p_value) noexcept consteval ampere operator\"\"_uA (long double p_value) noexcept consteval volts operator\"\"_uV (long double p_value) noexcept consteval meters operator\"\"_um (long double p_value) noexcept consteval meters operator\"\"_yards (long double p_value) noexcept"},{"location":"api/namespacehal_1_1literals/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacehal_1_1literals/#function-operator_a","title":"function operator\"\"_A","text":"<pre><code>consteval ampere hal::literals::operator\"\"_A (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_c","title":"function operator\"\"_C","text":"<pre><code>consteval celsius hal::literals::operator\"\"_C (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_f","title":"function operator\"\"_F","text":"<pre><code>consteval celsius hal::literals::operator\"\"_F (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_ghz","title":"function operator\"\"_GHz","text":"<pre><code>consteval hertz hal::literals::operator\"\"_GHz (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_hz","title":"function operator\"\"_Hz","text":"<pre><code>consteval hertz hal::literals::operator\"\"_Hz (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_k","title":"function operator\"\"_K","text":"<pre><code>consteval celsius hal::literals::operator\"\"_K (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_mhz","title":"function operator\"\"_MHz","text":"<pre><code>consteval hertz hal::literals::operator\"\"_MHz (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_v","title":"function operator\"\"_V","text":"<pre><code>consteval volts hal::literals::operator\"\"_V (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_deg","title":"function operator\"\"_deg","text":"<pre><code>consteval degrees hal::literals::operator\"\"_deg (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_deg_per_sec","title":"function operator\"\"_deg_per_sec","text":"<pre><code>consteval rpm hal::literals::operator\"\"_deg_per_sec (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_g","title":"function operator\"\"_g","text":"<pre><code>consteval g_force hal::literals::operator\"\"_g (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_inch","title":"function operator\"\"_inch","text":"<pre><code>consteval meters hal::literals::operator\"\"_inch (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_ka","title":"function operator\"\"_kA","text":"<pre><code>consteval ampere hal::literals::operator\"\"_kA (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_khz","title":"function operator\"\"_kHz","text":"<pre><code>consteval hertz hal::literals::operator\"\"_kHz (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_kv","title":"function operator\"\"_kV","text":"<pre><code>consteval volts hal::literals::operator\"\"_kV (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_km","title":"function operator\"\"_km","text":"<pre><code>consteval meters hal::literals::operator\"\"_km (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_m","title":"function operator\"\"_m","text":"<pre><code>consteval meters hal::literals::operator\"\"_m (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_ma","title":"function operator\"\"_mA","text":"<pre><code>consteval ampere hal::literals::operator\"\"_mA (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_mv","title":"function operator\"\"_mV","text":"<pre><code>consteval volts hal::literals::operator\"\"_mV (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_miles","title":"function operator\"\"_miles","text":"<pre><code>consteval meters hal::literals::operator\"\"_miles (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_mm","title":"function operator\"\"_mm","text":"<pre><code>consteval meters hal::literals::operator\"\"_mm (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_rpm","title":"function operator\"\"_rpm","text":"<pre><code>consteval rpm hal::literals::operator\"\"_rpm (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_ua","title":"function operator\"\"_uA","text":"<pre><code>consteval ampere hal::literals::operator\"\"_uA (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_uv","title":"function operator\"\"_uV","text":"<pre><code>consteval volts hal::literals::operator\"\"_uV (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_um","title":"function operator\"\"_um","text":"<pre><code>consteval meters hal::literals::operator\"\"_um (\n    long double p_value\n) noexcept\n</code></pre>"},{"location":"api/namespacehal_1_1literals/#function-operator_yards","title":"function operator\"\"_yards","text":"<pre><code>consteval meters hal::literals::operator\"\"_yards (\n    long double p_value\n) noexcept\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/units.hpp</code></p>"},{"location":"api/namespacehal_1_1lpc40/","title":"Namespace hal::lpc40","text":"<p>Namespace List &gt; hal &gt; lpc40</p> <p>libhal drivers for the lpc40 series of microcontrollers from NXP</p>"},{"location":"api/namespacehal_1_1lpc40/#classes","title":"Classes","text":"Type Name class adc Analog to digital converter. class can class clock Allows user code to manipulate and retrieve the various system clocks speeds. class i2c class input_pin Input pin implementation for the lpc40xx. class interrupt_pin Interrupt pin implementation for the lpc40xx. class output_pin Output pin implementation for the lpc40xx. class pin lpc40xx pin multiplexing and control driver used drivers and apps seeking to tune the pins. class power Power control for lpc40xx peripherals. class pwm pwm driver for the lpc40xx series of micro controllers class spi class uart Implementation of the UART peripheral for the LPC40xx family of microcontrollers."},{"location":"api/namespacehal_1_1lpc40/#public-types","title":"Public Types","text":"Type Name enum error_t Set of lpc40 specific error types. enum std::uint16_t irq List of interrupt request numbers for this platform. enum std::uint8_t peripheral List of each peripheral and their power on id number for this platform."},{"location":"api/namespacehal_1_1lpc40/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacehal_1_1lpc40/#enum-error_t","title":"enum error_t","text":"<pre><code>enum hal::lpc40::error_t {\n    requires_usage_of_external_oscillator,\n    baud_rate_impossible\n};\n</code></pre>"},{"location":"api/namespacehal_1_1lpc40/#enum-irq","title":"enum irq","text":"<pre><code>enum hal::lpc40::irq {\n    wdt = 16 + 0,\n    timer0 = 16 + 1,\n    timer1 = 16 + 2,\n    timer2 = 16 + 3,\n    timer3 = 16 + 4,\n    uart0 = 16 + 5,\n    uart1 = 16 + 6,\n    uart2 = 16 + 7,\n    uart3 = 16 + 8,\n    pwm1 = 16 + 9,\n    i2c0 = 16 + 10,\n    i2c1 = 16 + 11,\n    i2c2 = 16 + 12,\n    reserved0 = 16 + 13,\n    ssp0 = 16 + 14,\n    ssp1 = 16 + 15,\n    pll0 = 16 + 16,\n    rtc = 16 + 17,\n    eint0 = 16 + 18,\n    eint1 = 16 + 19,\n    eint2 = 16 + 20,\n    eint3 = 16 + 21,\n    adc = 16 + 22,\n    bod = 16 + 23,\n    usb = 16 + 24,\n    can = 16 + 25,\n    dma = 16 + 26,\n    i2s = 16 + 27,\n    enet = 16 + 28,\n    mci = 16 + 29,\n    mcpwm = 16 + 30,\n    qei = 16 + 31,\n    pll1 = 16 + 32,\n    usbactivity = 16 + 33,\n    canactivity = 16 + 34,\n    uart4 = 16 + 35,\n    ssp2 = 16 + 36,\n    lcd = 16 + 37,\n    gpio = 16 + 38,\n    pwm0 = 16 + 39,\n    eeprom = 16 + 40,\n    cmp0 = 16 + 41,\n    cmp1 = 16 + 42,\n    max\n};\n</code></pre>"},{"location":"api/namespacehal_1_1lpc40/#enum-peripheral","title":"enum peripheral","text":"<pre><code>enum hal::lpc40::peripheral {\n    lcd = 0,\n    timer0 = 1,\n    timer1 = 2,\n    uart0 = 3,\n    uart1 = 4,\n    pwm0 = 5,\n    pwm1 = 6,\n    i2c0 = 7,\n    uart4 = 8,\n    rtc = 9,\n    ssp1 = 10,\n    emc = 11,\n    adc = 12,\n    can1 = 13,\n    can2 = 14,\n    gpio = 15,\n    spifi = 16,\n    motor_control_pwm = 17,\n    quadrature_encoder = 18,\n    i2c1 = 19,\n    ssp2 = 20,\n    ssp0 = 21,\n    timer2 = 22,\n    timer3 = 23,\n    uart2 = 24,\n    uart3 = 25,\n    i2c2 = 26,\n    i2s = 27,\n    sdcard = 28,\n    gpdma = 29,\n    ethernet = 30,\n    usb = 31,\n    cpu\n};\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/adc.hpp</code></p>"},{"location":"api/classhal_1_1lpc40_1_1adc/","title":"Class hal::lpc40::adc","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; adc</p> <p>Analog to digital converter. </p> <ul> <li><code>#include &lt;adc.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::adc</p>"},{"location":"api/classhal_1_1lpc40_1_1adc/#classes","title":"Classes","text":"Type Name struct channel Channel specific information."},{"location":"api/classhal_1_1lpc40_1_1adc/#public-functions","title":"Public Functions","text":"Type Name virtual ~adc () = default"},{"location":"api/classhal_1_1lpc40_1_1adc/#public-functions-inherited-from-haladc","title":"Public Functions inherited from hal::adc","text":"<p>See hal::adc</p> Type Name result&lt; read_t &gt; read () Sample the analog to digital converter and return the result. virtual ~adc () = default"},{"location":"api/classhal_1_1lpc40_1_1adc/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; adc &gt; construct_custom_channel (const channel &amp; p_channel) Construct a custom adc object based on the passed in channel information. result&lt; adc &gt; get (size_t p_channel) Get a predefined adc channel."},{"location":"api/classhal_1_1lpc40_1_1adc/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1adc/#function-adc","title":"function ~adc","text":"<pre><code>virtual hal::lpc40::adc::~adc () = default\n</code></pre> <p>Implements hal::adc::~adc</p>"},{"location":"api/classhal_1_1lpc40_1_1adc/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1adc/#function-construct_custom_channel","title":"function construct_custom_channel","text":"<p>Construct a custom adc object based on the passed in channel information. <pre><code>static result&lt; adc &gt; hal::lpc40::adc::construct_custom_channel (\n    const channel &amp; p_channel\n) \n</code></pre></p> <p>Care should be taken to ensure that the adc's operating frequency does not go above 1MHz and that the the channel index is within the bounds of 0 to 7. Exceeding these bounds will result in a call to std::abort.</p> <p>Care should also be taken to ensure that two adc's constructed via this method do not overlap in index.</p> <p>The operating frequency is shared across all adc channels, which means that the last adc to be constructed will set sampling frequency for all channels.</p> <p>Parameters:</p> <ul> <li><code>p_channel</code> - Which adc channel to return </li> </ul> <p>Returns:</p> <p>result&lt;adc&gt; - adc driver object </p>"},{"location":"api/classhal_1_1lpc40_1_1adc/#function-get","title":"function get","text":"<p>Get a predefined adc channel. <pre><code>static result&lt; adc &gt; hal::lpc40::adc::get (\n    size_t p_channel\n) \n</code></pre></p> <ul> <li>ADC channel 0 is pin(0, 23)</li> <li>ADC channel 1 is pin(0, 24)</li> <li>ADC channel 2 is pin(0, 25)</li> <li>ADC channel 3 is pin(0, 26)</li> <li>ADC channel 4 is pin(1, 30)</li> <li>ADC channel 5 is pin(1, 31)</li> <li>ADC channel 6 is pin(0, 12)</li> <li>ADC channel 7 is pin(0, 13)</li> </ul> <p>Parameters:</p> <ul> <li><code>p_channel</code> - Which adc channel to return </li> </ul> <p>Returns:</p> <p>result&lt;adc&gt; - adc driver object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/adc.hpp</code></p>"},{"location":"api/structhal_1_1lpc40_1_1adc_1_1channel/","title":"Struct hal::lpc40::adc::channel","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; adc &gt; channel</p> <p>Channel specific information. </p> <ul> <li><code>#include &lt;adc.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1lpc40_1_1adc_1_1channel/#public-attributes","title":"Public Attributes","text":"Type Name pin adc_pin ADC pin. hertz clock_rate   = = 1'000'000.0f uint8_t index Channel data index. uint8_t pin_function Pin mux function code."},{"location":"api/structhal_1_1lpc40_1_1adc_1_1channel/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1lpc40_1_1adc_1_1channel/#variable-adc_pin","title":"variable adc_pin","text":"<pre><code>pin hal::lpc40::adc::channel::adc_pin;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1adc_1_1channel/#variable-clock_rate","title":"variable clock_rate","text":"<pre><code>hertz hal::lpc40::adc::channel::clock_rate;\n</code></pre> <p>Default and highest sampling rate is 1 MHz. Careful as changing this for one channel changes this for all channels on the lpc40xx mcu. </p>"},{"location":"api/structhal_1_1lpc40_1_1adc_1_1channel/#variable-index","title":"variable index","text":"<pre><code>uint8_t hal::lpc40::adc::channel::index;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1adc_1_1channel/#variable-pin_function","title":"variable pin_function","text":"<pre><code>uint8_t hal::lpc40::adc::channel::pin_function;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/adc.hpp</code></p>"},{"location":"api/classhal_1_1lpc40_1_1can/","title":"Class hal::lpc40::can","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; can</p> <p>Inherits the following classes: hal::can</p>"},{"location":"api/classhal_1_1lpc40_1_1can/#classes","title":"Classes","text":"Type Name struct port"},{"location":"api/classhal_1_1lpc40_1_1can/#public-types-inherited-from-halcan","title":"Public Types inherited from hal::can","text":"<p>See hal::can</p> Type Name typedef void(const message_t &amp;p_message) handler Receive handler for can messages. typedef uint32_t id_t Can message ID type trait."},{"location":"api/classhal_1_1lpc40_1_1can/#public-functions","title":"Public Functions","text":"Type Name can (can &amp; p_other) = delete can (can &amp;&amp; p_other) noexcept can &amp; operator= (can &amp; p_other) = delete can &amp; operator= (can &amp;&amp; p_other) noexcept virtual ~can ()"},{"location":"api/classhal_1_1lpc40_1_1can/#public-functions-inherited-from-halcan","title":"Public Functions inherited from hal::can","text":"<p>See hal::can</p> Type Name status bus_on () Transition the CAN device from \"bus-off\" to \"bus-on\". status configure (const settings &amp; p_settings) Configure this can bus port to match the settings supplied. void on_receive (hal::callback&lt; handler &gt; p_handler) Set the message reception handler. result&lt; send_t &gt; send (const message_t &amp; p_message) Send a can message. virtual ~can () = default"},{"location":"api/classhal_1_1lpc40_1_1can/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; can &gt; get (std::uint8_t p_port, const can::settings &amp; p_settings={})"},{"location":"api/classhal_1_1lpc40_1_1can/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1can/#function-can-13","title":"function can [1/3]","text":"<pre><code>hal::lpc40::can::can (\n    can &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1can/#function-can-23","title":"function can [2/3]","text":"<pre><code>hal::lpc40::can::can (\n    can &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1can/#function-operator","title":"function operator=","text":"<pre><code>can &amp; hal::lpc40::can::operator= (\n    can &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1can/#function-operator_1","title":"function operator=","text":"<pre><code>can &amp; hal::lpc40::can::operator= (\n    can &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1can/#function-can","title":"function ~can","text":"<pre><code>virtual hal::lpc40::can::~can () \n</code></pre> <p>Implements hal::can::~can</p>"},{"location":"api/classhal_1_1lpc40_1_1can/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1can/#function-get","title":"function get","text":"<pre><code>static result&lt; can &gt; hal::lpc40::can::get (\n    std::uint8_t p_port,\n    const can::settings &amp; p_settings={}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/can.hpp</code></p>"},{"location":"api/structhal_1_1lpc40_1_1can_1_1port/","title":"Struct hal::lpc40::can::port","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; can &gt; port</p> <p>More...</p> <ul> <li><code>#include &lt;can.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1lpc40_1_1can_1_1port/#public-attributes","title":"Public Attributes","text":"Type Name peripheral id Peripheral's ID. irq irq_number IRQ. pin rd Reference to read pin object. std::uint8_t rd_function_code Pin function code for receive. std::uint8_t sync_jump   = = 0Number of time quanta for sync bits - 1. pin td Reference to transmit pin object. std::uint8_t td_function_code Pin function code for transmit. std::uint8_t tseg1   = = 6Number of time quanta for tseg1 - 1. std::uint8_t tseg2   = = 1Number of time quanta for tseg2 - 1."},{"location":"api/structhal_1_1lpc40_1_1can_1_1port/#detailed-description","title":"Detailed Description","text":"<p>Contains all of the information for to control and configure a CAN BUS bus on the LPC40xx platform. </p>"},{"location":"api/structhal_1_1lpc40_1_1can_1_1port/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1lpc40_1_1can_1_1port/#variable-id","title":"variable id","text":"<pre><code>peripheral hal::lpc40::can::port::id;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1can_1_1port/#variable-irq_number","title":"variable irq_number","text":"<pre><code>irq hal::lpc40::can::port::irq_number;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1can_1_1port/#variable-rd","title":"variable rd","text":"<pre><code>pin hal::lpc40::can::port::rd;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1can_1_1port/#variable-rd_function_code","title":"variable rd_function_code","text":"<pre><code>std::uint8_t hal::lpc40::can::port::rd_function_code;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1can_1_1port/#variable-sync_jump","title":"variable sync_jump","text":"<pre><code>std::uint8_t hal::lpc40::can::port::sync_jump;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1can_1_1port/#variable-td","title":"variable td","text":"<pre><code>pin hal::lpc40::can::port::td;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1can_1_1port/#variable-td_function_code","title":"variable td_function_code","text":"<pre><code>std::uint8_t hal::lpc40::can::port::td_function_code;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1can_1_1port/#variable-tseg1","title":"variable tseg1","text":"<pre><code>std::uint8_t hal::lpc40::can::port::tseg1;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1can_1_1port/#variable-tseg2","title":"variable tseg2","text":"<pre><code>std::uint8_t hal::lpc40::can::port::tseg2;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/can.hpp</code></p>"},{"location":"api/classhal_1_1lpc40_1_1clock/","title":"Class hal::lpc40::clock","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; clock</p> <p>Allows user code to manipulate and retrieve the various system clocks speeds. </p> <ul> <li><code>#include &lt;clock.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1lpc40_1_1clock/#classes","title":"Classes","text":"Type Name struct configuration Clock configuration object."},{"location":"api/classhal_1_1lpc40_1_1clock/#public-types","title":"Public Types","text":"Type Name enum uint32_t flash_configuration enum uint8_t spifi_clock_source spifi clock options enum uint8_t usb_clock_source USB oscillator source constants (not used) enum uint8_t usb_divider USB Clock divider constants."},{"location":"api/classhal_1_1lpc40_1_1clock/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint32_t default_peripheral_divider   = = 4The default clock divider for the peripheral clock. constexpr hertz irc_frequency   = = 12'000'000.0fThe frequency of the internal RC clock and the clock frequency at startup."},{"location":"api/classhal_1_1lpc40_1_1clock/#public-functions","title":"Public Functions","text":"Type Name configuration &amp; config () Get the clock config object. hertz get_frequency (peripheral p_peripheral) Get the operating frequency of the peripheral. status reconfigure_clocks () Apply the clock configuration to hardware."},{"location":"api/classhal_1_1lpc40_1_1clock/#public-static-functions","title":"Public Static Functions","text":"Type Name clock &amp; get () Get system clock object. status maximum (hertz p_external_crystal_frequency) Set the lpc40xx MCU to the maximum clock speed (120MHz) possible."},{"location":"api/classhal_1_1lpc40_1_1clock/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1clock/#enum-flash_configuration","title":"enum flash_configuration","text":"<pre><code>enum hal::lpc40::clock::flash_configuration {\n    clock1 = 0b0000 &lt;&lt; 12,\n    clock2 = 0b0001 &lt;&lt; 12,\n    clock3 = 0b0010 &lt;&lt; 12,\n    clock4 = 0b0011 &lt;&lt; 12,\n    clock5 = 0b0100 &lt;&lt; 12,\n    clock6 = 0b0101 &lt;&lt; 12\n};\n</code></pre> <p>Defines the codes for the flash access clock cycles required based on the CPU clocks speed. </p>"},{"location":"api/classhal_1_1lpc40_1_1clock/#enum-spifi_clock_source","title":"enum spifi_clock_source","text":"<pre><code>enum hal::lpc40::clock::spifi_clock_source {\n    system_clock = 0b00,\n    pll0 = 0b01,\n    pll1 = 0b10\n};\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1clock/#enum-usb_clock_source","title":"enum usb_clock_source","text":"<pre><code>enum hal::lpc40::clock::usb_clock_source {\n    system_clock = 0b00,\n    pll0 = 0b01,\n    pll1 = 0b10\n};\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1clock/#enum-usb_divider","title":"enum usb_divider","text":"<pre><code>enum hal::lpc40::clock::usb_divider {\n    divide_by1 = 0,\n    divide_by2,\n    divide_by3,\n    divide_by4\n};\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1clock/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1clock/#variable-default_peripheral_divider","title":"variable default_peripheral_divider","text":"<pre><code>constexpr uint32_t hal::lpc40::clock::default_peripheral_divider;\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1clock/#variable-irc_frequency","title":"variable irc_frequency","text":"<pre><code>constexpr hertz hal::lpc40::clock::irc_frequency;\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1clock/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1clock/#function-config","title":"function config","text":"<p>Get the clock config object. <pre><code>configuration &amp; hal::lpc40::clock::config () \n</code></pre></p> <p>Returns:</p> <p>configuration&amp; - reference to configuration object </p>"},{"location":"api/classhal_1_1lpc40_1_1clock/#function-get_frequency","title":"function get_frequency","text":"<p>Get the operating frequency of the peripheral. <pre><code>hertz hal::lpc40::clock::get_frequency (\n    peripheral p_peripheral\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_peripheral</code> - id of the peripheral </li> </ul> <p>Returns:</p> <p>frequency - operating frequency of the peripheral </p>"},{"location":"api/classhal_1_1lpc40_1_1clock/#function-reconfigure_clocks","title":"function reconfigure_clocks","text":"<p>Apply the clock configuration to hardware. <pre><code>status hal::lpc40::clock::reconfigure_clocks () \n</code></pre></p> <p>TODO(#65): explain the set of errors in better detail</p> <p>Returns:</p> <p>status - success or failure calculations could not be reached. </p>"},{"location":"api/classhal_1_1lpc40_1_1clock/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1clock/#function-get","title":"function get","text":"<p>Get system clock object. <pre><code>static clock &amp; hal::lpc40::clock::get () \n</code></pre></p> <p>All peripherals and application code should use this function and clock objects. Additional clock objects should not created outside of unit tests. Doing so will result in multiple objects with shared state.</p> <p>Returns:</p> <p>clock&amp; - return the system clock object </p>"},{"location":"api/classhal_1_1lpc40_1_1clock/#function-maximum","title":"function maximum","text":"<p>Set the lpc40xx MCU to the maximum clock speed (120MHz) possible. <pre><code>static status hal::lpc40::clock::maximum (\n    hertz p_external_crystal_frequency\n) \n</code></pre></p> <p>This function REQUIRES an external crystal to be used.</p> <ul> <li>CPU clock speed set to 120MHz</li> <li>USB clock speed set to 120MHz</li> <li>Peripheral clock set to 120MHZ</li> <li>SPIFI clock set to 120MHz</li> <li>PLL0 is set to 120MHz and used for everything</li> <li>PLL1 is disabled and not used</li> </ul> <p>Parameters:</p> <ul> <li><code>p_external_crystal_frequency</code> - frequency of the crystal connected to the XTAL1 &amp; XTAL2 </li> </ul> <p>Returns:</p> <p>status - whether or not the function failed to set the clock speed to the maximum. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/clock.hpp</code></p>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration/","title":"Struct hal::lpc40::clock::configuration","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; clock &gt; configuration</p> <p>Clock configuration object. </p> <ul> <li><code>#include &lt;clock.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration/#classes","title":"Classes","text":"Type Name struct cpu_t cpu clock control config struct struct pll_t phase locked loops config struct struct spifi_t spifi clock control config struct struct usb_t usb clock control config struct"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration/#public-attributes","title":"Public Attributes","text":"Type Name cpu_t cpu   = = {}cpu clock control bool emc_half_cpu_divider   = = false hertz oscillator_frequency   = = irc_frequencythe frequency of the input oscillator uint8_t peripheral_divider   = = 4Defines the peripheral clock divider amount. std::array&lt; pll_t, 2 &gt; pll   = = {}phase locked loops for both pll[0] and pll[1] spifi_t spifi   = = {}spifi clock control usb_t usb   = = {}usb clock control bool use_external_oscillator   = = falseset to true to use external XTC"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration/#variable-cpu","title":"variable cpu","text":"<pre><code>cpu_t hal::lpc40::clock::configuration::cpu;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration/#variable-emc_half_cpu_divider","title":"variable emc_half_cpu_divider","text":"<pre><code>bool hal::lpc40::clock::configuration::emc_half_cpu_divider;\n</code></pre> <p>Set true to make the EMC divider half as slow as the CPU divider. Set to false to set it to equal that amount. </p>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration/#variable-oscillator_frequency","title":"variable oscillator_frequency","text":"<pre><code>hertz hal::lpc40::clock::configuration::oscillator_frequency;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration/#variable-peripheral_divider","title":"variable peripheral_divider","text":"<pre><code>uint8_t hal::lpc40::clock::configuration::peripheral_divider;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration/#variable-pll","title":"variable pll","text":"<pre><code>std::array&lt;pll_t, 2&gt; hal::lpc40::clock::configuration::pll;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration/#variable-spifi","title":"variable spifi","text":"<pre><code>spifi_t hal::lpc40::clock::configuration::spifi;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration/#variable-usb","title":"variable usb","text":"<pre><code>usb_t hal::lpc40::clock::configuration::usb;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration/#variable-use_external_oscillator","title":"variable use_external_oscillator","text":"<pre><code>bool hal::lpc40::clock::configuration::use_external_oscillator;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/clock.hpp</code></p>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1cpu__t/","title":"Struct hal::lpc40::clock::configuration::cpu_t","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; clock &gt; configuration &gt; cpu_t</p> <p>cpu clock control config struct </p> <ul> <li><code>#include &lt;clock.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1cpu__t/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t divider   = = 1Divide the input clock from IRC or PLL0. bool use_pll0   = = false"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1cpu__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1cpu__t/#variable-divider","title":"variable divider","text":"<pre><code>uint8_t hal::lpc40::clock::configuration::cpu_t::divider;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1cpu__t/#variable-use_pll0","title":"variable use_pll0","text":"<pre><code>bool hal::lpc40::clock::configuration::cpu_t::use_pll0;\n</code></pre> <p>If true, use PLL0, if false, use system clock which is defined as 12MHz </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/clock.hpp</code></p>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1pll__t/","title":"Struct hal::lpc40::clock::configuration::pll_t","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; clock &gt; configuration &gt; pll_t</p> <p>phase locked loops config struct </p> <ul> <li><code>#include &lt;clock.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1pll__t/#public-attributes","title":"Public Attributes","text":"Type Name bool enabled   = = falseturn on/off a PLL uint8_t multiply   = = 1increase the frequency of the PLL by the multiple"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1pll__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1pll__t/#variable-enabled","title":"variable enabled","text":"<pre><code>bool hal::lpc40::clock::configuration::pll_t::enabled;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1pll__t/#variable-multiply","title":"variable multiply","text":"<pre><code>uint8_t hal::lpc40::clock::configuration::pll_t::multiply;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/clock.hpp</code></p>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1spifi__t/","title":"Struct hal::lpc40::clock::configuration::spifi_t","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; clock &gt; configuration &gt; spifi_t</p> <p>spifi clock control config struct </p> <ul> <li><code>#include &lt;clock.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1spifi__t/#public-attributes","title":"Public Attributes","text":"Type Name spifi_clock_source clock   = = spifi_clock_source::system_clockspifi clock source uint8_t divider   = = 1spifi clock divider"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1spifi__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1spifi__t/#variable-clock","title":"variable clock","text":"<pre><code>spifi_clock_source hal::lpc40::clock::configuration::spifi_t::clock;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1spifi__t/#variable-divider","title":"variable divider","text":"<pre><code>uint8_t hal::lpc40::clock::configuration::spifi_t::divider;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/clock.hpp</code></p>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1usb__t/","title":"Struct hal::lpc40::clock::configuration::usb_t","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; clock &gt; configuration &gt; usb_t</p> <p>usb clock control config struct </p> <ul> <li><code>#include &lt;clock.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1usb__t/#public-attributes","title":"Public Attributes","text":"Type Name usb_clock_source clock   = = usb_clock_source::system_clockusb clock source usb_divider divider   = = usb_divider::divide_by1usb clock divider"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1usb__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1usb__t/#variable-clock","title":"variable clock","text":"<pre><code>usb_clock_source hal::lpc40::clock::configuration::usb_t::clock;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1clock_1_1configuration_1_1usb__t/#variable-divider","title":"variable divider","text":"<pre><code>usb_divider hal::lpc40::clock::configuration::usb_t::divider;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/clock.hpp</code></p>"},{"location":"api/classhal_1_1lpc40_1_1i2c/","title":"Class hal::lpc40::i2c","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; i2c</p> <p>Inherits the following classes: hal::i2c</p>"},{"location":"api/classhal_1_1lpc40_1_1i2c/#classes","title":"Classes","text":"Type Name struct bus_info"},{"location":"api/classhal_1_1lpc40_1_1i2c/#public-types","title":"Public Types","text":"Type Name typedef std::span&lt; hal::byte &gt;::iterator read_iterator typedef std::span&lt; const hal::byte &gt;::iterator write_iterator"},{"location":"api/classhal_1_1lpc40_1_1i2c/#public-functions","title":"Public Functions","text":"Type Name i2c (i2c &amp; p_other) = delete i2c (i2c &amp;&amp; p_other) noexcept i2c &amp; operator= (i2c &amp; p_other) = delete i2c &amp; operator= (i2c &amp;&amp; p_other) noexcept virtual ~i2c ()"},{"location":"api/classhal_1_1lpc40_1_1i2c/#public-functions-inherited-from-hali2c","title":"Public Functions inherited from hal::i2c","text":"<p>See hal::i2c</p> Type Name status configure (const settings &amp; p_settings) Configure i2c to match the settings supplied. result&lt; transaction_t &gt; transaction (hal::byte p_address, std::span&lt; const hal::byte &gt; p_data_out, std::span&lt; hal::byte &gt; p_data_in, hal::function_ref&lt; hal::timeout_function &gt; p_timeout) perform an i2c transaction with another device on the bus. The type of transaction depends on values of input parameters. This function will block until the entire transfer is finished. virtual ~i2c () = default"},{"location":"api/classhal_1_1lpc40_1_1i2c/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; i2c &gt; get (std::uint8_t p_bus, const i2c::settings &amp; p_settings={})"},{"location":"api/classhal_1_1lpc40_1_1i2c/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1i2c/#typedef-read_iterator","title":"typedef read_iterator","text":"<pre><code>using hal::lpc40::i2c::read_iterator =  std::span&lt;hal::byte&gt;::iterator;\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1i2c/#typedef-write_iterator","title":"typedef write_iterator","text":"<pre><code>using hal::lpc40::i2c::write_iterator =  std::span&lt;const hal::byte&gt;::iterator;\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1i2c/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1i2c/#function-i2c-13","title":"function i2c [1/3]","text":"<pre><code>hal::lpc40::i2c::i2c (\n    i2c &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1i2c/#function-i2c-23","title":"function i2c [2/3]","text":"<pre><code>hal::lpc40::i2c::i2c (\n    i2c &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1i2c/#function-operator","title":"function operator=","text":"<pre><code>i2c &amp; hal::lpc40::i2c::operator= (\n    i2c &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1i2c/#function-operator_1","title":"function operator=","text":"<pre><code>i2c &amp; hal::lpc40::i2c::operator= (\n    i2c &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1i2c/#function-i2c","title":"function ~i2c","text":"<pre><code>virtual hal::lpc40::i2c::~i2c () \n</code></pre> <p>Implements hal::i2c::~i2c</p>"},{"location":"api/classhal_1_1lpc40_1_1i2c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1i2c/#function-get","title":"function get","text":"<pre><code>static result&lt; i2c &gt; hal::lpc40::i2c::get (\n    std::uint8_t p_bus,\n    const i2c::settings &amp; p_settings={}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/i2c.hpp</code></p>"},{"location":"api/structhal_1_1lpc40_1_1i2c_1_1bus__info/","title":"Struct hal::lpc40::i2c::bus_info","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; i2c &gt; bus_info</p> <p>More...</p> <ul> <li><code>#include &lt;i2c.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1lpc40_1_1i2c_1_1bus__info/#public-attributes","title":"Public Attributes","text":"Type Name float duty_cycle   = = 0.5fClock rate duty cycle. irq irq_number IRQ number for this i2c port. peripheral peripheral_id peripheral id used to power on the i2c peripheral at creation pin scl i2c clock pin std::uint8_t scl_function scl pin function code pin sda i2c data pin std::uint8_t sda_function sda pin function code"},{"location":"api/structhal_1_1lpc40_1_1i2c_1_1bus__info/#detailed-description","title":"Detailed Description","text":"<p>port holds all of the information for an i2c bus on the LPC40xx platform. </p>"},{"location":"api/structhal_1_1lpc40_1_1i2c_1_1bus__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1lpc40_1_1i2c_1_1bus__info/#variable-duty_cycle","title":"variable duty_cycle","text":"<pre><code>float hal::lpc40::i2c::bus_info::duty_cycle;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1i2c_1_1bus__info/#variable-irq_number","title":"variable irq_number","text":"<pre><code>irq hal::lpc40::i2c::bus_info::irq_number;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1i2c_1_1bus__info/#variable-peripheral_id","title":"variable peripheral_id","text":"<pre><code>peripheral hal::lpc40::i2c::bus_info::peripheral_id;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1i2c_1_1bus__info/#variable-scl","title":"variable scl","text":"<pre><code>pin hal::lpc40::i2c::bus_info::scl;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1i2c_1_1bus__info/#variable-scl_function","title":"variable scl_function","text":"<pre><code>std::uint8_t hal::lpc40::i2c::bus_info::scl_function;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1i2c_1_1bus__info/#variable-sda","title":"variable sda","text":"<pre><code>pin hal::lpc40::i2c::bus_info::sda;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1i2c_1_1bus__info/#variable-sda_function","title":"variable sda_function","text":"<pre><code>std::uint8_t hal::lpc40::i2c::bus_info::sda_function;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/i2c.hpp</code></p>"},{"location":"api/classhal_1_1lpc40_1_1input__pin/","title":"Class hal::lpc40::input_pin","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; input_pin</p> <p>Input pin implementation for the lpc40xx. </p> <ul> <li><code>#include &lt;input_pin.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::input_pin</p>"},{"location":"api/classhal_1_1lpc40_1_1input__pin/#public-functions-inherited-from-halinput_pin","title":"Public Functions inherited from hal::input_pin","text":"<p>See hal::input_pin</p> Type Name status configure (const settings &amp; p_settings) Configure the input pin to match the settings supplied. result&lt; level_t &gt; level () Read the state of the input pin. virtual ~input_pin () = default"},{"location":"api/classhal_1_1lpc40_1_1input__pin/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; input_pin &gt; get (std::uint8_t p_port, std::uint8_t p_pin, input_pin::settings p_settings={}) Get the input pin object."},{"location":"api/classhal_1_1lpc40_1_1input__pin/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1input__pin/#function-get","title":"function get","text":"<p>Get the input pin object. <pre><code>static result&lt; input_pin &gt; hal::lpc40::input_pin::get (\n    std::uint8_t p_port,\n    std::uint8_t p_pin,\n    input_pin::settings p_settings={}\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_port</code> - selects pin port to use </li> <li><code>p_pin</code> - selects pin within the port to use </li> <li><code>p_settings</code> - initial pin settings </li> </ul> <p>Returns:</p> <p>result&lt;input_pin&gt; - reference to a statically allocated input pin </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/input_pin.hpp</code></p>"},{"location":"api/classhal_1_1lpc40_1_1interrupt__pin/","title":"Class hal::lpc40::interrupt_pin","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; interrupt_pin</p> <p>Interrupt pin implementation for the lpc40xx. </p> <ul> <li><code>#include &lt;interrupt_pin.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::interrupt_pin</p>"},{"location":"api/classhal_1_1lpc40_1_1interrupt__pin/#public-types-inherited-from-halinterrupt_pin","title":"Public Types inherited from hal::interrupt_pin","text":"<p>See hal::interrupt_pin</p> Type Name typedef void(bool p_state) handler Interrupt pin handler. enum trigger_edge The condition in which an interrupt it's triggered."},{"location":"api/classhal_1_1lpc40_1_1interrupt__pin/#public-functions","title":"Public Functions","text":"Type Name interrupt_pin (interrupt_pin &amp; p_other) = delete interrupt_pin (interrupt_pin &amp;&amp; p_other) noexcept interrupt_pin &amp; operator= (interrupt_pin &amp; p_other) = delete interrupt_pin &amp; operator= (interrupt_pin &amp;&amp; p_other) noexcept virtual ~interrupt_pin ()"},{"location":"api/classhal_1_1lpc40_1_1interrupt__pin/#public-functions-inherited-from-halinterrupt_pin","title":"Public Functions inherited from hal::interrupt_pin","text":"<p>See hal::interrupt_pin</p> Type Name status configure (const settings &amp; p_settings) Configure the interrupt pin to match the settings supplied. void on_trigger (hal::callback&lt; handler &gt; p_callback) Set the callback for when the interrupt occurs. virtual ~interrupt_pin () = default"},{"location":"api/classhal_1_1lpc40_1_1interrupt__pin/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; interrupt_pin &gt; get (std::uint8_t port, std::uint8_t pin, settings p_settings={}) Get the interrupt pin object."},{"location":"api/classhal_1_1lpc40_1_1interrupt__pin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1interrupt__pin/#function-interrupt_pin-13","title":"function interrupt_pin [1/3]","text":"<pre><code>hal::lpc40::interrupt_pin::interrupt_pin (\n    interrupt_pin &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1interrupt__pin/#function-interrupt_pin-23","title":"function interrupt_pin [2/3]","text":"<pre><code>hal::lpc40::interrupt_pin::interrupt_pin (\n    interrupt_pin &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1interrupt__pin/#function-operator","title":"function operator=","text":"<pre><code>interrupt_pin &amp; hal::lpc40::interrupt_pin::operator= (\n    interrupt_pin &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1interrupt__pin/#function-operator_1","title":"function operator=","text":"<pre><code>interrupt_pin &amp; hal::lpc40::interrupt_pin::operator= (\n    interrupt_pin &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1interrupt__pin/#function-interrupt_pin","title":"function ~interrupt_pin","text":"<pre><code>virtual hal::lpc40::interrupt_pin::~interrupt_pin () \n</code></pre> <p>Implements hal::interrupt_pin::~interrupt_pin</p>"},{"location":"api/classhal_1_1lpc40_1_1interrupt__pin/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1interrupt__pin/#function-get","title":"function get","text":"<p>Get the interrupt pin object. <pre><code>static result&lt; interrupt_pin &gt; hal::lpc40::interrupt_pin::get (\n    std::uint8_t port,\n    std::uint8_t pin,\n    settings p_settings={}\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>port</code> - selects pin port to use </li> <li><code>pin</code> - selects pin within the port to use </li> <li><code>p_settings</code> - initial pin settings </li> </ul> <p>Returns:</p> <p>result&lt;interrupt_pin&gt; - interrupt pin driver object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/interrupt_pin.hpp</code></p>"},{"location":"api/classhal_1_1lpc40_1_1output__pin/","title":"Class hal::lpc40::output_pin","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; output_pin</p> <p>Output pin implementation for the lpc40xx. </p> <ul> <li><code>#include &lt;output_pin.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::output_pin</p>"},{"location":"api/classhal_1_1lpc40_1_1output__pin/#public-functions-inherited-from-haloutput_pin","title":"Public Functions inherited from hal::output_pin","text":"<p>See hal::output_pin</p> Type Name status configure (const settings &amp; p_settings) Configure the output pin to match the settings supplied. result&lt; set_level_t &gt; level (bool p_high) Set the state of the pin. result&lt; level_t &gt; level () Read the current state of the output pin. virtual ~output_pin () = default"},{"location":"api/classhal_1_1lpc40_1_1output__pin/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; output_pin &gt; get (std::uint8_t p_port, std::uint8_t p_pin, output_pin::settings p_settings={}) Get the output pin object."},{"location":"api/classhal_1_1lpc40_1_1output__pin/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1output__pin/#function-get","title":"function get","text":"<p>Get the output pin object. <pre><code>static result&lt; output_pin &gt; hal::lpc40::output_pin::get (\n    std::uint8_t p_port,\n    std::uint8_t p_pin,\n    output_pin::settings p_settings={}\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_port</code> - selects pin port to use </li> <li><code>p_pin</code> - selects which pin within the port to use </li> <li><code>p_settings</code> - initial pin settings </li> </ul> <p>Returns:</p> <p>result&lt;output_pin&gt; - reference to the statically allocated output pin </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/output_pin.hpp</code></p>"},{"location":"api/classhal_1_1lpc40_1_1pin/","title":"Class hal::lpc40::pin","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; pin</p> <p>lpc40xx pin multiplexing and control driver used drivers and apps seeking to tune the pins. </p> <ul> <li><code>#include &lt;pin.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1lpc40_1_1pin/#public-functions","title":"Public Functions","text":"Type Name const pin &amp; analog (bool p_enable) constenable analog mode for this pin (required for dac and adc drivers) const pin &amp; dac (bool p_enable=true) constEnable dac mode (required for the dac driver) const pin &amp; digital_filter (bool p_enable) constenable digital filtering (filter out noise on input lines) const pin &amp; function (uint8_t p_function_code) constChange the function of the pin (mux the pins function) const pin &amp; high_slew_rate (bool p_enable=true) constenable high slew rate for pin const pin &amp; highspeed_i2c (bool p_enable=true) constEnable high speed mode for i2c pins. const pin &amp; hysteresis (bool p_enable) constDisable or enable hysteresis mode for this pin. const pin &amp; i2c_high_current (bool p_enable=true) constenable high current drain for i2c lines const pin &amp; input_invert (bool p_enable) constinvert the logic for this pin in input mode const pin &amp; open_drain (bool p_enable=true) constMake the pin open drain (required for the i2c driver) constexpr pin (std::uint8_t p_port, std::uint8_t p_pin) Construct a new pin mux and configuration driver. constexpr pin () = defaultDefault constructor. const pin &amp; resistor (hal::pin_resistor p_resistor) constSet the internal resistor connection for this pin."},{"location":"api/classhal_1_1lpc40_1_1pin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1pin/#function-analog","title":"function analog","text":"<p>enable analog mode for this pin (required for dac and adc drivers) <pre><code>const pin &amp; hal::lpc40::pin::analog (\n    bool p_enable\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_enable</code> - enable this mode, set to false to disable this mode </li> </ul> <p>Returns:</p> <p>pin&amp; - reference to this pin for chaining </p>"},{"location":"api/classhal_1_1lpc40_1_1pin/#function-dac","title":"function dac","text":"<p>Enable dac mode (required for the dac driver) <pre><code>const pin &amp; hal::lpc40::pin::dac (\n    bool p_enable=true\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_enable</code> - enable this mode, set to false to disable this mode </li> </ul> <p>Returns:</p> <p>pin&amp; - reference to this pin for chaining </p>"},{"location":"api/classhal_1_1lpc40_1_1pin/#function-digital_filter","title":"function digital_filter","text":"<p>enable digital filtering (filter out noise on input lines) <pre><code>const pin &amp; hal::lpc40::pin::digital_filter (\n    bool p_enable\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_enable</code> - enable this mode, set to false to disable this mode </li> </ul> <p>Returns:</p> <p>pin&amp; - reference to this pin for chaining </p>"},{"location":"api/classhal_1_1lpc40_1_1pin/#function-function","title":"function function","text":"<p>Change the function of the pin (mux the pins function) <pre><code>const pin &amp; hal::lpc40::pin::function (\n    uint8_t p_function_code\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_function_code</code> - the pin function code </li> </ul> <p>Returns:</p> <p>pin&amp; - reference to this pin for chaining </p>"},{"location":"api/classhal_1_1lpc40_1_1pin/#function-high_slew_rate","title":"function high_slew_rate","text":"<p>enable high slew rate for pin <pre><code>const pin &amp; hal::lpc40::pin::high_slew_rate (\n    bool p_enable=true\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_enable</code> - enable this mode, set to false to disable this mode </li> </ul> <p>Returns:</p> <p>pin&amp; - reference to this pin for chaining </p>"},{"location":"api/classhal_1_1lpc40_1_1pin/#function-highspeed_i2c","title":"function highspeed_i2c","text":"<p>Enable high speed mode for i2c pins. <pre><code>const pin &amp; hal::lpc40::pin::highspeed_i2c (\n    bool p_enable=true\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_enable</code> - enable this mode, set to false to disable this mode </li> </ul> <p>Returns:</p> <p>pin&amp; - reference to this pin for chaining </p>"},{"location":"api/classhal_1_1lpc40_1_1pin/#function-hysteresis","title":"function hysteresis","text":"<p>Disable or enable hysteresis mode for this pin. <pre><code>const pin &amp; hal::lpc40::pin::hysteresis (\n    bool p_enable\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_enable</code> - enable this mode, set to false to disable this mode </li> </ul> <p>Returns:</p> <p>pin&amp; - reference to this pin for chaining </p>"},{"location":"api/classhal_1_1lpc40_1_1pin/#function-i2c_high_current","title":"function i2c_high_current","text":"<p>enable high current drain for i2c lines <pre><code>const pin &amp; hal::lpc40::pin::i2c_high_current (\n    bool p_enable=true\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_enable</code> - enable this mode, set to false to disable this mode </li> </ul> <p>Returns:</p> <p>pin&amp; - reference to this pin for chaining </p>"},{"location":"api/classhal_1_1lpc40_1_1pin/#function-input_invert","title":"function input_invert","text":"<p>invert the logic for this pin in input mode <pre><code>const pin &amp; hal::lpc40::pin::input_invert (\n    bool p_enable\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_enable</code> - enable this mode, set to false to disable this mode </li> </ul> <p>Returns:</p> <p>pin&amp; - reference to this pin for chaining </p>"},{"location":"api/classhal_1_1lpc40_1_1pin/#function-open_drain","title":"function open_drain","text":"<p>Make the pin open drain (required for the i2c driver) <pre><code>const pin &amp; hal::lpc40::pin::open_drain (\n    bool p_enable=true\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_enable</code> - enable this mode, set to false to disable this mode </li> </ul> <p>Returns:</p> <p>pin&amp; - reference to this pin for chaining </p>"},{"location":"api/classhal_1_1lpc40_1_1pin/#function-pin-12","title":"function pin [1/2]","text":"<p>Construct a new pin mux and configuration driver. <pre><code>inline constexpr hal::lpc40::pin::pin (\n    std::uint8_t p_port,\n    std::uint8_t p_pin\n) \n</code></pre></p> <p>See UM10562 page 99 for more details on which pins can be what function.</p> <p>Parameters:</p> <ul> <li><code>p_port</code> - selects pin port to use </li> <li><code>p_pin</code> - selects pin within the port to use </li> </ul>"},{"location":"api/classhal_1_1lpc40_1_1pin/#function-pin-22","title":"function pin [2/2]","text":"<pre><code>constexpr hal::lpc40::pin::pin () = default\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1pin/#function-resistor","title":"function resistor","text":"<p>Set the internal resistor connection for this pin. <pre><code>const pin &amp; hal::lpc40::pin::resistor (\n    hal::pin_resistor p_resistor\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_resistor</code> - resistor type </li> </ul> <p>Returns:</p> <p>pin&amp; - reference to this pin for chaining </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/pin.hpp</code></p>"},{"location":"api/classhal_1_1lpc40_1_1power/","title":"Class hal::lpc40::power","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; power</p> <p>Power control for lpc40xx peripherals. </p> <ul> <li><code>#include &lt;power.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1lpc40_1_1power/#public-functions","title":"Public Functions","text":"Type Name bool is_on () Check if the peripheral is powered on. void off () Power off peripheral. void on () Power on the peripheral. power (peripheral p_peripheral) Construct a new power control object."},{"location":"api/classhal_1_1lpc40_1_1power/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1power/#function-is_on","title":"function is_on","text":"<p>Check if the peripheral is powered on. <pre><code>bool hal::lpc40::power::is_on () \n</code></pre></p> <p>Returns:</p> <p>true - peripheral is on </p> <p>Returns:</p> <p>false - peripheral is off </p>"},{"location":"api/classhal_1_1lpc40_1_1power/#function-off","title":"function off","text":"<pre><code>void hal::lpc40::power::off () \n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1power/#function-on","title":"function on","text":"<pre><code>void hal::lpc40::power::on () \n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1power/#function-power","title":"function power","text":"<p>Construct a new power control object. <pre><code>hal::lpc40::power::power (\n    peripheral p_peripheral\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_peripheral</code> - id of the peripheral to configure </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/power.hpp</code></p>"},{"location":"api/classhal_1_1lpc40_1_1pwm/","title":"Class hal::lpc40::pwm","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; pwm</p> <p>pwm driver for the lpc40xx series of micro controllers More...</p> <ul> <li><code>#include &lt;pwm.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::pwm</p>"},{"location":"api/classhal_1_1lpc40_1_1pwm/#classes","title":"Classes","text":"Type Name struct channel Channel specific information."},{"location":"api/classhal_1_1lpc40_1_1pwm/#public-functions-inherited-from-halpwm","title":"Public Functions inherited from hal::pwm","text":"<p>See hal::pwm</p> Type Name result&lt; duty_cycle_t &gt; duty_cycle (float p_duty_cycle) Set the pwm waveform duty cycle. result&lt; frequency_t &gt; frequency (hertz p_frequency) Set the pwm waveform frequency. virtual ~pwm () = default"},{"location":"api/classhal_1_1lpc40_1_1pwm/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; pwm &gt; get (std::uint8_t p_peripheral, std::uint8_t p_channel) Get a pwm driver."},{"location":"api/classhal_1_1lpc40_1_1pwm/#detailed-description","title":"Detailed Description","text":"<p>This driver uses the dedicated PWM peripherals, PWM0, and PWM1 for generating pwm signals. Other methods would include using timers and the MotorPWM peripherals.</p> <p>NOTE: Channels within a PWM peripheral device are NOT independent. Meaning that changing the frequency of one channel changes the frequency for all channels within the peripheral block. </p>"},{"location":"api/classhal_1_1lpc40_1_1pwm/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1pwm/#function-get","title":"function get","text":"<p>Get a pwm driver. <pre><code>static result&lt; pwm &gt; hal::lpc40::pwm::get (\n    std::uint8_t p_peripheral,\n    std::uint8_t p_channel\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_peripheral</code> - Peripheral block, either 0 or 1 </li> <li><code>p_channel</code> - PWM output channel within the peripheral block, from 1 to 6. </li> </ul> <p>Returns:</p> <p>result&lt;pwm&amp;&gt; - reference to the pwm driver </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/pwm.hpp</code></p>"},{"location":"api/structhal_1_1lpc40_1_1pwm_1_1channel/","title":"Struct hal::lpc40::pwm::channel","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; pwm &gt; channel</p> <p>Channel specific information. </p> <ul> <li><code>#include &lt;pwm.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1lpc40_1_1pwm_1_1channel/#public-attributes","title":"Public Attributes","text":"Type Name uint8_t index Channel index. peripheral peripheral_id peripheral id used to power on the pwm peripheral at creation uint8_t pin_function Pin function code. pin pwm_pin Pin to output pwm from."},{"location":"api/structhal_1_1lpc40_1_1pwm_1_1channel/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1lpc40_1_1pwm_1_1channel/#variable-index","title":"variable index","text":"<pre><code>uint8_t hal::lpc40::pwm::channel::index;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1pwm_1_1channel/#variable-peripheral_id","title":"variable peripheral_id","text":"<pre><code>peripheral hal::lpc40::pwm::channel::peripheral_id;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1pwm_1_1channel/#variable-pin_function","title":"variable pin_function","text":"<pre><code>uint8_t hal::lpc40::pwm::channel::pin_function;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1pwm_1_1channel/#variable-pwm_pin","title":"variable pwm_pin","text":"<pre><code>pin hal::lpc40::pwm::channel::pwm_pin;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/pwm.hpp</code></p>"},{"location":"api/classhal_1_1lpc40_1_1spi/","title":"Class hal::lpc40::spi","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; spi</p> <p>Inherits the following classes: hal::spi</p>"},{"location":"api/classhal_1_1lpc40_1_1spi/#classes","title":"Classes","text":"Type Name struct bus_info Information used to configure the spi bus."},{"location":"api/classhal_1_1lpc40_1_1spi/#public-static-attributes-inherited-from-halspi","title":"Public Static Attributes inherited from hal::spi","text":"<p>See hal::spi</p> Type Name constexpr hal::byte default_filler   = = hal::byte"},{"location":"api/classhal_1_1lpc40_1_1spi/#public-functions","title":"Public Functions","text":"Type Name spi &amp; operator= (spi &amp; p_other) = delete spi &amp; operator= (spi &amp;&amp; p_other) noexcept spi (spi &amp; p_other) = delete spi (spi &amp;&amp; p_other) noexcept virtual ~spi ()"},{"location":"api/classhal_1_1lpc40_1_1spi/#public-functions-inherited-from-halspi","title":"Public Functions inherited from hal::spi","text":"<p>See hal::spi</p> Type Name status configure (const settings &amp; p_settings) Configure spi to match the settings supplied. result&lt; transfer_t &gt; transfer (std::span&lt; const hal::byte &gt; p_data_out, std::span&lt; hal::byte &gt; p_data_in, hal::byte p_filler=default_filler) Send and receive data between a selected device on the spi bus. This function will block until the entire transfer is finished. virtual ~spi () = default"},{"location":"api/classhal_1_1lpc40_1_1spi/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; spi &gt; get (std::uint8_t p_bus, const spi::settings &amp; p_settings={})"},{"location":"api/classhal_1_1lpc40_1_1spi/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1spi/#function-operator","title":"function operator=","text":"<pre><code>spi &amp; hal::lpc40::spi::operator= (\n    spi &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1spi/#function-operator_1","title":"function operator=","text":"<pre><code>spi &amp; hal::lpc40::spi::operator= (\n    spi &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1spi/#function-spi-13","title":"function spi [1/3]","text":"<pre><code>hal::lpc40::spi::spi (\n    spi &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1spi/#function-spi-23","title":"function spi [2/3]","text":"<pre><code>hal::lpc40::spi::spi (\n    spi &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1spi/#function-spi","title":"function ~spi","text":"<pre><code>virtual hal::lpc40::spi::~spi () \n</code></pre> <p>Implements hal::spi::~spi</p>"},{"location":"api/classhal_1_1lpc40_1_1spi/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1spi/#function-get","title":"function get","text":"<pre><code>static result&lt; spi &gt; hal::lpc40::spi::get (\n    std::uint8_t p_bus,\n    const spi::settings &amp; p_settings={}\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/spi.hpp</code></p>"},{"location":"api/structhal_1_1lpc40_1_1spi_1_1bus__info/","title":"Struct hal::lpc40::spi::bus_info","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; spi &gt; bus_info</p> <p>Information used to configure the spi bus. </p> <ul> <li><code>#include &lt;spi.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1lpc40_1_1spi_1_1bus__info/#public-attributes","title":"Public Attributes","text":"Type Name pin clock spi data pin std::uint8_t clock_function clock function code pin data_in spi clock pin std::uint8_t data_in_function scl pin function code pin data_out spi clock pin std::uint8_t data_out_function scl pin function code peripheral peripheral_id peripheral id used to power on the spi peripheral at creation"},{"location":"api/structhal_1_1lpc40_1_1spi_1_1bus__info/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1lpc40_1_1spi_1_1bus__info/#variable-clock","title":"variable clock","text":"<pre><code>pin hal::lpc40::spi::bus_info::clock;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1spi_1_1bus__info/#variable-clock_function","title":"variable clock_function","text":"<pre><code>std::uint8_t hal::lpc40::spi::bus_info::clock_function;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1spi_1_1bus__info/#variable-data_in","title":"variable data_in","text":"<pre><code>pin hal::lpc40::spi::bus_info::data_in;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1spi_1_1bus__info/#variable-data_in_function","title":"variable data_in_function","text":"<pre><code>std::uint8_t hal::lpc40::spi::bus_info::data_in_function;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1spi_1_1bus__info/#variable-data_out","title":"variable data_out","text":"<pre><code>pin hal::lpc40::spi::bus_info::data_out;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1spi_1_1bus__info/#variable-data_out_function","title":"variable data_out_function","text":"<pre><code>std::uint8_t hal::lpc40::spi::bus_info::data_out_function;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1spi_1_1bus__info/#variable-peripheral_id","title":"variable peripheral_id","text":"<pre><code>peripheral hal::lpc40::spi::bus_info::peripheral_id;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/spi.hpp</code></p>"},{"location":"api/classhal_1_1lpc40_1_1uart/","title":"Class hal::lpc40::uart","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; uart</p> <p>Implementation of the UART peripheral for the LPC40xx family of microcontrollers. More...</p> <ul> <li><code>#include &lt;uart.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::serial</p>"},{"location":"api/classhal_1_1lpc40_1_1uart/#classes","title":"Classes","text":"Type Name struct port"},{"location":"api/classhal_1_1lpc40_1_1uart/#public-functions","title":"Public Functions","text":"Type Name uart &amp; operator= (uart &amp; p_other) = delete uart &amp; operator= (uart &amp;&amp; p_other) noexcept uart (uart &amp; p_other) = delete uart (uart &amp;&amp; p_other) noexcept"},{"location":"api/classhal_1_1lpc40_1_1uart/#public-functions-inherited-from-halserial","title":"Public Functions inherited from hal::serial","text":"<p>See hal::serial</p> Type Name status configure (const settings &amp; p_settings) Configure serial to match the settings supplied. result&lt; flush_t &gt; flush () Flush working buffer. result&lt; read_t &gt; read (std::span&lt; hal::byte &gt; p_data) Copy bytes from working buffer into passed buffer. result&lt; write_t &gt; write (std::span&lt; const hal::byte &gt; p_data) Write data to the transmitter line of the serial port. virtual ~serial () = default"},{"location":"api/classhal_1_1lpc40_1_1uart/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; uart &gt; construct_custom (uart::port p_port, std::span&lt; hal::byte &gt; p_receive_working_buffer, serial::settings p_settings={})  result&lt; uart &gt; get (std::uint8_t p_port_number, std::span&lt; hal::byte &gt; p_receive_buffer, serial::settings p_settings={}) Retrieve a UART serial port."},{"location":"api/classhal_1_1lpc40_1_1uart/#detailed-description","title":"Detailed Description","text":"<p>Note:</p> <p>that the baud rates less than or equal to the peripheral clock frequency / 48. Otherwise this peripheral cannot guarantee proper transmission or receive of bytes. </p>"},{"location":"api/classhal_1_1lpc40_1_1uart/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1uart/#function-operator","title":"function operator=","text":"<pre><code>uart &amp; hal::lpc40::uart::operator= (\n    uart &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1uart/#function-operator_1","title":"function operator=","text":"<pre><code>uart &amp; hal::lpc40::uart::operator= (\n    uart &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1uart/#function-uart-13","title":"function uart [1/3]","text":"<pre><code>hal::lpc40::uart::uart (\n    uart &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1uart/#function-uart-23","title":"function uart [2/3]","text":"<pre><code>hal::lpc40::uart::uart (\n    uart &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1uart/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1lpc40_1_1uart/#function-construct_custom","title":"function construct_custom","text":"<pre><code>static result&lt; uart &gt; hal::lpc40::uart::construct_custom (\n    uart::port p_port,\n    std::span&lt; hal::byte &gt; p_receive_working_buffer,\n    serial::settings p_settings={}\n) \n</code></pre>"},{"location":"api/classhal_1_1lpc40_1_1uart/#function-get","title":"function get","text":"<p>Retrieve a UART serial port. <pre><code>static result&lt; uart &gt; hal::lpc40::uart::get (\n    std::uint8_t p_port_number,\n    std::span&lt; hal::byte &gt; p_receive_buffer,\n    serial::settings p_settings={}\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_port_number</code> - which uart port number to return </li> <li><code>p_receive_buffer</code> - uart serial receive working buffer </li> <li><code>p_settings</code> - the initial settings for the uart driver </li> </ul> <p>Returns:</p> <p>result&lt;uart&gt; - uart serial driver </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/uart.hpp</code></p>"},{"location":"api/structhal_1_1lpc40_1_1uart_1_1port/","title":"Struct hal::lpc40::uart::port","text":"<p>ClassList &gt; hal &gt; lpc40 &gt; uart &gt; port</p> <p>More...</p> <ul> <li><code>#include &lt;uart.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1lpc40_1_1uart_1_1port/#public-attributes","title":"Public Attributes","text":"Type Name peripheral id Resource ID of the UART peripheral to power on at initialization. irq irq_number Interrupt request number. pin rx Reference to a uart receiver pin. std::uint8_t rx_function Function code to set the receive pin to uart receiver. pin tx Reference to a uart transmitter pin. std::uint8_t tx_function Function code to set the transmit pin to uart transmitter."},{"location":"api/structhal_1_1lpc40_1_1uart_1_1port/#detailed-description","title":"Detailed Description","text":"<p>Port contains all of the information that the lpc40 uart port needs to operate. </p>"},{"location":"api/structhal_1_1lpc40_1_1uart_1_1port/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1lpc40_1_1uart_1_1port/#variable-id","title":"variable id","text":"<pre><code>peripheral hal::lpc40::uart::port::id;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1uart_1_1port/#variable-irq_number","title":"variable irq_number","text":"<pre><code>irq hal::lpc40::uart::port::irq_number;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1uart_1_1port/#variable-rx","title":"variable rx","text":"<pre><code>pin hal::lpc40::uart::port::rx;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1uart_1_1port/#variable-rx_function","title":"variable rx_function","text":"<pre><code>std::uint8_t hal::lpc40::uart::port::rx_function;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1uart_1_1port/#variable-tx","title":"variable tx","text":"<pre><code>pin hal::lpc40::uart::port::tx;\n</code></pre>"},{"location":"api/structhal_1_1lpc40_1_1uart_1_1port/#variable-tx_function","title":"variable tx_function","text":"<pre><code>std::uint8_t hal::lpc40::uart::port::tx_function;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/uart.hpp</code></p>"},{"location":"api/classhal_1_1magnetometer/","title":"Class hal::magnetometer","text":"<p>ClassList &gt; hal &gt; magnetometer</p> <p>Magnetic field strength sensing hardware abstraction interface. More...</p> <ul> <li><code>#include &lt;magnetometer.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::soft::inert_magnetometer</p>"},{"location":"api/classhal_1_1magnetometer/#classes","title":"Classes","text":"Type Name struct read_t Result from reading the accelerometer."},{"location":"api/classhal_1_1magnetometer/#public-functions","title":"Public Functions","text":"Type Name result&lt; read_t &gt; read () Read the latest magnetic field strength sensed by the device. virtual ~magnetometer () = default"},{"location":"api/classhal_1_1magnetometer/#detailed-description","title":"Detailed Description","text":"<p>Magnetometers are usually used for determining the strength of a magnetic field, or calculating compass headings. If the device that the magnetometer is mounted on, tends to move, or change its own orientation, then it is helpful to use an accelerometer or tilt sensor in order to determine appropriate heading for compass calculations. </p>"},{"location":"api/classhal_1_1magnetometer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1magnetometer/#function-read","title":"function read","text":"<p>Read the latest magnetic field strength sensed by the device. <pre><code>inline result&lt; read_t &gt; hal::magnetometer::read () \n</code></pre></p> <p>Returns:</p> <p>result&lt;read_t&gt; - magnetic field strength data </p>"},{"location":"api/classhal_1_1magnetometer/#function-magnetometer","title":"function ~magnetometer","text":"<pre><code>virtual hal::magnetometer::~magnetometer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/magnetometer.hpp</code></p>"},{"location":"api/structhal_1_1magnetometer_1_1read__t/","title":"Struct hal::magnetometer::read_t","text":"<p>ClassList &gt; hal &gt; magnetometer &gt; read_t</p> <p>Result from reading the accelerometer. </p> <ul> <li><code>#include &lt;magnetometer.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1magnetometer_1_1read__t/#public-attributes","title":"Public Attributes","text":"Type Name gauss x Magnetic field strength in the X axis, relative to the device's reference frame. gauss y Magnetic field strength in the Y axis, relative to the device's reference frame. gauss z Magnetic field strength in the Z axis, relative to the device's reference frame."},{"location":"api/structhal_1_1magnetometer_1_1read__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1magnetometer_1_1read__t/#variable-x","title":"variable x","text":"<pre><code>gauss hal::magnetometer::read_t::x;\n</code></pre>"},{"location":"api/structhal_1_1magnetometer_1_1read__t/#variable-y","title":"variable y","text":"<pre><code>gauss hal::magnetometer::read_t::y;\n</code></pre>"},{"location":"api/structhal_1_1magnetometer_1_1read__t/#variable-z","title":"variable z","text":"<pre><code>gauss hal::magnetometer::read_t::z;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/magnetometer.hpp</code></p>"},{"location":"api/namespacehal_1_1micromod/","title":"Namespace hal::micromod","text":"<p>Namespace List &gt; hal &gt; micromod</p>"},{"location":"api/namespacehal_1_1micromod/#namespaces","title":"Namespaces","text":"Type Name namespace v1 <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-micromod/micromod.hpp</code></p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/","title":"Namespace hal::micromod::v1","text":"<p>Namespace List &gt; hal &gt; micromod &gt; v1</p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#public-functions","title":"Public Functions","text":"Type Name hal::adc &amp; a0 () Driver for adc pin 0. hal::adc &amp; a1 () Driver for adc pin 1. hal::adc &amp; battery () Driver for battery analog signal which is 1/3rd of the VIN voltage. hal::can &amp; can () Driver for the can bus. hal::serial &amp; console (std::span&lt; hal::byte &gt; p_receive_buffer) Console serial interface. hal::dac &amp; d0 () Driver for dac pin 0. hal::dac &amp; d1 () Driver for dac pin 1. void enter_power_saving_mode () Enter power savings mode for your processor. hal::i2c &amp; i2c () Driver for the main i2c bus. hal::i2c &amp; i2c1 () Driver for the alternative i2c bus 1. hal::interrupt_pin &amp; i2c_interrupt_pin () Driver for i2c interrupt pin. void initialize_platform () Initialize the system. hal::input_pin &amp; input_g0 ()  hal::input_pin &amp; input_g1 ()  hal::input_pin &amp; input_g10 ()  hal::input_pin &amp; input_g2 ()  hal::input_pin &amp; input_g3 ()  hal::input_pin &amp; input_g4 ()  hal::input_pin &amp; input_g5 ()  hal::input_pin &amp; input_g6 ()  hal::input_pin &amp; input_g7 ()  hal::input_pin &amp; input_g8 ()  hal::input_pin &amp; input_g9 ()  hal::interrupt_pin &amp; interrupt_g0 ()  hal::interrupt_pin &amp; interrupt_g1 ()  hal::interrupt_pin &amp; interrupt_g10 ()  hal::interrupt_pin &amp; interrupt_g2 ()  hal::interrupt_pin &amp; interrupt_g3 ()  hal::interrupt_pin &amp; interrupt_g4 ()  hal::interrupt_pin &amp; interrupt_g5 ()  hal::interrupt_pin &amp; interrupt_g6 ()  hal::interrupt_pin &amp; interrupt_g7 ()  hal::interrupt_pin &amp; interrupt_g8 ()  hal::interrupt_pin &amp; interrupt_g9 ()  hal::output_pin &amp; led () Driver for the board LED output pin. hal::output_pin &amp; output_g0 ()  hal::output_pin &amp; output_g1 ()  hal::output_pin &amp; output_g10 ()  hal::output_pin &amp; output_g2 ()  hal::output_pin &amp; output_g3 ()  hal::output_pin &amp; output_g4 ()  hal::output_pin &amp; output_g5 ()  hal::output_pin &amp; output_g6 ()  hal::output_pin &amp; output_g7 ()  hal::output_pin &amp; output_g8 ()  hal::output_pin &amp; output_g9 ()  hal::pwm &amp; pwm0 () Driver for pwm pin 0. hal::pwm &amp; pwm1 () Driver for pwm pin 1. void reset () Resets the microcontroller, restarting the program in the process. hal::spi &amp; spi () Driver for the main spi bus. hal::spi &amp; spi1 () Driver for the alternative spi port 1. hal::interrupt_pin &amp; spi_interrupt_pin () Driver for spi interrupt pin. hal::timer &amp; system_timer () Get core system timer driver. hal::serial &amp; uart1 (std::span&lt; hal::byte &gt; p_receive_buffer) Driver for uart 1 port. hal::serial &amp; uart2 (std::span&lt; hal::byte &gt; p_receive_buffer) Driver for uart 0 port. hal::steady_clock &amp; uptime_clock () steady clock to measures the cycles the processor has been up."},{"location":"api/namespacehal_1_1micromod_1_1v1/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-a0","title":"function a0","text":"<p>Driver for adc pin 0. <pre><code>hal::adc &amp; hal::micromod::v1::a0 () \n</code></pre></p> <p>Returns:</p> <p>hal::adc&amp; - Statically allocated analog pin driver. </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-a1","title":"function a1","text":"<p>Driver for adc pin 1. <pre><code>hal::adc &amp; hal::micromod::v1::a1 () \n</code></pre></p> <p>Returns:</p> <p>hal::adc&amp; - Statically allocated analog pin driver. </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-battery","title":"function battery","text":"<p>Driver for battery analog signal which is 1/3rd of the VIN voltage. <pre><code>hal::adc &amp; hal::micromod::v1::battery () \n</code></pre></p> <p>Returns:</p> <p>hal::adc&amp; - Statically allocated battery analog pin driver. </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-can","title":"function can","text":"<p>Driver for the can bus. <pre><code>hal::can &amp; hal::micromod::v1::can () \n</code></pre></p> <p>Returns:</p> <p>hal::can&amp; - statically allocated can driver </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-console","title":"function console","text":"<p>Console serial interface. <pre><code>hal::serial &amp; hal::micromod::v1::console (\n    std::span&lt; hal::byte &gt; p_receive_buffer\n) \n</code></pre></p> <p>The console does not have to implement an actual serial communication protocol like, uart or rs232. It can be implemented with anything such as usb, i2c and spi, or something different. It just needs to follow the hal::serial interface for writing, reading bytes from the console.</p> <p>Parameters:</p> <ul> <li><code>p_receive_buffer</code> - The size of the receive buffer for the serial port. Note that subsequent calls to the function will ignore this parameter, thus the first call will set the receive buffer size. Ensure that the lifetime of the buffer is equal to or exceeds the lifetime of the console serial port. </li> </ul> <p>Returns:</p> <p>hal::serial&amp; - serial interface to the console </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-d0","title":"function d0","text":"<p>Driver for dac pin 0. <pre><code>hal::dac &amp; hal::micromod::v1::d0 () \n</code></pre></p> <p>Returns:</p> <p>hal::dac&amp; - Statically allocated dac pin driver. </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-d1","title":"function d1","text":"<p>Driver for dac pin 1. <pre><code>hal::dac &amp; hal::micromod::v1::d1 () \n</code></pre></p> <p>Returns:</p> <p>hal::dac&amp; - Statically allocated dac pin driver. </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-enter_power_saving_mode","title":"function enter_power_saving_mode","text":"<p>Enter power savings mode for your processor. <pre><code>void hal::micromod::v1::enter_power_saving_mode () \n</code></pre></p> <p>Generally needs an interrupt to wake up the device from sleep </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-i2c","title":"function i2c","text":"<p>Driver for the main i2c bus. <pre><code>hal::i2c &amp; hal::micromod::v1::i2c () \n</code></pre></p> <p>Returns:</p> <p>hal::i2c&amp; - Statically allocated i2c driver. </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-i2c1","title":"function i2c1","text":"<p>Driver for the alternative i2c bus 1. <pre><code>hal::i2c &amp; hal::micromod::v1::i2c1 () \n</code></pre></p> <p>Returns:</p> <p>hal::i2c&amp; - Statically allocated i2c driver. </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-i2c_interrupt_pin","title":"function i2c_interrupt_pin","text":"<p>Driver for i2c interrupt pin. <pre><code>hal::interrupt_pin &amp; hal::micromod::v1::i2c_interrupt_pin () \n</code></pre></p> <p>NOTE: that this pin can be used as an interrupt pin for both or either i2c buss.</p> <p>Returns:</p> <p>hal::interrupt_pin&amp; - Statically allocated interrupt pin driver. </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-initialize_platform","title":"function initialize_platform","text":"<p>Initialize the system. <pre><code>void hal::micromod::v1::initialize_platform () \n</code></pre></p> <p>Should be the first API called at the start of main. Typically sets up .data and .bss, heap sections if applicable, interrupt service routine handler and anything else necessary for code to function on the MCU. </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-input_g0","title":"function input_g0","text":"<pre><code>hal::input_pin &amp; hal::micromod::v1::input_g0 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-input_g1","title":"function input_g1","text":"<pre><code>hal::input_pin &amp; hal::micromod::v1::input_g1 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-input_g10","title":"function input_g10","text":"<pre><code>hal::input_pin &amp; hal::micromod::v1::input_g10 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-input_g2","title":"function input_g2","text":"<pre><code>hal::input_pin &amp; hal::micromod::v1::input_g2 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-input_g3","title":"function input_g3","text":"<pre><code>hal::input_pin &amp; hal::micromod::v1::input_g3 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-input_g4","title":"function input_g4","text":"<pre><code>hal::input_pin &amp; hal::micromod::v1::input_g4 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-input_g5","title":"function input_g5","text":"<pre><code>hal::input_pin &amp; hal::micromod::v1::input_g5 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-input_g6","title":"function input_g6","text":"<pre><code>hal::input_pin &amp; hal::micromod::v1::input_g6 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-input_g7","title":"function input_g7","text":"<pre><code>hal::input_pin &amp; hal::micromod::v1::input_g7 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-input_g8","title":"function input_g8","text":"<pre><code>hal::input_pin &amp; hal::micromod::v1::input_g8 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-input_g9","title":"function input_g9","text":"<pre><code>hal::input_pin &amp; hal::micromod::v1::input_g9 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-interrupt_g0","title":"function interrupt_g0","text":"<pre><code>hal::interrupt_pin &amp; hal::micromod::v1::interrupt_g0 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-interrupt_g1","title":"function interrupt_g1","text":"<pre><code>hal::interrupt_pin &amp; hal::micromod::v1::interrupt_g1 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-interrupt_g10","title":"function interrupt_g10","text":"<pre><code>hal::interrupt_pin &amp; hal::micromod::v1::interrupt_g10 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-interrupt_g2","title":"function interrupt_g2","text":"<pre><code>hal::interrupt_pin &amp; hal::micromod::v1::interrupt_g2 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-interrupt_g3","title":"function interrupt_g3","text":"<pre><code>hal::interrupt_pin &amp; hal::micromod::v1::interrupt_g3 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-interrupt_g4","title":"function interrupt_g4","text":"<pre><code>hal::interrupt_pin &amp; hal::micromod::v1::interrupt_g4 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-interrupt_g5","title":"function interrupt_g5","text":"<pre><code>hal::interrupt_pin &amp; hal::micromod::v1::interrupt_g5 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-interrupt_g6","title":"function interrupt_g6","text":"<pre><code>hal::interrupt_pin &amp; hal::micromod::v1::interrupt_g6 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-interrupt_g7","title":"function interrupt_g7","text":"<pre><code>hal::interrupt_pin &amp; hal::micromod::v1::interrupt_g7 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-interrupt_g8","title":"function interrupt_g8","text":"<pre><code>hal::interrupt_pin &amp; hal::micromod::v1::interrupt_g8 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-interrupt_g9","title":"function interrupt_g9","text":"<pre><code>hal::interrupt_pin &amp; hal::micromod::v1::interrupt_g9 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-led","title":"function led","text":"<p>Driver for the board LED output pin. <pre><code>hal::output_pin &amp; hal::micromod::v1::led () \n</code></pre></p> <p>If this output pin level is called with TRUE, the LED must be ON. If this output pin level is called with FALSE, the LED must be OFF.</p> <p>Returns:</p> <p>hal::output_pin&amp; - Statically allocated output pin driver connected to the LED. </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-output_g0","title":"function output_g0","text":"<pre><code>hal::output_pin &amp; hal::micromod::v1::output_g0 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-output_g1","title":"function output_g1","text":"<pre><code>hal::output_pin &amp; hal::micromod::v1::output_g1 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-output_g10","title":"function output_g10","text":"<pre><code>hal::output_pin &amp; hal::micromod::v1::output_g10 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-output_g2","title":"function output_g2","text":"<pre><code>hal::output_pin &amp; hal::micromod::v1::output_g2 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-output_g3","title":"function output_g3","text":"<pre><code>hal::output_pin &amp; hal::micromod::v1::output_g3 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-output_g4","title":"function output_g4","text":"<pre><code>hal::output_pin &amp; hal::micromod::v1::output_g4 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-output_g5","title":"function output_g5","text":"<pre><code>hal::output_pin &amp; hal::micromod::v1::output_g5 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-output_g6","title":"function output_g6","text":"<pre><code>hal::output_pin &amp; hal::micromod::v1::output_g6 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-output_g7","title":"function output_g7","text":"<pre><code>hal::output_pin &amp; hal::micromod::v1::output_g7 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-output_g8","title":"function output_g8","text":"<pre><code>hal::output_pin &amp; hal::micromod::v1::output_g8 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-output_g9","title":"function output_g9","text":"<pre><code>hal::output_pin &amp; hal::micromod::v1::output_g9 () \n</code></pre>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-pwm0","title":"function pwm0","text":"<p>Driver for pwm pin 0. <pre><code>hal::pwm &amp; hal::micromod::v1::pwm0 () \n</code></pre></p> <p>Returns:</p> <p>hal::pwm&amp; - Statically allocated pwm pin driver. </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-pwm1","title":"function pwm1","text":"<p>Driver for pwm pin 1. <pre><code>hal::pwm &amp; hal::micromod::v1::pwm1 () \n</code></pre></p> <p>Returns:</p> <p>hal::pwm&amp; - Statically allocated pwm pin driver. </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-reset","title":"function reset","text":"<p>Resets the microcontroller, restarting the program in the process. <pre><code>void hal::micromod::v1::reset () \n</code></pre></p> <p>If the application is executed as a program or process on operating system then this function should exit() with the code TBD which will alert the spawner process to rerun the command.</p> <p>This function must not return. </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-spi","title":"function spi","text":"<p>Driver for the main spi bus. <pre><code>hal::spi &amp; hal::micromod::v1::spi () \n</code></pre></p> <p>NOTE: in future iterations of this API, there will exist an sdio port used for talking to SD cards. This port is shared with the future sdio port. Take care to not use this along with the sdio port in the same application as they will conflict with each other resulting in undefined behavior.</p> <p>Returns:</p> <p>hal::spi&amp; </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-spi1","title":"function spi1","text":"<p>Driver for the alternative spi port 1. <pre><code>hal::spi &amp; hal::micromod::v1::spi1 () \n</code></pre></p> <p>Returns:</p> <p>hal::spi&amp; </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-spi_interrupt_pin","title":"function spi_interrupt_pin","text":"<p>Driver for spi interrupt pin. <pre><code>hal::interrupt_pin &amp; hal::micromod::v1::spi_interrupt_pin () \n</code></pre></p> <p>NOTE: that this pin can be used as an interrupt pin for both or either spi ports.</p> <p>Returns:</p> <p>hal::interrupt_pin&amp; </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-system_timer","title":"function system_timer","text":"<p>Get core system timer driver. <pre><code>hal::timer &amp; hal::micromod::v1::system_timer () \n</code></pre></p> <p>Usually used as the system timer for the RTOS</p> <p>Returns:</p> <p>hal::timer&amp; - reference to the timer </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-uart1","title":"function uart1","text":"<p>Driver for uart 1 port. <pre><code>hal::serial &amp; hal::micromod::v1::uart1 (\n    std::span&lt; hal::byte &gt; p_receive_buffer\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_receive_buffer</code> - The size of the receive buffer for the serial port. Note that subsequent calls to the function will ignore this parameter, thus the first call will set the receive buffer size. Ensure that the lifetime of the buffer is equal to or exceeds the lifetime of the uart port. </li> </ul> <p>Returns:</p> <p>hal::serial&amp; </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-uart2","title":"function uart2","text":"<p>Driver for uart 0 port. <pre><code>hal::serial &amp; hal::micromod::v1::uart2 (\n    std::span&lt; hal::byte &gt; p_receive_buffer\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_receive_buffer</code> - The size of the receive buffer for the serial port. Note that subsequent calls to the function will ignore this parameter, thus the first call will set the receive buffer size. Ensure that the lifetime of the buffer is equal to or exceeds the lifetime of the uart port. </li> </ul> <p>Returns:</p> <p>hal::serial&amp; </p>"},{"location":"api/namespacehal_1_1micromod_1_1v1/#function-uptime_clock","title":"function uptime_clock","text":"<p>steady clock to measures the cycles the processor has been up. <pre><code>hal::steady_clock &amp; hal::micromod::v1::uptime_clock () \n</code></pre></p> <p>Returns:</p> <p>hal::steady_clock&amp; - system uptime steady clock. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-micromod/micromod.hpp</code></p>"},{"location":"api/namespacehal_1_1mock/","title":"Namespace hal::mock","text":"<p>Namespace List &gt; hal &gt; mock</p>"},{"location":"api/namespacehal_1_1mock/#classes","title":"Classes","text":"Type Name struct adc Mock adc implementation for use in unit tests and simulations. struct can Mock can implementation for use in unit tests and simulations. struct dac Mock dac implementation for use in unit tests and simulations with a spy function for write() __ struct input_pin mock input_pin implementation for use in unit tests and simulations. struct interrupt_pin mock interrupt_pin implementation for use in unit tests and simulations. struct motor Mock motor implementation for use in unit tests and simulations with a spy function for power() __ struct output_pin mock output pin for use in unit tests and simulations struct pwm Mock pwm implementation for use in unit tests and simulations with spy functions for frequency() andduty_cycle() . struct steady_clock mock steady_clock implementation for use in unit tests and simulations. struct timer Mock timer implementation for use in unit tests and simulations with spy functions for schedule() , clear(), andis_running() __ struct write_only_spi Mock spi implementation for use in unit tests and simulations with a spy functions for configure() and a record for thetransfer() out data. The record ignores the in buffer and just stores the data being sent so it can be inspected later. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/adc.hpp</code></p>"},{"location":"api/structhal_1_1mock_1_1adc/","title":"Struct hal::mock::adc","text":"<p>ClassList &gt; hal &gt; mock &gt; adc</p> <p>Mock adc implementation for use in unit tests and simulations. </p> <ul> <li><code>#include &lt;adc.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::adc</p>"},{"location":"api/structhal_1_1mock_1_1adc/#public-functions","title":"Public Functions","text":"Type Name void set (std::queue&lt; read_t &gt; &amp; p_adc_values) Queues the floats to be returned for read() __"},{"location":"api/structhal_1_1mock_1_1adc/#public-functions-inherited-from-haladc","title":"Public Functions inherited from hal::adc","text":"<p>See hal::adc</p> Type Name result&lt; read_t &gt; read () Sample the analog to digital converter and return the result. virtual ~adc () = default"},{"location":"api/structhal_1_1mock_1_1adc/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1mock_1_1adc/#function-set","title":"function set","text":"<p>Queues the floats to be returned for read() __ <pre><code>inline void hal::mock::adc::set (\n    std::queue&lt; read_t &gt; &amp; p_adc_values\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_adc_values</code> - queue of floats </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/adc.hpp</code></p>"},{"location":"api/structhal_1_1mock_1_1can/","title":"Struct hal::mock::can","text":"<p>ClassList &gt; hal &gt; mock &gt; can</p> <p>Mock can implementation for use in unit tests and simulations. </p> <ul> <li><code>#include &lt;can.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::can</p>"},{"location":"api/structhal_1_1mock_1_1can/#public-types-inherited-from-halcan","title":"Public Types inherited from hal::can","text":"<p>See hal::can</p> Type Name typedef void(const message_t &amp;p_message) handler Receive handler for can messages. typedef uint32_t id_t Can message ID type trait."},{"location":"api/structhal_1_1mock_1_1can/#public-attributes","title":"Public Attributes","text":"Type Name spy_handler&lt; bool &gt; spy_bus_on Spy handler for hal::can::bus_on() will always have content of \"true\". spy_handler&lt; settings &gt; spy_configure Spy handler for hal::can::configure() __ spy_handler&lt; hal::callback&lt; handler &gt; &gt; spy_on_receive Spy handler for hal::can::on_receive() __ spy_handler&lt; message_t &gt; spy_send Spy handler for hal::can::send() __"},{"location":"api/structhal_1_1mock_1_1can/#public-functions","title":"Public Functions","text":"Type Name void reset () Reset spy information for functions."},{"location":"api/structhal_1_1mock_1_1can/#public-functions-inherited-from-halcan","title":"Public Functions inherited from hal::can","text":"<p>See hal::can</p> Type Name status bus_on () Transition the CAN device from \"bus-off\" to \"bus-on\". status configure (const settings &amp; p_settings) Configure this can bus port to match the settings supplied. void on_receive (hal::callback&lt; handler &gt; p_handler) Set the message reception handler. result&lt; send_t &gt; send (const message_t &amp; p_message) Send a can message. virtual ~can () = default"},{"location":"api/structhal_1_1mock_1_1can/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1mock_1_1can/#variable-spy_bus_on","title":"variable spy_bus_on","text":"<pre><code>spy_handler&lt;bool&gt; hal::mock::can::spy_bus_on;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1can/#variable-spy_configure","title":"variable spy_configure","text":"<pre><code>spy_handler&lt;settings&gt; hal::mock::can::spy_configure;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1can/#variable-spy_on_receive","title":"variable spy_on_receive","text":"<pre><code>spy_handler&lt;hal::callback&lt;handler&gt; &gt; hal::mock::can::spy_on_receive;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1can/#variable-spy_send","title":"variable spy_send","text":"<pre><code>spy_handler&lt;message_t&gt; hal::mock::can::spy_send;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1can/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1mock_1_1can/#function-reset","title":"function reset","text":"<pre><code>inline void hal::mock::can::reset () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/can.hpp</code></p>"},{"location":"api/structhal_1_1mock_1_1dac/","title":"Struct hal::mock::dac","text":"<p>ClassList &gt; hal &gt; mock &gt; dac</p> <p>Mock dac implementation for use in unit tests and simulations with a spy function for write() __</p> <ul> <li><code>#include &lt;dac.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::dac</p>"},{"location":"api/structhal_1_1mock_1_1dac/#public-attributes","title":"Public Attributes","text":"Type Name spy_handler&lt; float &gt; spy_write Spy handler for hal::dac::write() __"},{"location":"api/structhal_1_1mock_1_1dac/#public-functions","title":"Public Functions","text":"Type Name void reset () Reset spy information for write() __"},{"location":"api/structhal_1_1mock_1_1dac/#public-functions-inherited-from-haldac","title":"Public Functions inherited from hal::dac","text":"<p>See hal::dac</p> Type Name result&lt; write_t &gt; write (float p_percentage) Set the output voltage of the DAC. virtual ~dac () = default"},{"location":"api/structhal_1_1mock_1_1dac/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1mock_1_1dac/#variable-spy_write","title":"variable spy_write","text":"<pre><code>spy_handler&lt;float&gt; hal::mock::dac::spy_write;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1dac/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1mock_1_1dac/#function-reset","title":"function reset","text":"<pre><code>inline void hal::mock::dac::reset () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/dac.hpp</code></p>"},{"location":"api/structhal_1_1mock_1_1input__pin/","title":"Struct hal::mock::input_pin","text":"<p>ClassList &gt; hal &gt; mock &gt; input_pin</p> <p>mock input_pin implementation for use in unit tests and simulations.</p> <ul> <li><code>#include &lt;input_pin.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::input_pin</p>"},{"location":"api/structhal_1_1mock_1_1input__pin/#public-attributes","title":"Public Attributes","text":"Type Name spy_handler&lt; settings &gt; spy_configure Spy handler for embed:input_pin:: configure() __"},{"location":"api/structhal_1_1mock_1_1input__pin/#public-functions","title":"Public Functions","text":"Type Name void reset () Reset spy information for configure() __ void set (std::queue&lt; level_t &gt; &amp; p_levels) Queues the active levels to be returned for levels()"},{"location":"api/structhal_1_1mock_1_1input__pin/#public-functions-inherited-from-halinput_pin","title":"Public Functions inherited from hal::input_pin","text":"<p>See hal::input_pin</p> Type Name status configure (const settings &amp; p_settings) Configure the input pin to match the settings supplied. result&lt; level_t &gt; level () Read the state of the input pin. virtual ~input_pin () = default"},{"location":"api/structhal_1_1mock_1_1input__pin/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1mock_1_1input__pin/#variable-spy_configure","title":"variable spy_configure","text":"<pre><code>spy_handler&lt;settings&gt; hal::mock::input_pin::spy_configure;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1input__pin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1mock_1_1input__pin/#function-reset","title":"function reset","text":"<pre><code>inline void hal::mock::input_pin::reset () \n</code></pre>"},{"location":"api/structhal_1_1mock_1_1input__pin/#function-set","title":"function set","text":"<p>Queues the active levels to be returned for levels() <pre><code>inline void hal::mock::input_pin::set (\n    std::queue&lt; level_t &gt; &amp; p_levels\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_levels</code> - queue of actives levels </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/input_pin.hpp</code></p>"},{"location":"api/structhal_1_1mock_1_1interrupt__pin/","title":"Struct hal::mock::interrupt_pin","text":"<p>ClassList &gt; hal &gt; mock &gt; interrupt_pin</p> <p>mock interrupt_pin implementation for use in unit tests and simulations.</p> <ul> <li><code>#include &lt;interrupt_pin.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::interrupt_pin</p>"},{"location":"api/structhal_1_1mock_1_1interrupt__pin/#public-types-inherited-from-halinterrupt_pin","title":"Public Types inherited from hal::interrupt_pin","text":"<p>See hal::interrupt_pin</p> Type Name typedef void(bool p_state) handler Interrupt pin handler. enum trigger_edge The condition in which an interrupt it's triggered."},{"location":"api/structhal_1_1mock_1_1interrupt__pin/#public-attributes","title":"Public Attributes","text":"Type Name spy_handler&lt; settings &gt; spy_configure Spy handler for hal::interrupt_pin::configure() __ spy_handler&lt; std::function&lt; handler &gt; &gt; spy_on_trigger Spy handler for hal::interrupt_pin::on_trigger() __"},{"location":"api/structhal_1_1mock_1_1interrupt__pin/#public-functions","title":"Public Functions","text":"Type Name void reset () Reset spy information for configure() ,on_trigger() , and disable()"},{"location":"api/structhal_1_1mock_1_1interrupt__pin/#public-functions-inherited-from-halinterrupt_pin","title":"Public Functions inherited from hal::interrupt_pin","text":"<p>See hal::interrupt_pin</p> Type Name status configure (const settings &amp; p_settings) Configure the interrupt pin to match the settings supplied. void on_trigger (hal::callback&lt; handler &gt; p_callback) Set the callback for when the interrupt occurs. virtual ~interrupt_pin () = default"},{"location":"api/structhal_1_1mock_1_1interrupt__pin/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1mock_1_1interrupt__pin/#variable-spy_configure","title":"variable spy_configure","text":"<pre><code>spy_handler&lt;settings&gt; hal::mock::interrupt_pin::spy_configure;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1interrupt__pin/#variable-spy_on_trigger","title":"variable spy_on_trigger","text":"<pre><code>spy_handler&lt;std::function&lt;handler&gt; &gt; hal::mock::interrupt_pin::spy_on_trigger;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1interrupt__pin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1mock_1_1interrupt__pin/#function-reset","title":"function reset","text":"<pre><code>inline void hal::mock::interrupt_pin::reset () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/interrupt_pin.hpp</code></p>"},{"location":"api/structhal_1_1mock_1_1motor/","title":"Struct hal::mock::motor","text":"<p>ClassList &gt; hal &gt; mock &gt; motor</p> <p>Mock motor implementation for use in unit tests and simulations with a spy function for power() __</p> <ul> <li><code>#include &lt;motor.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::motor</p>"},{"location":"api/structhal_1_1mock_1_1motor/#public-attributes","title":"Public Attributes","text":"Type Name spy_handler&lt; float &gt; spy_power Spy handler for hal::motor::write()"},{"location":"api/structhal_1_1mock_1_1motor/#public-functions","title":"Public Functions","text":"Type Name void reset () Reset spy information for power() __"},{"location":"api/structhal_1_1mock_1_1motor/#public-functions-inherited-from-halmotor","title":"Public Functions inherited from hal::motor","text":"<p>See hal::motor</p> Type Name result&lt; power_t &gt; power (float p_power) Apply power to the motor. virtual ~motor () = default"},{"location":"api/structhal_1_1mock_1_1motor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1mock_1_1motor/#variable-spy_power","title":"variable spy_power","text":"<pre><code>spy_handler&lt;float&gt; hal::mock::motor::spy_power;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1motor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1mock_1_1motor/#function-reset","title":"function reset","text":"<pre><code>inline void hal::mock::motor::reset () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/motor.hpp</code></p>"},{"location":"api/structhal_1_1mock_1_1output__pin/","title":"Struct hal::mock::output_pin","text":"<p>ClassList &gt; hal &gt; mock &gt; output_pin</p> <p>mock output pin for use in unit tests and simulations </p> <ul> <li><code>#include &lt;output_pin.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::output_pin</p>"},{"location":"api/structhal_1_1mock_1_1output__pin/#public-attributes","title":"Public Attributes","text":"Type Name spy_handler&lt; settings &gt; spy_configure Spy handler for hal::output_pin::configure() __ spy_handler&lt; level_t &gt; spy_level Spy handler for hal::output_pin::level() __"},{"location":"api/structhal_1_1mock_1_1output__pin/#public-functions","title":"Public Functions","text":"Type Name void reset () Reset spy information for configure() andlevel() __"},{"location":"api/structhal_1_1mock_1_1output__pin/#public-functions-inherited-from-haloutput_pin","title":"Public Functions inherited from hal::output_pin","text":"<p>See hal::output_pin</p> Type Name status configure (const settings &amp; p_settings) Configure the output pin to match the settings supplied. result&lt; set_level_t &gt; level (bool p_high) Set the state of the pin. result&lt; level_t &gt; level () Read the current state of the output pin. virtual ~output_pin () = default"},{"location":"api/structhal_1_1mock_1_1output__pin/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1mock_1_1output__pin/#variable-spy_configure","title":"variable spy_configure","text":"<pre><code>spy_handler&lt;settings&gt; hal::mock::output_pin::spy_configure;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1output__pin/#variable-spy_level","title":"variable spy_level","text":"<pre><code>spy_handler&lt;level_t&gt; hal::mock::output_pin::spy_level;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1output__pin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1mock_1_1output__pin/#function-reset","title":"function reset","text":"<pre><code>inline void hal::mock::output_pin::reset () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/output_pin.hpp</code></p>"},{"location":"api/structhal_1_1mock_1_1pwm/","title":"Struct hal::mock::pwm","text":"<p>ClassList &gt; hal &gt; mock &gt; pwm</p> <p>Mock pwm implementation for use in unit tests and simulations with spy functions for frequency() andduty_cycle() .</p> <ul> <li><code>#include &lt;pwm.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::pwm</p>"},{"location":"api/structhal_1_1mock_1_1pwm/#public-attributes","title":"Public Attributes","text":"Type Name spy_handler&lt; float &gt; spy_duty_cycle Spy handler for hal::pwm::duty_cycle() __ spy_handler&lt; hertz &gt; spy_frequency Spy handler for hal::pwm::frequency() __"},{"location":"api/structhal_1_1mock_1_1pwm/#public-functions","title":"Public Functions","text":"Type Name void reset () Reset spy information for both frequency() andduty_cycle() __"},{"location":"api/structhal_1_1mock_1_1pwm/#public-functions-inherited-from-halpwm","title":"Public Functions inherited from hal::pwm","text":"<p>See hal::pwm</p> Type Name result&lt; duty_cycle_t &gt; duty_cycle (float p_duty_cycle) Set the pwm waveform duty cycle. result&lt; frequency_t &gt; frequency (hertz p_frequency) Set the pwm waveform frequency. virtual ~pwm () = default"},{"location":"api/structhal_1_1mock_1_1pwm/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1mock_1_1pwm/#variable-spy_duty_cycle","title":"variable spy_duty_cycle","text":"<pre><code>spy_handler&lt;float&gt; hal::mock::pwm::spy_duty_cycle;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1pwm/#variable-spy_frequency","title":"variable spy_frequency","text":"<pre><code>spy_handler&lt;hertz&gt; hal::mock::pwm::spy_frequency;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1pwm/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1mock_1_1pwm/#function-reset","title":"function reset","text":"<pre><code>inline void hal::mock::pwm::reset () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/pwm.hpp</code></p>"},{"location":"api/structhal_1_1mock_1_1steady__clock/","title":"Struct hal::mock::steady_clock","text":"<p>ClassList &gt; hal &gt; mock &gt; steady_clock</p> <p>mock steady_clock implementation for use in unit tests and simulations.</p> <ul> <li><code>#include &lt;steady_clock.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::steady_clock</p>"},{"location":"api/structhal_1_1mock_1_1steady__clock/#public-functions","title":"Public Functions","text":"Type Name void set_frequency (frequency_t p_frequency) Set the frequency to be returned from frequency() __ void set_uptimes (std::queue&lt; uptime_t &gt; &amp; p_uptime_values) Queues the uptimes to be returned from uptimes()"},{"location":"api/structhal_1_1mock_1_1steady__clock/#public-functions-inherited-from-halsteady_clock","title":"Public Functions inherited from hal::steady_clock","text":"<p>See hal::steady_clock</p> Type Name frequency_t frequency () Get the operating frequency of the steady clock. uptime_t uptime () Get the current value of the steady clock. virtual ~steady_clock () = default"},{"location":"api/structhal_1_1mock_1_1steady__clock/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1mock_1_1steady__clock/#function-set_frequency","title":"function set_frequency","text":"<p>Set the frequency to be returned from frequency() __ <pre><code>inline void hal::mock::steady_clock::set_frequency (\n    frequency_t p_frequency\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_frequency</code> - Frequency to return </li> </ul>"},{"location":"api/structhal_1_1mock_1_1steady__clock/#function-set_uptimes","title":"function set_uptimes","text":"<p>Queues the uptimes to be returned from uptimes() <pre><code>inline void hal::mock::steady_clock::set_uptimes (\n    std::queue&lt; uptime_t &gt; &amp; p_uptime_values\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_uptime_values</code> - Queue of uptimes </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/steady_clock.hpp</code></p>"},{"location":"api/structhal_1_1mock_1_1timer/","title":"Struct hal::mock::timer","text":"<p>ClassList &gt; hal &gt; mock &gt; timer</p> <p>Mock timer implementation for use in unit tests and simulations with spy functions for schedule() , clear(), andis_running() __</p> <ul> <li><code>#include &lt;timer.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::timer</p>"},{"location":"api/structhal_1_1mock_1_1timer/#public-attributes","title":"Public Attributes","text":"Type Name spy_handler&lt; bool &gt; spy_cancel Spy handler for hal::timer::clear() spy_handler&lt; bool &gt; spy_is_running Spy handler for hal::timer::is_running() __ spy_handler&lt; std::function&lt; void(void)&gt;, std::chrono::nanoseconds &gt; spy_schedule Spy handler for hal::timer::schedule() __"},{"location":"api/structhal_1_1mock_1_1timer/#public-functions","title":"Public Functions","text":"Type Name void reset () Reset spy information for schedule() , clear(), andis_running() __"},{"location":"api/structhal_1_1mock_1_1timer/#public-functions-inherited-from-haltimer","title":"Public Functions inherited from hal::timer","text":"<p>See hal::timer</p> Type Name result&lt; cancel_t &gt; cancel () Stops a scheduled event from happening. result&lt; is_running_t &gt; is_running () Determine if the timer is currently running. result&lt; schedule_t &gt; schedule (hal::callback&lt; void(void)&gt; p_callback, hal::time_duration p_delay) Schedule an callback be be executed after the delay time. virtual ~timer () = default"},{"location":"api/structhal_1_1mock_1_1timer/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1mock_1_1timer/#variable-spy_cancel","title":"variable spy_cancel","text":"<pre><code>spy_handler&lt;bool&gt; hal::mock::timer::spy_cancel;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1timer/#variable-spy_is_running","title":"variable spy_is_running","text":"<pre><code>spy_handler&lt;bool&gt; hal::mock::timer::spy_is_running;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1timer/#variable-spy_schedule","title":"variable spy_schedule","text":"<pre><code>spy_handler&lt;std::function&lt;void(void)&gt;, std::chrono::nanoseconds&gt; hal::mock::timer::spy_schedule;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1timer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1mock_1_1timer/#function-reset","title":"function reset","text":"<pre><code>inline void hal::mock::timer::reset () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/timer.hpp</code></p>"},{"location":"api/structhal_1_1mock_1_1write__only__spi/","title":"Struct hal::mock::write_only_spi","text":"<p>ClassList &gt; hal &gt; mock &gt; write_only_spi</p> <p>Mock spi implementation for use in unit tests and simulations with a spy functions for configure() and a record for thetransfer() out data. The record ignores the in buffer and just stores the data being sent so it can be inspected later.</p> <ul> <li><code>#include &lt;spi.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::spi</p>"},{"location":"api/structhal_1_1mock_1_1write__only__spi/#public-attributes","title":"Public Attributes","text":"Type Name spy_handler&lt; settings &gt; spy_configure Spy handler for hal::spi::configure() __ std::vector&lt; std::vector&lt; hal::byte &gt; &gt; write_record Record of the out data from hal::spi::transfer() __"},{"location":"api/structhal_1_1mock_1_1write__only__spi/#public-static-attributes-inherited-from-halspi","title":"Public Static Attributes inherited from hal::spi","text":"<p>See hal::spi</p> Type Name constexpr hal::byte default_filler   = = hal::byte"},{"location":"api/structhal_1_1mock_1_1write__only__spi/#public-functions","title":"Public Functions","text":"Type Name void reset () Reset spy information for both configure() andtransfer() __"},{"location":"api/structhal_1_1mock_1_1write__only__spi/#public-functions-inherited-from-halspi","title":"Public Functions inherited from hal::spi","text":"<p>See hal::spi</p> Type Name status configure (const settings &amp; p_settings) Configure spi to match the settings supplied. result&lt; transfer_t &gt; transfer (std::span&lt; const hal::byte &gt; p_data_out, std::span&lt; hal::byte &gt; p_data_in, hal::byte p_filler=default_filler) Send and receive data between a selected device on the spi bus. This function will block until the entire transfer is finished. virtual ~spi () = default"},{"location":"api/structhal_1_1mock_1_1write__only__spi/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1mock_1_1write__only__spi/#variable-spy_configure","title":"variable spy_configure","text":"<pre><code>spy_handler&lt;settings&gt; hal::mock::write_only_spi::spy_configure;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1write__only__spi/#variable-write_record","title":"variable write_record","text":"<pre><code>std::vector&lt;std::vector&lt;hal::byte&gt; &gt; hal::mock::write_only_spi::write_record;\n</code></pre>"},{"location":"api/structhal_1_1mock_1_1write__only__spi/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1mock_1_1write__only__spi/#function-reset","title":"function reset","text":"<pre><code>inline void hal::mock::write_only_spi::reset () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/spi.hpp</code></p>"},{"location":"api/classhal_1_1motor/","title":"Class hal::motor","text":"<p>ClassList &gt; hal &gt; motor</p> <p>Hardware abstraction for an open loop rotational actuator. More...</p> <ul> <li><code>#include &lt;motor.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::mock::motor,  hal::rmd::drc_motor,  hal::rmd::mc_x_motor,  hal::soft::inert_motor</p>"},{"location":"api/classhal_1_1motor/#classes","title":"Classes","text":"Type Name struct power_t Feedback from setting the motor power."},{"location":"api/classhal_1_1motor/#public-functions","title":"Public Functions","text":"Type Name result&lt; power_t &gt; power (float p_power) Apply power to the motor. virtual ~motor () = default"},{"location":"api/classhal_1_1motor/#detailed-description","title":"Detailed Description","text":"<p>The motor interface can represent a variety of things such as:</p> <ul> <li>A driver for motor controller IC like the DRV8801</li> <li>A driver for a motor with integrated controller &amp; serial interface</li> <li>A unidirectional motor controlled by a single transistor</li> <li>A servo with open loop motor control </li> </ul>"},{"location":"api/classhal_1_1motor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1motor/#function-power","title":"function power","text":"<p>Apply power to the motor. <pre><code>inline result&lt; power_t &gt; hal::motor::power (\n    float p_power\n) \n</code></pre></p> <p>Power is a percentage and thus cannot be used as a way to gauge how fast the motor is moving. In general applying more power means to increase speed and/or torque to the motor.</p> <ul> <li>0% power would mean that no power is being applied to the motor. In this situation an unloaded motor will not move. 0% power does not guarantee that the motor will hold its position. These specifics depend greatly on the type of motor used and careful selection of motor and motor driver are important for applications using this interface.</li> <li>100% power means that the maximum available of power is being applied to the motor. As an example, if the max voltage of a DC brushed motor's power supply is 12V, then 12V would be supplied to this motor.</li> <li>50% power would mean that half of the available power is being applied to the motor. Using the same example, in this case 6V would be applied to the motor either as a DC constant voltage or via PWM at 50% duty cycle.</li> <li>Negative values will cause the motor to move in the opposite direction as positive values. In the event that motor driver can * only go in one direction, this function should clamp the power applied to 0%.</li> </ul> <p>Parameters:</p> <ul> <li><code>p_power</code> - Percentage of power to apply to the motor from -1.0f to +1.0f, -100% to 100%, respectively. </li> </ul> <p>Returns:</p> <p>result&lt;power_t&gt; - success or failure </p>"},{"location":"api/classhal_1_1motor/#function-motor","title":"function ~motor","text":"<pre><code>virtual hal::motor::~motor () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/motor.hpp</code></p>"},{"location":"api/structhal_1_1motor_1_1power__t/","title":"Struct hal::motor::power_t","text":"<p>ClassList &gt; hal &gt; motor &gt; power_t</p> <p>Feedback from setting the motor power. More...</p> <ul> <li><code>#include &lt;motor.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1motor_1_1power__t/#detailed-description","title":"Detailed Description","text":"<p>This structure is currently empty as no feedback has been determined for now. This structure may be expanded in the future. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/motor.hpp</code></p>"},{"location":"api/classhal_1_1move__interceptor/","title":"Class hal::move_interceptor","text":"<p>template &lt;class T class T&gt;</p> <p>ClassList &gt; hal &gt; move_interceptor</p> <p>Use this to perform changes on an object its move constructor is executed. More...</p> <ul> <li><code>#include &lt;move_interceptor.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1move__interceptor/#public-attributes","title":"Public Attributes","text":"Type Name friend T"},{"location":"api/classhal_1_1move__interceptor/#detailed-description","title":"Detailed Description","text":"<p>This can be used to allow type T to use a default move constructor but allow specific operations to occur beforehand. This is used for moveable objects with callbacks that refer back to their object's address such as the following:  The default move constructor does everything correctly for type T. But the address of \"this\" in the lambda expression refers to the previous object's address which is no longer valid. Rather than a make a whole move constructor just to update this one callback, the move_interceptor can be used to change the previous object's callback to the new object's address before the move occurs. Then the object's default move constructor is executed.</p> <p>Template parameters:</p> <ul> <li><code>T</code> - object to intercept the move constructor of </li> </ul>"},{"location":"api/classhal_1_1move__interceptor/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/classhal_1_1move__interceptor/#variable-t","title":"variable T","text":"<pre><code>friend hal::move_interceptor&lt; T &gt;::T;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/move_interceptor.hpp</code></p>"},{"location":"api/namespacehal_1_1mpl/","title":"Namespace hal::mpl","text":"<p>Namespace List &gt; hal &gt; mpl</p>"},{"location":"api/namespacehal_1_1mpl/#classes","title":"Classes","text":"Type Name class mpl3115a2 <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mpl/mpl3115a2.hpp</code></p>"},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/","title":"Class hal::mpl::mpl3115a2","text":"<p>ClassList &gt; hal &gt; mpl &gt; mpl3115a2</p>"},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#classes","title":"Classes","text":"Type Name struct altitude_read_t struct pressure_read_t struct temperature_read_t"},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#public-types","title":"Public Types","text":"Type Name enum mode"},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr uint16_t default_max_polling_retries   = = 10000"},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#public-functions","title":"Public Functions","text":"Type Name hal::result&lt; altitude_read_t &gt; read_altitude () Read altitude data from out_p_msb_r, out_p_csb_r, and out_p_lsb_r and perform altitude conversion to meters. hal::result&lt; pressure_read_t &gt; read_pressure () Read pressure data from out_p_msb_r, out_p_csb_r, and out_p_lsb_r and perform pressure conversion to kilopascals. hal::result&lt; temperature_read_t &gt; read_temperature () Read pressure data from out_t_msb_r and out_t_lsb_r and perform temperature conversion to celsius. hal::status set_altitude_offset (int8_t p_offset) Set altitude offset in off_h_r. hal::status set_sea_pressure (float p_sea_level_pressure) Set sea level pressure (Barometric input for altitude calculations) in bar_in_msb_r and bar_in_lsb_r registers."},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; mpl3115a2 &gt; create (hal::i2c &amp; p_i2c) Initialization of MPLX device."},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#enum-mode","title":"enum mode","text":"<pre><code>enum hal::mpl::mpl3115a2::mode {\n    barometer = 0,\n    altimeter = 1\n};\n</code></pre>"},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#variable-default_max_polling_retries","title":"variable default_max_polling_retries","text":"<pre><code>constexpr uint16_t hal::mpl::mpl3115a2::default_max_polling_retries;\n</code></pre>"},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#function-read_altitude","title":"function read_altitude","text":"<pre><code>hal::result&lt; altitude_read_t &gt; hal::mpl::mpl3115a2::read_altitude () \n</code></pre>"},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#function-read_pressure","title":"function read_pressure","text":"<pre><code>hal::result&lt; pressure_read_t &gt; hal::mpl::mpl3115a2::read_pressure () \n</code></pre>"},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#function-read_temperature","title":"function read_temperature","text":"<pre><code>hal::result&lt; temperature_read_t &gt; hal::mpl::mpl3115a2::read_temperature () \n</code></pre>"},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#function-set_altitude_offset","title":"function set_altitude_offset","text":"<p>Set altitude offset in off_h_r. <pre><code>hal::status hal::mpl::mpl3115a2::set_altitude_offset (\n    int8_t p_offset\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_offset</code> Offset value in meters, from -127 to 128 </li> </ul>"},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#function-set_sea_pressure","title":"function set_sea_pressure","text":"<p>Set sea level pressure (Barometric input for altitude calculations) in bar_in_msb_r and bar_in_lsb_r registers. <pre><code>hal::status hal::mpl::mpl3115a2::set_sea_pressure (\n    float p_sea_level_pressure\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_sea_level_pressure</code> Sea level pressure in Pascals. Default value on startup is 101,326 Pa. </li> </ul>"},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1mpl_1_1mpl3115a2/#function-create","title":"function create","text":"<p>Initialization of MPLX device. <pre><code>static result&lt; mpl3115a2 &gt; hal::mpl::mpl3115a2::create (\n    hal::i2c &amp; p_i2c\n) \n</code></pre></p> <p>This function performs the following steps during startup configuration: * Perform WHOAMI check * Trigger reset and wait for completion * Set altimeter mode * Set oversampling ratio to 2^128 (OS128) * Enable data ready events for pressure/altitude and temperature </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mpl/mpl3115a2.hpp</code></p>"},{"location":"api/structhal_1_1mpl_1_1mpl3115a2_1_1altitude__read__t/","title":"Struct hal::mpl::mpl3115a2::altitude_read_t","text":"<p>ClassList &gt; hal &gt; mpl &gt; mpl3115a2 &gt; altitude_read_t</p>"},{"location":"api/structhal_1_1mpl_1_1mpl3115a2_1_1altitude__read__t/#public-attributes","title":"Public Attributes","text":"Type Name meters altitude"},{"location":"api/structhal_1_1mpl_1_1mpl3115a2_1_1altitude__read__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1mpl_1_1mpl3115a2_1_1altitude__read__t/#variable-altitude","title":"variable altitude","text":"<pre><code>meters hal::mpl::mpl3115a2::altitude_read_t::altitude;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mpl/mpl3115a2.hpp</code></p>"},{"location":"api/structhal_1_1mpl_1_1mpl3115a2_1_1pressure__read__t/","title":"Struct hal::mpl::mpl3115a2::pressure_read_t","text":"<p>ClassList &gt; hal &gt; mpl &gt; mpl3115a2 &gt; pressure_read_t</p>"},{"location":"api/structhal_1_1mpl_1_1mpl3115a2_1_1pressure__read__t/#public-attributes","title":"Public Attributes","text":"Type Name float pressure"},{"location":"api/structhal_1_1mpl_1_1mpl3115a2_1_1pressure__read__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1mpl_1_1mpl3115a2_1_1pressure__read__t/#variable-pressure","title":"variable pressure","text":"<pre><code>float hal::mpl::mpl3115a2::pressure_read_t::pressure;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mpl/mpl3115a2.hpp</code></p>"},{"location":"api/structhal_1_1mpl_1_1mpl3115a2_1_1temperature__read__t/","title":"Struct hal::mpl::mpl3115a2::temperature_read_t","text":"<p>ClassList &gt; hal &gt; mpl &gt; mpl3115a2 &gt; temperature_read_t</p>"},{"location":"api/structhal_1_1mpl_1_1mpl3115a2_1_1temperature__read__t/#public-attributes","title":"Public Attributes","text":"Type Name celsius temperature"},{"location":"api/structhal_1_1mpl_1_1mpl3115a2_1_1temperature__read__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1mpl_1_1mpl3115a2_1_1temperature__read__t/#variable-temperature","title":"variable temperature","text":"<pre><code>celsius hal::mpl::mpl3115a2::temperature_read_t::temperature;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mpl/mpl3115a2.hpp</code></p>"},{"location":"api/structhal_1_1nibble__mask/","title":"Struct hal::nibble_mask","text":"<p>template &lt;size_t NibbleIndex&gt;</p> <p>ClassList &gt; hal &gt; nibble_mask</p> <p>Helper for generating nibble position masks. More...</p> <ul> <li><code>#include &lt;bit.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1nibble__mask/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr hal::bit_mask value   = { .position = NibbleIndex, .width = 4 }"},{"location":"api/structhal_1_1nibble__mask/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>NibbleIndex</code> - the nibble position to make a mask for </li> </ul>"},{"location":"api/structhal_1_1nibble__mask/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/structhal_1_1nibble__mask/#variable-value","title":"variable value","text":"<pre><code>constexpr hal::bit_mask hal::nibble_mask&lt; NibbleIndex &gt;::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/bit.hpp</code></p>"},{"location":"api/classhal_1_1output__pin/","title":"Class hal::output_pin","text":"<p>ClassList &gt; hal &gt; output_pin</p> <p>Digital output pin hardware abstraction. More...</p> <ul> <li><code>#include &lt;output_pin.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::lpc40::output_pin,  hal::mock::output_pin,  hal::soft::inert_output_pin,  hal::soft::output_pin_inverter,  hal::stm32f1::output_pin</p>"},{"location":"api/classhal_1_1output__pin/#classes","title":"Classes","text":"Type Name struct level_t Pin level reading structure. struct set_level_t Feedback from setting the pin state. struct settings Generic settings for output pins."},{"location":"api/classhal_1_1output__pin/#public-functions","title":"Public Functions","text":"Type Name status configure (const settings &amp; p_settings) Configure the output pin to match the settings supplied. result&lt; set_level_t &gt; level (bool p_high) Set the state of the pin. result&lt; level_t &gt; level () Read the current state of the output pin. virtual ~output_pin () = default"},{"location":"api/classhal_1_1output__pin/#detailed-description","title":"Detailed Description","text":"<p>Use this to drive a pin HIGH or LOW in order to send a control signal or turn off or on an LED.</p> <p>Implementations of this interface can be backed by external devices such as I/O expanders or other micro-controllers. </p>"},{"location":"api/classhal_1_1output__pin/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1output__pin/#function-configure","title":"function configure","text":"<p>Configure the output pin to match the settings supplied. <pre><code>inline status hal::output_pin::configure (\n    const settings &amp; p_settings\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_settings</code> - settings to apply to output pin </li> </ul> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::invalid_argument</code> if the settings could not be achieved. </li> </ul>"},{"location":"api/classhal_1_1output__pin/#function-level-12","title":"function level [1/2]","text":"<p>Set the state of the pin. <pre><code>inline result&lt; set_level_t &gt; hal::output_pin::level (\n    bool p_high\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_high</code> - if true then the pin state is set to HIGH voltage. If false, the pin state is set to LOW voltage. </li> </ul> <p>Returns:</p> <p>result&lt;set_level_t&gt; - success or failure </p>"},{"location":"api/classhal_1_1output__pin/#function-level-22","title":"function level [2/2]","text":"<p>Read the current state of the output pin. <pre><code>inline result&lt; level_t &gt; hal::output_pin::level () \n</code></pre></p> <p>Implementations must read the pin state from hardware and will not simply cache the results from the execution of <code>level(bool)</code>.</p> <p>This pin may not equal the state set by <code>level(bool)</code> when the pin is configured as open-drain.</p> <p>Returns:</p> <p>result&lt;level_t&gt; - return the current level state of the output pin </p>"},{"location":"api/classhal_1_1output__pin/#function-output_pin","title":"function ~output_pin","text":"<pre><code>virtual hal::output_pin::~output_pin () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/output_pin.hpp</code></p>"},{"location":"api/structhal_1_1output__pin_1_1level__t/","title":"Struct hal::output_pin::level_t","text":"<p>ClassList &gt; hal &gt; output_pin &gt; level_t</p> <p>Pin level reading structure. </p> <ul> <li><code>#include &lt;output_pin.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1output__pin_1_1level__t/#public-attributes","title":"Public Attributes","text":"Type Name bool state Current state of the pin."},{"location":"api/structhal_1_1output__pin_1_1level__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1output__pin_1_1level__t/#variable-state","title":"variable state","text":"<pre><code>bool hal::output_pin::level_t::state;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/output_pin.hpp</code></p>"},{"location":"api/structhal_1_1output__pin_1_1set__level__t/","title":"Struct hal::output_pin::set_level_t","text":"<p>ClassList &gt; hal &gt; output_pin &gt; set_level_t</p> <p>Feedback from setting the pin state. More...</p> <ul> <li><code>#include &lt;output_pin.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1output__pin_1_1set__level__t/#detailed-description","title":"Detailed Description","text":"<p>This structure is currently empty as no feedback has been determined for now. This structure may be expanded in the future. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/output_pin.hpp</code></p>"},{"location":"api/structhal_1_1output__pin_1_1settings/","title":"Struct hal::output_pin::settings","text":"<p>ClassList &gt; hal &gt; output_pin &gt; settings</p> <p>Generic settings for output pins. </p> <ul> <li><code>#include &lt;output_pin.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1output__pin_1_1settings/#public-attributes","title":"Public Attributes","text":"Type Name bool open_drain   = = false pin_resistor resistor   = = pin_resistor::none"},{"location":"api/structhal_1_1output__pin_1_1settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1output__pin_1_1settings/#variable-open_drain","title":"variable open_drain","text":"<pre><code>bool hal::output_pin::settings::open_drain;\n</code></pre> <p>Starting level of the output pin. HIGH voltage defined as true and LOW voltage defined as false. </p>"},{"location":"api/structhal_1_1output__pin_1_1settings/#variable-resistor","title":"variable resistor","text":"<pre><code>pin_resistor hal::output_pin::settings::resistor;\n</code></pre> <p>Pull resistor for the pin. This generally only helpful when open drain is enabled. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/output_pin.hpp</code></p>"},{"location":"api/classhal_1_1overflow__counter/","title":"Class hal::overflow_counter","text":"<p>template &lt;size_t CountBitWidth&gt;</p> <p>ClassList &gt; hal &gt; overflow_counter</p> <p>Extend a counter's count from an arbitrary bit width to 64-bits by detecting overflows in the count. Each detected overflow is added to an overflow counter which is combined with the current count in order create a count up to 64-bits in length. More...</p> <ul> <li><code>#include &lt;overflow_counter.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1overflow__counter/#public-functions","title":"Public Functions","text":"Type Name constexpr void reset () Reset the overflow count back to zero. constexpr uint64_t update (uint32_t p_new_count) update the overflow counter, detect if an overflow has occurred, and return the combined"},{"location":"api/classhal_1_1overflow__counter/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>CountBitWidth</code> - the bit width of the counter before the count value overflows. </li> </ul>"},{"location":"api/classhal_1_1overflow__counter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1overflow__counter/#function-reset","title":"function reset","text":"<pre><code>inline constexpr void hal::overflow_counter::reset () \n</code></pre>"},{"location":"api/classhal_1_1overflow__counter/#function-update","title":"function update","text":"<p>update the overflow counter, detect if an overflow has occurred, and return the combined <pre><code>inline constexpr uint64_t hal::overflow_counter::update (\n    uint32_t p_new_count\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_new_count</code> - must be an increasing value and should only decrease when an overflow event occurs. </li> </ul> <p>Returns:</p> <p>constexpr uint64_t - 64-bit count combining the new count value and the overflow count value. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/overflow_counter.hpp</code></p>"},{"location":"api/classhal_1_1pwm/","title":"Class hal::pwm","text":"<p>ClassList &gt; hal &gt; pwm</p> <p>Pulse Width Modulation (PWM) channel hardware abstraction. More...</p> <ul> <li><code>#include &lt;pwm.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::lpc40::pwm,  hal::mock::pwm,  hal::soft::inert_pwm</p>"},{"location":"api/classhal_1_1pwm/#classes","title":"Classes","text":"Type Name struct duty_cycle_t Feedback setting the pwm duty cycle. struct frequency_t Feedback setting the pwm frequency."},{"location":"api/classhal_1_1pwm/#public-functions","title":"Public Functions","text":"Type Name result&lt; duty_cycle_t &gt; duty_cycle (float p_duty_cycle) Set the pwm waveform duty cycle. result&lt; frequency_t &gt; frequency (hertz p_frequency) Set the pwm waveform frequency. virtual ~pwm () = default"},{"location":"api/classhal_1_1pwm/#detailed-description","title":"Detailed Description","text":"<p>This driver controls the waveform generation of a square wave and its properties such as frequency and duty cycle.</p> <p>Frequency, meaning how often the waveform cycles from from low to high.</p> <p>Duty cycle, what proportion of the wavelength of the pulse is the voltage HIGH.</p> <p>___       _  |                    |     | |                    |___|  ^                    ^     ^  |&lt;------ high ------&gt;|| <p>HIGH Duration = 18 segments  LOW Duration =  5 segments  Duty Cycle = 20 / (20 + 5) = 80%</p> <p>If each segment is 1us then the wavelength is 25us  Thus frequency is (1 / 25us) = 40kHz</p> <p>PWM is used for power control like motor control, lighting, transmitting signals to servos, sending telemetry and much more. </p>"},{"location":"api/classhal_1_1pwm/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1pwm/#function-duty_cycle","title":"function duty_cycle","text":"<p>Set the pwm waveform duty cycle. <pre><code>inline result&lt; duty_cycle_t &gt; hal::pwm::duty_cycle (\n    float p_duty_cycle\n) \n</code></pre></p> <p>The input value <code>p_duty_cycle</code> is a 32-bit floating point value from 0.0f to 1.0f.</p> <p>The floating point value is directly proportional to the duty cycle percentage, such that 0.0f is 0%, 0.25f is 25%, 0.445f is 44.5% and 1.0f is 100%.</p> <p>This function clamps the input value between 0.0f and 1.0f and thus values passed to driver implementations are guaranteed to be within this range. Callers of this function do not need to clamp their values before passing them into this function as it would be redundant. The rationale for doing this at the interface layer is that it allows callers and driver implementors to omit redundant clamping code, reducing code bloat.</p> <p>Parameters:</p> <ul> <li><code>p_duty_cycle</code> - a value from 0.0f to +1.0f representing the duty cycle percentage. </li> </ul> <p>Returns:</p> <p>result&lt;duty_cycle_t&gt; - success or failure </p>"},{"location":"api/classhal_1_1pwm/#function-frequency","title":"function frequency","text":"<p>Set the pwm waveform frequency. <pre><code>inline result&lt; frequency_t &gt; hal::pwm::frequency (\n    hertz p_frequency\n) \n</code></pre></p> <p>This function clamps the input value between 1.0_Hz and 1.0_GHz and thus values passed to driver implementations are guaranteed to be within this range. Callers of this function do not need to clamp their values before passing them into this function as it would be redundant. The rationale for doing this at the interface layer is that it allows callers and driver implementors to omit redundant clamping code, reducing code bloat.</p> <p>Parameters:</p> <ul> <li><code>p_frequency</code> - settings to apply to pwm driver </li> </ul> <p>Returns:</p> <p>result&lt;frequency_t&gt; - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::argument_out_of_domain</code> - if the frequency is beyond what the pwm generator is capable of achieving. </li> </ul>"},{"location":"api/classhal_1_1pwm/#function-pwm","title":"function ~pwm","text":"<pre><code>virtual hal::pwm::~pwm () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/pwm.hpp</code></p>"},{"location":"api/structhal_1_1pwm_1_1duty__cycle__t/","title":"Struct hal::pwm::duty_cycle_t","text":"<p>ClassList &gt; hal &gt; pwm &gt; duty_cycle_t</p> <p>Feedback setting the pwm duty cycle. More...</p> <ul> <li><code>#include &lt;pwm.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1pwm_1_1duty__cycle__t/#detailed-description","title":"Detailed Description","text":"<p>This structure is currently empty as no feedback has been determined for now. This structure may be expanded in the future. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/pwm.hpp</code></p>"},{"location":"api/structhal_1_1pwm_1_1frequency__t/","title":"Struct hal::pwm::frequency_t","text":"<p>ClassList &gt; hal &gt; pwm &gt; frequency_t</p> <p>Feedback setting the pwm frequency. More...</p> <ul> <li><code>#include &lt;pwm.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1pwm_1_1frequency__t/#detailed-description","title":"Detailed Description","text":"<p>This structure is currently empty as no feedback has been determined for now. This structure may be expanded in the future. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/pwm.hpp</code></p>"},{"location":"api/classhal_1_1read__into/","title":"Class hal::read_into","text":"<p>ClassList &gt; hal &gt; read_into</p> <p>Non-blocking callable for reading serial data into a buffer. </p> <ul> <li><code>#include &lt;serial_coroutines.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1read__into/#public-functions","title":"Public Functions","text":"Type Name result&lt; work_state &gt; operator() () read data into the buffer. read_into (serial &amp; p_serial, std::span&lt; hal::byte &gt; p_buffer, size_t p_read_limit=32) Construct a new read_into object."},{"location":"api/classhal_1_1read__into/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1read__into/#function-operator","title":"function operator()","text":"<p>read data into the buffer. <pre><code>inline result&lt; work_state &gt; hal::read_into::operator() () \n</code></pre></p> <p>This function will return if the read limit is reached or if there are no more bytes in the serial port.</p> <p>Call this function again to resume reading from the port.</p> <p>Returns:</p> <p>result&lt;work_state&gt; - work_state::in_progress if the sequence hasn't been met and the buffer still has space. </p> <p>Returns:</p> <p>result&lt;work_state&gt; - work_state::finished if the sequence was found before the buffer was filled completely. </p>"},{"location":"api/classhal_1_1read__into/#function-read_into","title":"function read_into","text":"<p>Construct a new read_into object. <pre><code>inline hal::read_into::read_into (\n    serial &amp; p_serial,\n    std::span&lt; hal::byte &gt; p_buffer,\n    size_t p_read_limit=32\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_serial</code> - serial port to skip through </li> <li><code>p_buffer</code> - buffer to read data into </li> <li><code>p_read_limit</code> - the maximum number read attempts from the port before returning. A value 0 will result in no reads from the serial port. </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/serial_coroutines.hpp</code></p>"},{"location":"api/classhal_1_1read__uint32/","title":"Class hal::read_uint32","text":"<p>ClassList &gt; hal &gt; read_uint32</p> <p>Read bytes from serial port and convert to integer. </p> <ul> <li><code>#include &lt;serial_coroutines.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1read__uint32/#public-functions","title":"Public Functions","text":"Type Name std::optional&lt; uint32_t &gt; get ()  result&lt; work_state &gt; operator() () parse serial data and convert to an integer read_uint32 (serial &amp; p_serial, size_t p_read_limit=32) Construct a new read_uint32 object."},{"location":"api/classhal_1_1read__uint32/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1read__uint32/#function-get","title":"function get","text":"<pre><code>inline std::optional&lt; uint32_t &gt; hal::read_uint32::get () \n</code></pre> <p>Returns:</p> <p>std::optional&lt;uint32_t&gt; - integer if the parsing is finished or std::nullopt </p>"},{"location":"api/classhal_1_1read__uint32/#function-operator","title":"function operator()","text":"<p>parse serial data and convert to an integer <pre><code>inline result&lt; work_state &gt; hal::read_uint32::operator() () \n</code></pre></p> <p>This function will return if an integer ws found or no more bytes in the serial port.</p> <p>Call this function again to resume reading from the port.</p> <p>Returns:</p> <p>result&lt;work_state&gt; - work_state::in_progress - if an integer hasn't been found </p> <p>Returns:</p> <p>result&lt;work_state&gt; - work_state::finished - integer has been found and a non-integer byte has also been found. </p>"},{"location":"api/classhal_1_1read__uint32/#function-read_uint32","title":"function read_uint32","text":"<p>Construct a new read_uint32 object. <pre><code>inline hal::read_uint32::read_uint32 (\n    serial &amp; p_serial,\n    size_t p_read_limit=32\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_serial</code> - serial port to skip through </li> <li><code>p_read_limit</code> - the maximum number read attempts from the port before returning. A value 0 will result in no reads from the serial port. </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/serial_coroutines.hpp</code></p>"},{"location":"api/classhal_1_1read__upto/","title":"Class hal::read_upto","text":"<p>ClassList &gt; hal &gt; read_upto</p> <p>Discard received bytes until the sequence is found. </p> <ul> <li><code>#include &lt;serial_coroutines.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1read__upto/#public-functions","title":"Public Functions","text":"Type Name result&lt; work_state &gt; operator() () read data into the buffer. read_upto (serial &amp; p_serial, std::span&lt; const hal::byte &gt; p_sequence, std::span&lt; hal::byte &gt; p_buffer, size_t p_read_limit=32) Construct a new skip beyond object."},{"location":"api/classhal_1_1read__upto/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1read__upto/#function-operator","title":"function operator()","text":"<p>read data into the buffer. <pre><code>inline result&lt; work_state &gt; hal::read_upto::operator() () \n</code></pre></p> <p>This function will return if the read limit is reached or if there are no more bytes in the serial port.</p> <p>Call this function again to resume reading from the port.</p> <p>Returns:</p> <p>result&lt;work_state&gt; - work_state::in_progress if the sequence hasn't been met and the buffer still has space. </p> <p>Returns:</p> <p>result&lt;work_state&gt; - work_state::failed if the sequence wasn't found before the buffer was filled completely. </p> <p>Returns:</p> <p>result&lt;work_state&gt; - work_state::finished if the sequence was found before the buffer was filled completely. </p>"},{"location":"api/classhal_1_1read__upto/#function-read_upto","title":"function read_upto","text":"<p>Construct a new skip beyond object. <pre><code>inline hal::read_upto::read_upto (\n    serial &amp; p_serial,\n    std::span&lt; const hal::byte &gt; p_sequence,\n    std::span&lt; hal::byte &gt; p_buffer,\n    size_t p_read_limit=32\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_serial</code> - serial port to skip through </li> <li><code>p_sequence</code> - sequence to search for. The lifetime of this data pointed to by this span must outlive this object, or not be used when the lifetime of that data is no longer available. </li> <li><code>p_buffer</code> - buffer to fill data into </li> <li><code>p_read_limit</code> - the maximum number of bytes to read off from the serial port before returning. A value 0 will result in no reads from the serial port. </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/serial_coroutines.hpp</code></p>"},{"location":"api/namespacehal_1_1rmd/","title":"Namespace hal::rmd","text":"<p>Namespace List &gt; hal &gt; rmd</p>"},{"location":"api/namespacehal_1_1rmd/#classes","title":"Classes","text":"Type Name class drc Driver for RMD motors equip with the DRC motor drivers. class drc_motor Motor interface adaptor for DRC. class drc_rotation_sensor Rotation sensor adaptor for DRC motors. class drc_servo Servo interface adaptor for DRC. class drc_temperature_sensor Temperature sensor adaptor for DRC motors. class mc_x Driver for RMD series motors equip with the MC-X motor driver. class mc_x_motor Control a mc_x motor driver like ahal::motor . class mc_x_rotation Reports the rotation of the DRC motor. class mc_x_servo Control a mc_x motor driver like ahal::servo . class mc_x_temperature Reports the temperature of the DRC motor."},{"location":"api/namespacehal_1_1rmd/#public-functions","title":"Public Functions","text":"Type Name result&lt; drc_motor &gt; make_motor (drc &amp; p_drc, hal::rpm p_max_speed) Create a hal::motor implementation from the drc driver. result&lt; mc_x_motor &gt; make_motor (mc_x &amp; p_mc_x, hal::rpm p_max_speed) Create a hal::motor driver using the MC-X driver. result&lt; drc_rotation_sensor &gt; make_rotation_sensor (drc &amp; p_drc) Create a hal::rotation_sensor driver using the drc driver. result&lt; mc_x_rotation &gt; make_rotation_sensor (mc_x &amp; p_mc_x) Create a hal::rotation_sensor driver using the MC-X driver. result&lt; drc_servo &gt; make_servo (drc &amp; p_drc, hal::rpm p_max_speed) Create a hal::servo driver using the drc driver. result&lt; mc_x_servo &gt; make_servo (mc_x &amp; p_mc_x, hal::rpm p_max_speed) Create a hal::rotation_sensor driver using the MC-X driver. result&lt; drc_temperature_sensor &gt; make_temperature_sensor (drc &amp; p_drc) Create a hal::temperature_sensor driver using the drc driver. result&lt; mc_x_temperature &gt; make_temperature_sensor (mc_x &amp; p_mc_x) Create a hal::temperature_sensor driver using the MC-X driver."},{"location":"api/namespacehal_1_1rmd/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacehal_1_1rmd/#function-make_motor","title":"function make_motor","text":"<p>Create a hal::motor implementation from the drc driver. <pre><code>result&lt; drc_motor &gt; hal::rmd::make_motor (\n    drc &amp; p_drc,\n    hal::rpm p_max_speed\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_drc</code> - reference to a drc driver. This object's lifetime must NOT exceed the lifetime of the return drc motor. </li> <li><code>p_max_speed</code> - maximum speed of the motor represented by +1.0 and -1.0 </li> </ul> <p>Returns:</p> <p>drc_motor - motor implementation based on the drc driver </p>"},{"location":"api/namespacehal_1_1rmd/#function-make_motor_1","title":"function make_motor","text":"<p>Create a hal::motor driver using the MC-X driver. <pre><code>result&lt; mc_x_motor &gt; hal::rmd::make_motor (\n    mc_x &amp; p_mc_x,\n    hal::rpm p_max_speed\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_mc_x</code> - reference to a MC-X driver. This object's lifetime must exceed the lifetime of the returned object. </li> <li><code>p_max_speed</code> - maximum speed of the motor represented by +1.0 and -1.0 </li> </ul> <p>Returns:</p> <p>result&lt;mc_x_motor&gt; - motor implementation using the MC-X driver </p>"},{"location":"api/namespacehal_1_1rmd/#function-make_rotation_sensor","title":"function make_rotation_sensor","text":"<p>Create a hal::rotation_sensor driver using the drc driver. <pre><code>result&lt; drc_rotation_sensor &gt; hal::rmd::make_rotation_sensor (\n    drc &amp; p_drc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_drc</code> - reference to a drc driver. This object's lifetime must exceed the lifetime of the returned object. </li> </ul> <p>Returns:</p> <p>drc_rotation_sensor - motor implementation based on the drc driver </p>"},{"location":"api/namespacehal_1_1rmd/#function-make_rotation_sensor_1","title":"function make_rotation_sensor","text":"<p>Create a hal::rotation_sensor driver using the MC-X driver. <pre><code>result&lt; mc_x_rotation &gt; hal::rmd::make_rotation_sensor (\n    mc_x &amp; p_mc_x\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_mc_x</code> - reference to a MC-X driver. This object's lifetime must exceed the lifetime of the returned object. </li> </ul> <p>Returns:</p> <p>result&lt;mc_x_rotation&gt; - rotation sensor implementation based on the MC-X driver </p>"},{"location":"api/namespacehal_1_1rmd/#function-make_servo","title":"function make_servo","text":"<p>Create a hal::servo driver using the drc driver. <pre><code>result&lt; drc_servo &gt; hal::rmd::make_servo (\n    drc &amp; p_drc,\n    hal::rpm p_max_speed\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_drc</code> - reference to a drc driver. This object's lifetime must exceed the lifetime of the returned object. </li> <li><code>p_max_speed</code> - maximum speed of the motor when moving to an angle </li> </ul> <p>Returns:</p> <p>result&lt;drc_servo&gt; - motor implementation based on the drc driver </p>"},{"location":"api/namespacehal_1_1rmd/#function-make_servo_1","title":"function make_servo","text":"<p>Create a hal::rotation_sensor driver using the MC-X driver. <pre><code>result&lt; mc_x_servo &gt; hal::rmd::make_servo (\n    mc_x &amp; p_mc_x,\n    hal::rpm p_max_speed\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_mc_x</code> - reference to a MC-X driver. This object's lifetime must exceed the lifetime of the returned object. </li> <li><code>p_max_speed</code> - maximum speed of the motor when moving to an angle </li> </ul> <p>Returns:</p> <p>result&lt;mc_x_rotation&gt; - rotation sensor implementation based on the MC-X driver </p>"},{"location":"api/namespacehal_1_1rmd/#function-make_temperature_sensor","title":"function make_temperature_sensor","text":"<p>Create a hal::temperature_sensor driver using the drc driver. <pre><code>result&lt; drc_temperature_sensor &gt; hal::rmd::make_temperature_sensor (\n    drc &amp; p_drc\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_drc</code> - reference to a drc driver. This object's lifetime must exceed the lifetime of the returned object. </li> </ul> <p>Returns:</p> <p>result&lt;drc_temperature_sensor&gt; - temperature sensor implementation based on the drc driver. </p>"},{"location":"api/namespacehal_1_1rmd/#function-make_temperature_sensor_1","title":"function make_temperature_sensor","text":"<p>Create a hal::temperature_sensor driver using the MC-X driver. <pre><code>result&lt; mc_x_temperature &gt; hal::rmd::make_temperature_sensor (\n    mc_x &amp; p_mc_x\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_mc_x</code> - reference to a MC-X driver. This object's lifetime must exceed the lifetime of the returned object. </li> </ul> <p>Returns:</p> <p>result&lt;mc_x_temperature&gt; - temperature sensor implementation based on the MC-X driver </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/drc.hpp</code></p>"},{"location":"api/classhal_1_1rmd_1_1drc/","title":"Class hal::rmd::drc","text":"<p>ClassList &gt; hal &gt; rmd &gt; drc</p> <p>Driver for RMD motors equip with the DRC motor drivers. </p> <ul> <li><code>#include &lt;drc.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1rmd_1_1drc/#classes","title":"Classes","text":"Type Name struct feedback_t"},{"location":"api/classhal_1_1rmd_1_1drc/#public-types","title":"Public Types","text":"Type Name enum hal::byte actuate Commands for actuate the motor. enum hal::byte read Commands that can be issued to a RMD-X motor. enum hal::byte system Commands for controlling the motor as a whole. enum hal::byte write Commands for updating motor configuration data."},{"location":"api/classhal_1_1rmd_1_1drc/#public-functions","title":"Public Functions","text":"Type Name drc (drc &amp; p_other) = delete drc (drc &amp;&amp; p_other) noexcept const feedback_t &amp; feedback () const status feedback_request (read p_command) Request feedback from the motor. void operator() (const can::message_t &amp; p_message) Handle messages from the canbus with this devices ID. drc &amp; operator= (drc &amp; p_other) = delete drc &amp; operator= (drc &amp;&amp; p_other) noexcept status position_control (degrees p_angle, rpm speed) Move motor shaft to a specific angle. status system_control (system p_system_command) Send system control commands to the device. status velocity_control (rpm p_speed) Rotate motor shaft at the designated speed."},{"location":"api/classhal_1_1rmd_1_1drc/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; drc &gt; create (hal::can_router &amp; p_router, hal::steady_clock &amp; p_clock, float p_gear_ratio, can::id_t device_id, hal::time_duration p_max_response_time=std::chrono::milliseconds(10)) Create a new drc device driver."},{"location":"api/classhal_1_1rmd_1_1drc/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classhal_1_1rmd_1_1drc/#enum-actuate","title":"enum actuate","text":"<pre><code>enum hal::rmd::drc::actuate {\n    speed = 0xA2,\n    position_2 = 0xA4\n};\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1drc/#enum-read","title":"enum read","text":"<pre><code>enum hal::rmd::drc::read {\n    multi_turns_angle = 0x92,\n    status_1_and_error_flags = 0x9A,\n    status_2 = 0x9C\n};\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1drc/#enum-system","title":"enum system","text":"<pre><code>enum hal::rmd::drc::system {\n    clear_error_flag = 0x9B,\n    off = 0x80,\n    stop = 0x81,\n    running = 0x88\n};\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1drc/#enum-write","title":"enum write","text":"<pre><code>enum hal::rmd::drc::write {\n    pid_to_ram = 0x31,\n    pid_to_rom = 0x32,\n    acceleration_data_to_ram = 0x34,\n    encoder_offset = 0x91,\n    current_position_to_rom_as_motor_zero = 0x19\n};\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1drc/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1rmd_1_1drc/#function-drc-13","title":"function drc [1/3]","text":"<pre><code>hal::rmd::drc::drc (\n    drc &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1drc/#function-drc-23","title":"function drc [2/3]","text":"<pre><code>hal::rmd::drc::drc (\n    drc &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1drc/#function-feedback","title":"function feedback","text":"<pre><code>const feedback_t &amp; hal::rmd::drc::feedback () const\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1drc/#function-feedback_request","title":"function feedback_request","text":"<p>Request feedback from the motor. <pre><code>status hal::rmd::drc::feedback_request (\n    read p_command\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_command</code> - the request to command the motor to respond with </li> </ul> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::timed_out</code> - if a response is not returned within the max response time set at creation. </li> </ul>"},{"location":"api/classhal_1_1rmd_1_1drc/#function-operator","title":"function operator()","text":"<p>Handle messages from the canbus with this devices ID. <pre><code>void hal::rmd::drc::operator() (\n    const can::message_t &amp; p_message\n) \n</code></pre></p> <p>Meant mostly for testing purposes.</p> <p>Parameters:</p> <ul> <li><code>p_message</code> - message received from the bus </li> </ul>"},{"location":"api/classhal_1_1rmd_1_1drc/#function-operator_1","title":"function operator=","text":"<pre><code>drc &amp; hal::rmd::drc::operator= (\n    drc &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1drc/#function-operator_2","title":"function operator=","text":"<pre><code>drc &amp; hal::rmd::drc::operator= (\n    drc &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1drc/#function-position_control","title":"function position_control","text":"<p>Move motor shaft to a specific angle. <pre><code>status hal::rmd::drc::position_control (\n    degrees p_angle,\n    rpm speed\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_angle</code> - angle position in degrees to move to </li> <li><code>speed</code> - maximum speed in rpm's </li> </ul> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::timed_out</code> - if a response is not returned within the max response time set at creation. </li> </ul>"},{"location":"api/classhal_1_1rmd_1_1drc/#function-system_control","title":"function system_control","text":"<p>Send system control commands to the device. <pre><code>status hal::rmd::drc::system_control (\n    system p_system_command\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_system_command</code> - system control command to send to the device </li> </ul> <p>Returns:</p> <p>status - success or failure status </p> <p>Exception:</p> <ul> <li><code>std::errc::timed_out</code> - if a response is not returned within the max response time set at creation. </li> </ul>"},{"location":"api/classhal_1_1rmd_1_1drc/#function-velocity_control","title":"function velocity_control","text":"<p>Rotate motor shaft at the designated speed. <pre><code>status hal::rmd::drc::velocity_control (\n    rpm p_speed\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_speed</code> - speed in rpm to move the motor shaft at. Positive values rotate the motor shaft clockwise, negative values rotate the motor shaft counter-clockwise assuming you are looking directly at the motor shaft. </li> </ul> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::timed_out</code> - if a response is not returned within the max response time set at creation. </li> </ul>"},{"location":"api/classhal_1_1rmd_1_1drc/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1rmd_1_1drc/#function-create","title":"function create","text":"<p>Create a new drc device driver. <pre><code>static result&lt; drc &gt; hal::rmd::drc::create (\n    hal::can_router &amp; p_router,\n    hal::steady_clock &amp; p_clock,\n    float p_gear_ratio,\n    can::id_t device_id,\n    hal::time_duration p_max_response_time=std::chrono::milliseconds(10)\n) \n</code></pre></p> <p>This factory function will power cycle the motor</p> <p>Parameters:</p> <ul> <li><code>p_router</code> - can router to use </li> <li><code>p_clock</code> - clocked used to determine timeouts </li> <li><code>p_gear_ratio</code> - gear ratio of the motor </li> <li><code>device_id</code> - The CAN ID of the motor </li> <li><code>p_max_response_time</code> - maximum amount of time to wait for a response from the motor. </li> </ul> <p>Returns:</p> <p>result&lt;drc&gt; - the drc driver or an error </p> <p>Exception:</p> <ul> <li><code>std::errc::timed_out</code> - a response is not returned within the max response time when attempting to power cycle. </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/drc.hpp</code></p>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/","title":"Struct hal::rmd::drc::feedback_t","text":"<p>ClassList &gt; hal &gt; rmd &gt; drc &gt; feedback_t</p> <p>More...</p> <ul> <li><code>#include &lt;drc.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#public-attributes","title":"Public Attributes","text":"Type Name std::int16_t encoder   = { 0 }Signed 16-bit raw encoder count value of the motor. std::uint32_t message_number   = = 0 std::int16_t raw_current   = { 0 } std::uint8_t raw_error_state   = { 0 }8-bit value containing error flag information std::int8_t raw_motor_temperature   = { 0 }Core temperature of the motor (1C/LSB) std::int64_t raw_multi_turn_angle   = { 0 }Raw multi-turn angle (0.01\u00b0/LSB) std::int16_t raw_speed   = { 0 }Rotational velocity of the motor (1 degrees per second (dps)/LSB) std::int16_t raw_volts   = { 0 }Motor's supply voltage (0.1V/LSB)"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#public-functions","title":"Public Functions","text":"Type Name hal::degrees angle () noexcept const hal::ampere current () noexcept const bool over_temperature_protection_tripped () noexcept constReturn if the motor has detected an over temperature event. bool over_voltage_protection_tripped () noexcept constReturn if the motor has detected an over voltage event. hal::rpm speed () noexcept const hal::celsius temperature () noexcept const hal::volts volts () noexcept const"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#detailed-description","title":"Detailed Description","text":"<p>Structure containing all of the forms of feedback acquired by an RMD-X motor </p>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#variable-encoder","title":"variable encoder","text":"<pre><code>std::int16_t hal::rmd::drc::feedback_t::encoder;\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#variable-message_number","title":"variable message_number","text":"<pre><code>std::uint32_t hal::rmd::drc::feedback_t::message_number;\n</code></pre> <p>Every time a message from our motor is received this number increments. This can be used to indicate if the feedback has updated since the last time it was read. </p>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#variable-raw_current","title":"variable raw_current","text":"<pre><code>std::int16_t hal::rmd::drc::feedback_t::raw_current;\n</code></pre> <p>Current flowing through the motor windings (-2048 &lt;-&gt; 2048 ==&gt; -33A &lt;-&gt; 33A) </p>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#variable-raw_error_state","title":"variable raw_error_state","text":"<pre><code>std::uint8_t hal::rmd::drc::feedback_t::raw_error_state;\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#variable-raw_motor_temperature","title":"variable raw_motor_temperature","text":"<pre><code>std::int8_t hal::rmd::drc::feedback_t::raw_motor_temperature;\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#variable-raw_multi_turn_angle","title":"variable raw_multi_turn_angle","text":"<pre><code>std::int64_t hal::rmd::drc::feedback_t::raw_multi_turn_angle;\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#variable-raw_speed","title":"variable raw_speed","text":"<pre><code>std::int16_t hal::rmd::drc::feedback_t::raw_speed;\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#variable-raw_volts","title":"variable raw_volts","text":"<pre><code>std::int16_t hal::rmd::drc::feedback_t::raw_volts;\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#function-angle","title":"function angle","text":"<pre><code>hal::degrees hal::rmd::drc::feedback_t::angle () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#function-current","title":"function current","text":"<pre><code>hal::ampere hal::rmd::drc::feedback_t::current () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#function-over_temperature_protection_tripped","title":"function over_temperature_protection_tripped","text":"<p>Return if the motor has detected an over temperature event. <pre><code>bool hal::rmd::drc::feedback_t::over_temperature_protection_tripped () noexcept const\n</code></pre></p> <p>In order for this field to be updated a feedback_request with status_1_and_error_flags must be issued.</p> <p>Returns:</p> <p>true - over temperature protection tripped </p> <p>Returns:</p> <p>false - over temperature protection has not tripped </p>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#function-over_voltage_protection_tripped","title":"function over_voltage_protection_tripped","text":"<p>Return if the motor has detected an over voltage event. <pre><code>bool hal::rmd::drc::feedback_t::over_voltage_protection_tripped () noexcept const\n</code></pre></p> <p>In order for this field to be updated a feedback_request with status_1_and_error_flags must be issued.</p> <p>Returns:</p> <p>true - over voltage protection tripped </p> <p>Returns:</p> <p>false - over voltage protection has not tripped </p>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#function-speed","title":"function speed","text":"<pre><code>hal::rpm hal::rmd::drc::feedback_t::speed () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#function-temperature","title":"function temperature","text":"<pre><code>hal::celsius hal::rmd::drc::feedback_t::temperature () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1drc_1_1feedback__t/#function-volts","title":"function volts","text":"<pre><code>hal::volts hal::rmd::drc::feedback_t::volts () noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/drc.hpp</code></p>"},{"location":"api/classhal_1_1rmd_1_1drc__motor/","title":"Class hal::rmd::drc_motor","text":"<p>ClassList &gt; hal &gt; rmd &gt; drc_motor</p> <p>Motor interface adaptor for DRC. </p> <ul> <li><code>#include &lt;drc.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::motor</p>"},{"location":"api/classhal_1_1rmd_1_1drc__motor/#public-functions-inherited-from-halmotor","title":"Public Functions inherited from hal::motor","text":"<p>See hal::motor</p> Type Name result&lt; power_t &gt; power (float p_power) Apply power to the motor. virtual ~motor () = default"},{"location":"api/classhal_1_1rmd_1_1drc__motor/#friends-documentation","title":"Friends Documentation","text":""},{"location":"api/classhal_1_1rmd_1_1drc__motor/#friend-make_motor","title":"friend make_motor","text":"<p>Create a hal::motor implementation from the drc driver. <pre><code>result&lt; drc_motor &gt; hal::rmd::drc_motor::make_motor (\n    drc &amp; p_drc,\n    hal::rpm p_max_speed\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_drc</code> - reference to a drc driver. This object's lifetime must NOT exceed the lifetime of the return drc motor. </li> <li><code>p_max_speed</code> - maximum speed of the motor represented by +1.0 and -1.0 </li> </ul> <p>Returns:</p> <p>drc_motor - motor implementation based on the drc driver </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/drc.hpp</code></p>"},{"location":"api/classhal_1_1rmd_1_1drc__rotation__sensor/","title":"Class hal::rmd::drc_rotation_sensor","text":"<p>ClassList &gt; hal &gt; rmd &gt; drc_rotation_sensor</p> <p>Rotation sensor adaptor for DRC motors. </p> <ul> <li><code>#include &lt;drc.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::rotation_sensor</p>"},{"location":"api/classhal_1_1rmd_1_1drc__rotation__sensor/#public-functions-inherited-from-halrotation_sensor","title":"Public Functions inherited from hal::rotation_sensor","text":"<p>See hal::rotation_sensor</p> Type Name result&lt; read_t &gt; read () Read the current angle measured by the device. virtual ~rotation_sensor () = default <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/drc.hpp</code></p>"},{"location":"api/classhal_1_1rmd_1_1drc__servo/","title":"Class hal::rmd::drc_servo","text":"<p>ClassList &gt; hal &gt; rmd &gt; drc_servo</p> <p>Servo interface adaptor for DRC. </p> <ul> <li><code>#include &lt;drc.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::servo</p>"},{"location":"api/classhal_1_1rmd_1_1drc__servo/#public-functions-inherited-from-halservo","title":"Public Functions inherited from hal::servo","text":"<p>See hal::servo</p> Type Name result&lt; position_t &gt; position (hal::degrees p_position) Set the position of the servo's output shaft. virtual ~servo () = default <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/drc.hpp</code></p>"},{"location":"api/classhal_1_1rmd_1_1drc__temperature__sensor/","title":"Class hal::rmd::drc_temperature_sensor","text":"<p>ClassList &gt; hal &gt; rmd &gt; drc_temperature_sensor</p> <p>Temperature sensor adaptor for DRC motors. </p> <ul> <li><code>#include &lt;drc.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::temperature_sensor</p>"},{"location":"api/classhal_1_1rmd_1_1drc__temperature__sensor/#public-functions-inherited-from-haltemperature_sensor","title":"Public Functions inherited from hal::temperature_sensor","text":"<p>See hal::temperature_sensor</p> Type Name result&lt; read_t &gt; read () Read the current temperature measured by the device. virtual ~temperature_sensor () = default <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/drc.hpp</code></p>"},{"location":"api/classhal_1_1rmd_1_1mc__x/","title":"Class hal::rmd::mc_x","text":"<p>ClassList &gt; hal &gt; rmd &gt; mc_x</p> <p>Driver for RMD series motors equip with the MC-X motor driver. </p> <ul> <li><code>#include &lt;mc_x.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#classes","title":"Classes","text":"Type Name struct feedback_t"},{"location":"api/classhal_1_1rmd_1_1mc__x/#public-types","title":"Public Types","text":"Type Name enum hal::byte actuate Commands for actuate the motor. enum hal::byte read Commands that can be issued to a RMD-X motor. enum hal::byte system Commands for controlling the motor as a whole. enum hal::byte write Commands for updating motor configuration data."},{"location":"api/classhal_1_1rmd_1_1mc__x/#public-functions","title":"Public Functions","text":"Type Name const feedback_t &amp; feedback () constGet feedback about the motor. status feedback_request (read p_command) Request feedback from the motor. mc_x (mc_x &amp; p_other) = delete mc_x (mc_x &amp;&amp; p_other) noexcept void operator() (const can::message_t &amp; p_message) Handle messages from the can bus with this devices ID. mc_x &amp; operator= (mc_x &amp; p_other) = delete mc_x &amp; operator= (mc_x &amp;&amp; p_other) noexcept status position_control (degrees p_angle, rpm speed) Move motor shaft to a specific angle. status system_control (system p_system_command) Send system control commands to the device. status velocity_control (rpm p_speed) Rotate motor shaft at the designated speed."},{"location":"api/classhal_1_1rmd_1_1mc__x/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; mc_x &gt; create (hal::can_router &amp; p_router, hal::steady_clock &amp; p_clock, float p_gear_ratio, can::id_t device_id, hal::time_duration p_max_response_time=std::chrono::milliseconds(10)) Create a new mc_x device driver."},{"location":"api/classhal_1_1rmd_1_1mc__x/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classhal_1_1rmd_1_1mc__x/#enum-actuate","title":"enum actuate","text":"<pre><code>enum hal::rmd::mc_x::actuate {\n    torque = 0xA1,\n    speed = 0xA2,\n    position = 0xA5\n};\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#enum-read","title":"enum read","text":"<pre><code>enum hal::rmd::mc_x::read {\n    multi_turns_angle = 0x92,\n    status_1_and_error_flags = 0x9A,\n    status_2 = 0x9C\n};\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#enum-system","title":"enum system","text":"<pre><code>enum hal::rmd::mc_x::system {\n    off = 0x80,\n    stop = 0x81\n};\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#enum-write","title":"enum write","text":"<pre><code>enum hal::rmd::mc_x::write;\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1rmd_1_1mc__x/#function-feedback","title":"function feedback","text":"<p>Get feedback about the motor. <pre><code>const feedback_t &amp; hal::rmd::mc_x::feedback () const\n</code></pre></p> <p>This object contains cached data from each response returned from the motor. It is updated when any of the control or feedback APIs are called. This object will not update without one of those APIs being called.</p> <p>Returns:</p> <p>const feedback_t&amp; - information about the motor </p> <p>Exception:</p> <ul> <li><code>std::errc::timed_out</code> - if a response is not returned within the max response time set at creation. </li> </ul>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#function-feedback_request","title":"function feedback_request","text":"<p>Request feedback from the motor. <pre><code>status hal::rmd::mc_x::feedback_request (\n    read p_command\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_command</code> - the request to command the motor to respond with </li> </ul> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::timed_out</code> - if a response is not returned within the max response time set at creation. </li> </ul>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#function-mc_x-13","title":"function mc_x [1/3]","text":"<pre><code>hal::rmd::mc_x::mc_x (\n    mc_x &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#function-mc_x-23","title":"function mc_x [2/3]","text":"<pre><code>hal::rmd::mc_x::mc_x (\n    mc_x &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#function-operator","title":"function operator()","text":"<p>Handle messages from the can bus with this devices ID. <pre><code>void hal::rmd::mc_x::operator() (\n    const can::message_t &amp; p_message\n) \n</code></pre></p> <p>Meant mostly for testing purposes.</p> <p>Parameters:</p> <ul> <li><code>p_message</code> - message received from the bus </li> </ul>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#function-operator_1","title":"function operator=","text":"<pre><code>mc_x &amp; hal::rmd::mc_x::operator= (\n    mc_x &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#function-operator_2","title":"function operator=","text":"<pre><code>mc_x &amp; hal::rmd::mc_x::operator= (\n    mc_x &amp;&amp; p_other\n) noexcept\n</code></pre>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#function-position_control","title":"function position_control","text":"<p>Move motor shaft to a specific angle. <pre><code>status hal::rmd::mc_x::position_control (\n    degrees p_angle,\n    rpm speed\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_angle</code> - angle position in degrees to move to </li> <li><code>speed</code> - speed in rpm's </li> </ul> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::timed_out</code> - if a response is not returned within the max response time set at creation. </li> </ul>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#function-system_control","title":"function system_control","text":"<p>Send system control commands to the device. <pre><code>status hal::rmd::mc_x::system_control (\n    system p_system_command\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_system_command</code> - system control command to send to the device </li> </ul> <p>Returns:</p> <p>status - success or failure status </p> <p>Exception:</p> <ul> <li><code>std::errc::timed_out</code> - if a response is not returned within the max response time set at creation. </li> </ul>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#function-velocity_control","title":"function velocity_control","text":"<p>Rotate motor shaft at the designated speed. <pre><code>status hal::rmd::mc_x::velocity_control (\n    rpm p_speed\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_speed</code> - speed in rpm to move the motor shaft at. Positive values rotate the motor shaft clockwise, negative values rotate the motor shaft counter-clockwise assuming you are looking directly at the motor shaft. </li> </ul> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::timed_out</code> - if a response is not returned within the max response time set at creation. </li> </ul>"},{"location":"api/classhal_1_1rmd_1_1mc__x/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1rmd_1_1mc__x/#function-create","title":"function create","text":"<p>Create a new mc_x device driver. <pre><code>static result&lt; mc_x &gt; hal::rmd::mc_x::create (\n    hal::can_router &amp; p_router,\n    hal::steady_clock &amp; p_clock,\n    float p_gear_ratio,\n    can::id_t device_id,\n    hal::time_duration p_max_response_time=std::chrono::milliseconds(10)\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_router</code> - can router to use </li> <li><code>p_clock</code> - clocked used to determine timeouts </li> <li><code>p_gear_ratio</code> - gear ratio of the motor </li> <li><code>device_id</code> - The CAN ID of the motor </li> <li><code>p_max_response_time</code> - maximum amount of time to wait for a response from the motor. </li> </ul> <p>Returns:</p> <p>result&lt;mc_x&gt; - the mc_x driver or an error (no errors are currently generated from this function) </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/mc_x.hpp</code></p>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/","title":"Struct hal::rmd::mc_x::feedback_t","text":"<p>ClassList &gt; hal &gt; rmd &gt; mc_x &gt; feedback_t</p> <p>More...</p> <ul> <li><code>#include &lt;mc_x.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#public-attributes","title":"Public Attributes","text":"Type Name std::int16_t encoder   = { 0 }Signed 16-bit raw encoder count value of the motor. std::uint32_t message_number   = = 0 std::int16_t raw_current   = { 0 } std::uint16_t raw_error_state   = { 0 }16-bit value containing error flag information std::int8_t raw_motor_temperature   = { 0 }Core temperature of the motor (1C/LSB) std::int64_t raw_multi_turn_angle   = { 0 } std::int16_t raw_speed   = { 0 }Rotational velocity of the motor (1 degrees per second (dps)/LSB) std::int16_t raw_volts   = { 0 }Motor's supply voltage (0.1V/LSB)"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#public-functions","title":"Public Functions","text":"Type Name hal::degrees angle () noexcept const hal::ampere current () noexcept const bool encoder_calibration_error () noexcept const bool low_pressure () noexcept const bool motor_stall () noexcept const bool over_current () noexcept const bool over_temperature () noexcept const bool over_voltage () noexcept const bool power_overrun () noexcept const hal::rpm speed () noexcept const bool speeding () noexcept const hal::celsius temperature () noexcept const hal::volts volts () noexcept const"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#detailed-description","title":"Detailed Description","text":"<p>Structure containing all of the forms of feedback acquired by an RMD-X motor </p>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#variable-encoder","title":"variable encoder","text":"<pre><code>std::int16_t hal::rmd::mc_x::feedback_t::encoder;\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#variable-message_number","title":"variable message_number","text":"<pre><code>std::uint32_t hal::rmd::mc_x::feedback_t::message_number;\n</code></pre> <p>Every time a message from our motor is received this number increments. This can be used to indicate if the feedback has updated since the last time it was read. </p>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#variable-raw_current","title":"variable raw_current","text":"<pre><code>std::int16_t hal::rmd::mc_x::feedback_t::raw_current;\n</code></pre> <p>Current flowing through the motor windings (-2048 &lt;-&gt; 2048 ==&gt; -33A &lt;-&gt; 33A) </p>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#variable-raw_error_state","title":"variable raw_error_state","text":"<pre><code>std::uint16_t hal::rmd::mc_x::feedback_t::raw_error_state;\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#variable-raw_motor_temperature","title":"variable raw_motor_temperature","text":"<pre><code>std::int8_t hal::rmd::mc_x::feedback_t::raw_motor_temperature;\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#variable-raw_multi_turn_angle","title":"variable raw_multi_turn_angle","text":"<pre><code>std::int64_t hal::rmd::mc_x::feedback_t::raw_multi_turn_angle;\n</code></pre> <p>Represents the multi-turn absolute angle of the encoder relative to its zero starting point (0.01\u00b0/LSB) </p>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#variable-raw_speed","title":"variable raw_speed","text":"<pre><code>std::int16_t hal::rmd::mc_x::feedback_t::raw_speed;\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#variable-raw_volts","title":"variable raw_volts","text":"<pre><code>std::int16_t hal::rmd::mc_x::feedback_t::raw_volts;\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#function-angle","title":"function angle","text":"<pre><code>hal::degrees hal::rmd::mc_x::feedback_t::angle () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#function-current","title":"function current","text":"<pre><code>hal::ampere hal::rmd::mc_x::feedback_t::current () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#function-encoder_calibration_error","title":"function encoder_calibration_error","text":"<pre><code>bool hal::rmd::mc_x::feedback_t::encoder_calibration_error () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#function-low_pressure","title":"function low_pressure","text":"<pre><code>bool hal::rmd::mc_x::feedback_t::low_pressure () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#function-motor_stall","title":"function motor_stall","text":"<pre><code>bool hal::rmd::mc_x::feedback_t::motor_stall () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#function-over_current","title":"function over_current","text":"<pre><code>bool hal::rmd::mc_x::feedback_t::over_current () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#function-over_temperature","title":"function over_temperature","text":"<pre><code>bool hal::rmd::mc_x::feedback_t::over_temperature () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#function-over_voltage","title":"function over_voltage","text":"<pre><code>bool hal::rmd::mc_x::feedback_t::over_voltage () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#function-power_overrun","title":"function power_overrun","text":"<pre><code>bool hal::rmd::mc_x::feedback_t::power_overrun () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#function-speed","title":"function speed","text":"<pre><code>hal::rpm hal::rmd::mc_x::feedback_t::speed () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#function-speeding","title":"function speeding","text":"<pre><code>bool hal::rmd::mc_x::feedback_t::speeding () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#function-temperature","title":"function temperature","text":"<pre><code>hal::celsius hal::rmd::mc_x::feedback_t::temperature () noexcept const\n</code></pre>"},{"location":"api/structhal_1_1rmd_1_1mc__x_1_1feedback__t/#function-volts","title":"function volts","text":"<pre><code>hal::volts hal::rmd::mc_x::feedback_t::volts () noexcept const\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/mc_x.hpp</code></p>"},{"location":"api/classhal_1_1rmd_1_1mc__x__motor/","title":"Class hal::rmd::mc_x_motor","text":"<p>ClassList &gt; hal &gt; rmd &gt; mc_x_motor</p> <p>Control a mc_x motor driver like ahal::motor .</p> <ul> <li><code>#include &lt;mc_x.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::motor</p>"},{"location":"api/classhal_1_1rmd_1_1mc__x__motor/#public-functions-inherited-from-halmotor","title":"Public Functions inherited from hal::motor","text":"<p>See hal::motor</p> Type Name result&lt; power_t &gt; power (float p_power) Apply power to the motor. virtual ~motor () = default <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/mc_x.hpp</code></p>"},{"location":"api/classhal_1_1rmd_1_1mc__x__rotation/","title":"Class hal::rmd::mc_x_rotation","text":"<p>ClassList &gt; hal &gt; rmd &gt; mc_x_rotation</p> <p>Reports the rotation of the DRC motor. </p> <ul> <li><code>#include &lt;mc_x.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::rotation_sensor</p>"},{"location":"api/classhal_1_1rmd_1_1mc__x__rotation/#public-functions-inherited-from-halrotation_sensor","title":"Public Functions inherited from hal::rotation_sensor","text":"<p>See hal::rotation_sensor</p> Type Name result&lt; read_t &gt; read () Read the current angle measured by the device. virtual ~rotation_sensor () = default <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/mc_x.hpp</code></p>"},{"location":"api/classhal_1_1rmd_1_1mc__x__servo/","title":"Class hal::rmd::mc_x_servo","text":"<p>ClassList &gt; hal &gt; rmd &gt; mc_x_servo</p> <p>Control a mc_x motor driver like ahal::servo .</p> <ul> <li><code>#include &lt;mc_x.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::servo</p>"},{"location":"api/classhal_1_1rmd_1_1mc__x__servo/#public-functions-inherited-from-halservo","title":"Public Functions inherited from hal::servo","text":"<p>See hal::servo</p> Type Name result&lt; position_t &gt; position (hal::degrees p_position) Set the position of the servo's output shaft. virtual ~servo () = default <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/mc_x.hpp</code></p>"},{"location":"api/classhal_1_1rmd_1_1mc__x__temperature/","title":"Class hal::rmd::mc_x_temperature","text":"<p>ClassList &gt; hal &gt; rmd &gt; mc_x_temperature</p> <p>Reports the temperature of the DRC motor. </p> <ul> <li><code>#include &lt;mc_x.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::temperature_sensor</p>"},{"location":"api/classhal_1_1rmd_1_1mc__x__temperature/#public-functions-inherited-from-haltemperature_sensor","title":"Public Functions inherited from hal::temperature_sensor","text":"<p>See hal::temperature_sensor</p> Type Name result&lt; read_t &gt; read () Read the current temperature measured by the device. virtual ~temperature_sensor () = default <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/mc_x.hpp</code></p>"},{"location":"api/classhal_1_1rotation__sensor/","title":"Class hal::rotation_sensor","text":"<p>ClassList &gt; hal &gt; rotation_sensor</p> <p>Rotation measuring hardware abstraction interface. More...</p> <ul> <li><code>#include &lt;rotation_sensor.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::rmd::drc_rotation_sensor,  hal::rmd::mc_x_rotation,  hal::soft::inert_rotation_sensor</p>"},{"location":"api/classhal_1_1rotation__sensor/#classes","title":"Classes","text":"Type Name struct read_t Result from reading the rotation sensor."},{"location":"api/classhal_1_1rotation__sensor/#public-functions","title":"Public Functions","text":"Type Name result&lt; read_t &gt; read () Read the current angle measured by the device. virtual ~rotation_sensor () = default"},{"location":"api/classhal_1_1rotation__sensor/#detailed-description","title":"Detailed Description","text":"<p>Examples of rotary encoder are:</p> <ul> <li>Rotary Potentiometers</li> <li>Quadrature Encoders</li> <li>Incremental Encoders</li> <li>Absolute Encoders</li> <li>Rotary Magnetic Encoders</li> <li>Inertial Measurement Unit or IMU</li> </ul> <p>Rotation sensors can be relative or absolute. Relative position means that the sensor can only see changes in rotation from where measurement started. In other words, at application start, relative encoders will start at 0. Absolute encoders know their position at all times. At application start, the absolute encoder will be able to determine its exact orientation relative to a frame of reference when read.</p> <p>Examples of relative rotation sensors are:</p> <ul> <li>Quadrature Encoders</li> <li>Incremental Encoders</li> </ul> <p>Examples of absolute rotation sensors are:</p> <ul> <li>Rotary Potentiometers</li> <li>Absolute Encoders</li> <li>Rotary Magnetic Encoders</li> <li>IMUs</li> </ul> <p>Rotation sensors can also be finite or infinite. Finite meaning that the angle that can be reported is a fixed amount for the device. Infinite means that the encoder can continue rotating and adding more to its angle reading forever. Infinite rotation sensors tend to not have a physical stop that limits how much they can be rotated.</p> <p>Examples of finite rotation sensors are:</p> <ul> <li>Rotary Potentiometers</li> <li>Absolute Encoders</li> <li>IMUs</li> </ul> <p>Examples of infinite rotation sensors are:</p> <ul> <li>Rotary Magnetic Encoders</li> <li>Quadrature Encoders</li> <li>Incremental Encoders</li> </ul> <p>This interface does not provide a means to determine these attributes of a rotation sensor as this is an application architecture decision. Drivers that implement this interface should document what kind of rotary sensor it is such that a developer can determine its applicability to their application. The context of which sensor ought to be used for an application is solely known at architecture definition time and software should not be expected to at runtime, if the right type of rotation sensor was passed into the object. </p>"},{"location":"api/classhal_1_1rotation__sensor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1rotation__sensor/#function-read","title":"function read","text":"<p>Read the current angle measured by the device. <pre><code>inline result&lt; read_t &gt; hal::rotation_sensor::read () \n</code></pre></p> <p>Returns:</p> <p>result&lt;read_t&gt; - rotation data </p>"},{"location":"api/classhal_1_1rotation__sensor/#function-rotation_sensor","title":"function ~rotation_sensor","text":"<pre><code>virtual hal::rotation_sensor::~rotation_sensor () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/rotation_sensor.hpp</code></p>"},{"location":"api/structhal_1_1rotation__sensor_1_1read__t/","title":"Struct hal::rotation_sensor::read_t","text":"<p>ClassList &gt; hal &gt; rotation_sensor &gt; read_t</p> <p>Result from reading the rotation sensor. </p> <ul> <li><code>#include &lt;rotation_sensor.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1rotation__sensor_1_1read__t/#public-attributes","title":"Public Attributes","text":"Type Name degrees angle Rotation angle measurement."},{"location":"api/structhal_1_1rotation__sensor_1_1read__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1rotation__sensor_1_1read__t/#variable-angle","title":"variable angle","text":"<pre><code>degrees hal::rotation_sensor::read_t::angle;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/rotation_sensor.hpp</code></p>"},{"location":"api/classhal_1_1serial/","title":"Class hal::serial","text":"<p>ClassList &gt; hal &gt; serial</p> <p>Hardware abstract interface for the serial communication protocol. More...</p> <ul> <li><code>#include &lt;serial.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::lpc40::uart</p>"},{"location":"api/classhal_1_1serial/#classes","title":"Classes","text":"Type Name struct flush_t Feedback from performing a flush operation. struct read_t Return type for serial read operations. struct settings Generic settings for a standard serial device. struct write_t Return type for serial write operations."},{"location":"api/classhal_1_1serial/#public-functions","title":"Public Functions","text":"Type Name status configure (const settings &amp; p_settings) Configure serial to match the settings supplied. result&lt; flush_t &gt; flush () Flush working buffer. result&lt; read_t &gt; read (std::span&lt; hal::byte &gt; p_data) Copy bytes from working buffer into passed buffer. result&lt; write_t &gt; write (std::span&lt; const hal::byte &gt; p_data) Write data to the transmitter line of the serial port. virtual ~serial () = default"},{"location":"api/classhal_1_1serial/#detailed-description","title":"Detailed Description","text":"<p>Use this interface for hardware that implements a serial protocol like UART, RS232, RS485 and others that use a similar communication protocol but may use different voltage schemes.</p> <p>This interface only works 8-bit serial data frames.</p> <p>Due to the asynchronous and unformatted nature of serial communication protocols, all implementations of serial devices must be buffered. Buffered, in this case, is defined as automatic storage of received bytes without direct application intervention.</p> <p>All implementations MUST allow the user to supply their own buffer of arbitrary size up to the limits of what hardware can support. This allows a developer the ability to tailored the buffer size to the needs of the application.</p> <p>Examples of buffering schemes are:</p> <ul> <li>Using DMA to copy data from a serial peripheral to a region of memory</li> <li>Using interrupts when a serial peripheral's queue has filled to a point </li> </ul>"},{"location":"api/classhal_1_1serial/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1serial/#function-configure","title":"function configure","text":"<p>Configure serial to match the settings supplied. <pre><code>inline status hal::serial::configure (\n    const settings &amp; p_settings\n) \n</code></pre></p> <p>Implementing drivers must verify if the settings can be applied to hardware before modifying the hardware. This will ensure that if this operation fails, the state of the serial device has not changed.</p> <p>Parameters:</p> <ul> <li><code>p_settings</code> - settings to apply to serial driver </li> </ul> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::invalid_argument</code> if the settings could not be achieved </li> </ul>"},{"location":"api/classhal_1_1serial/#function-flush","title":"function flush","text":"<p>Flush working buffer. <pre><code>inline result&lt; flush_t &gt; hal::serial::flush () \n</code></pre></p> <p>The behavior of flushing the internal working buffer is this:</p> <ul> <li>Sets the serial port's internal working buffer to an \"empty\" state.</li> <li>Clear any received data stored in hardware registers.</li> <li>Use the fastest available option to perform these operations, meaning that the contents of the internal working buffer will not be zeroed out.</li> </ul> <p>Returns:</p> <p>result&lt;flush_t&gt; - success or failure </p>"},{"location":"api/classhal_1_1serial/#function-read","title":"function read","text":"<p>Copy bytes from working buffer into passed buffer. <pre><code>inline result&lt; read_t &gt; hal::serial::read (\n    std::span&lt; hal::byte &gt; p_data\n) \n</code></pre></p> <p>This operation copies the bytes from the serial driver's internal working buffer to the buffer supplied.</p> <p>The buffer will be filled up either to the end of the buffer or until there are no more bytes left in the working buffer. The remaining portion of the input buffer is returned in <code>read_t::remaining</code>.</p> <p>If a frame error has occurred at any point during serial reception, this function will throw a <code>std::errc::io_error</code> value. The contents of the internal working buffer will stay the same. No information from the internal working buffer will be copied into the supplied buffer and no data will be removed from the internal working buffer. The frame error status will be internally cleared after its occurrence. Subsequent calls of this function will read out the contents of the buffer although the data inside may be corrupt.</p> <p>When an error occurs the options available are to flush the buffer and attempt reception again or read out the potentially corrupted data and parse it as needed. The choice of operation is application/driver specific.</p> <p>Parameters:</p> <ul> <li><code>p_data</code> - Buffer to read bytes in to </li> </ul> <p>Returns:</p> <p>result&lt;read_t&gt; - serial read response data </p> <p>Exception:</p> <ul> <li><code>std::errc::io_error</code> - a frame error occurred at some point during reception. </li> </ul>"},{"location":"api/classhal_1_1serial/#function-write","title":"function write","text":"<p>Write data to the transmitter line of the serial port. <pre><code>inline result&lt; write_t &gt; hal::serial::write (\n    std::span&lt; const hal::byte &gt; p_data\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_data</code> - data to be transmitted over the serial port </li> </ul> <p>Returns:</p> <p>result&lt;write_t&gt; - serial write response </p>"},{"location":"api/classhal_1_1serial/#function-serial","title":"function ~serial","text":"<pre><code>virtual hal::serial::~serial () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/serial.hpp</code></p>"},{"location":"api/structhal_1_1serial_1_1flush__t/","title":"Struct hal::serial::flush_t","text":"<p>ClassList &gt; hal &gt; serial &gt; flush_t</p> <p>Feedback from performing a flush operation. More...</p> <ul> <li><code>#include &lt;serial.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1serial_1_1flush__t/#detailed-description","title":"Detailed Description","text":"<p>This structure is currently empty as no feedback has been determined for now. This structure may be expanded in the future. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/serial.hpp</code></p>"},{"location":"api/structhal_1_1serial_1_1read__t/","title":"Struct hal::serial::read_t","text":"<p>ClassList &gt; hal &gt; serial &gt; read_t</p> <p>Return type for serial read operations. </p> <ul> <li><code>#include &lt;serial.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1serial_1_1read__t/#public-attributes","title":"Public Attributes","text":"Type Name size_t available Number of enqueued and available to be read out bytes. size_t capacity The maximum number of bytes that the serial port can queue up. std::span&lt; hal::byte &gt; data The filled portion of the input buffer from the serial port."},{"location":"api/structhal_1_1serial_1_1read__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1serial_1_1read__t/#variable-available","title":"variable available","text":"<p>Number of enqueued and available to be read out bytes. <pre><code>size_t hal::serial::read_t::available;\n</code></pre></p> <p>This value can be equal to or exceed the value of capacity. In this situation, the number of bytes above the capacity are bytes that have been dropped. Not all drivers will indicate the number of bytes lost. It is up to the driver or application to decide what to do in this situation. </p>"},{"location":"api/structhal_1_1serial_1_1read__t/#variable-capacity","title":"variable capacity","text":"<pre><code>size_t hal::serial::read_t::capacity;\n</code></pre>"},{"location":"api/structhal_1_1serial_1_1read__t/#variable-data","title":"variable data","text":"<p>The filled portion of the input buffer from the serial port. <pre><code>std::span&lt;hal::byte&gt; hal::serial::read_t::data;\n</code></pre></p> <p>The size of this buffer indicates the number of bytes read The address points to the start of the buffer passed into the read() function. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/serial.hpp</code></p>"},{"location":"api/structhal_1_1serial_1_1settings/","title":"Struct hal::serial::settings","text":"<p>ClassList &gt; hal &gt; serial &gt; settings</p> <p>Generic settings for a standard serial device. </p> <ul> <li><code>#include &lt;serial.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1serial_1_1settings/#public-types","title":"Public Types","text":"Type Name enum uint8_t parity Set of parity bit options. enum uint8_t stop_bits Set of available stop bits options."},{"location":"api/structhal_1_1serial_1_1settings/#public-attributes","title":"Public Attributes","text":"Type Name hertz baud_rate   = = 115200.0fThe operating speed of the baud rate (in units of bits per second) parity parity   = = parity::noneParity bit type for each frame. stop_bits stop   = = stop_bits::oneNumber of stop bits for each frame."},{"location":"api/structhal_1_1serial_1_1settings/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/structhal_1_1serial_1_1settings/#enum-parity-12","title":"enum parity [1/2]","text":"<pre><code>enum hal::serial::settings::parity {\n    none = 0,\n    odd,\n    even,\n    forced1,\n    forced0\n};\n</code></pre>"},{"location":"api/structhal_1_1serial_1_1settings/#enum-stop_bits","title":"enum stop_bits","text":"<pre><code>enum hal::serial::settings::stop_bits {\n    one = 0,\n    two\n};\n</code></pre>"},{"location":"api/structhal_1_1serial_1_1settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1serial_1_1settings/#variable-baud_rate","title":"variable baud_rate","text":"<pre><code>hertz hal::serial::settings::baud_rate;\n</code></pre>"},{"location":"api/structhal_1_1serial_1_1settings/#variable-parity-22","title":"variable parity [2/2]","text":"<pre><code>parity hal::serial::settings::parity;\n</code></pre>"},{"location":"api/structhal_1_1serial_1_1settings/#variable-stop","title":"variable stop","text":"<pre><code>stop_bits hal::serial::settings::stop;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/serial.hpp</code></p>"},{"location":"api/structhal_1_1serial_1_1write__t/","title":"Struct hal::serial::write_t","text":"<p>ClassList &gt; hal &gt; serial &gt; write_t</p> <p>Return type for serial write operations. </p> <ul> <li><code>#include &lt;serial.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1serial_1_1write__t/#public-attributes","title":"Public Attributes","text":"Type Name std::span&lt; const hal::byte &gt; data The portion of the buffer transmitted."},{"location":"api/structhal_1_1serial_1_1write__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1serial_1_1write__t/#variable-data","title":"variable data","text":"<pre><code>std::span&lt;const hal::byte&gt; hal::serial::write_t::data;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/serial.hpp</code></p>"},{"location":"api/classhal_1_1servo/","title":"Class hal::servo","text":"<p>ClassList &gt; hal &gt; servo</p> <p>Hardware abstraction for a closed loop position controlled rotational actuator. </p> <ul> <li><code>#include &lt;servo.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::rmd::drc_servo,  hal::rmd::mc_x_servo,  hal::soft::rc_servo</p>"},{"location":"api/classhal_1_1servo/#classes","title":"Classes","text":"Type Name struct position_t Feedback from setting the servo position. struct range_error Error information indicating the range of the servo."},{"location":"api/classhal_1_1servo/#public-functions","title":"Public Functions","text":"Type Name result&lt; position_t &gt; position (hal::degrees p_position) Set the position of the servo's output shaft. virtual ~servo () = default"},{"location":"api/classhal_1_1servo/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1servo/#function-position","title":"function position","text":"<p>Set the position of the servo's output shaft. <pre><code>inline result&lt; position_t &gt; hal::servo::position (\n    hal::degrees p_position\n) \n</code></pre></p> <p>Position is the rotational position as a angle in degrees that the caller wants the shaft to rotate to. The allowed range of positions is defined by the servo itself. Many servos have intrinsic limits to their range.</p> <p>Developers must choose servos that fit the range for their applications. Applications must clearly define the range that they require in order to perform correctly.</p> <p>The velocity in which the servo shaft moves is not defined by this function but is either intrinsic to the servo or a configuration of the servo.</p> <p>Parameters:</p> <ul> <li><code>p_position</code> - the position to move the servo shaft in degrees. </li> </ul> <p>Returns:</p> <p>result&lt;position_t&gt; - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::invalid_argument</code> - when position exceeds the range of the servo. When this error occurs, the guaranteed behavior is that the servo keeps its last set position. </li> <li>hal::servo::range_error - when position exceeds the range of the servo. Provides details about the min and max range of the servo. When this error occurs, the guaranteed behavior is that the servo keeps its last set position. </li> </ul>"},{"location":"api/classhal_1_1servo/#function-servo","title":"function ~servo","text":"<pre><code>virtual hal::servo::~servo () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/servo.hpp</code></p>"},{"location":"api/structhal_1_1servo_1_1position__t/","title":"Struct hal::servo::position_t","text":"<p>ClassList &gt; hal &gt; servo &gt; position_t</p> <p>Feedback from setting the servo position. More...</p> <ul> <li><code>#include &lt;servo.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1servo_1_1position__t/#detailed-description","title":"Detailed Description","text":"<p>This structure is currently empty as no feedback has been determined for now. This structure may be expanded in the future. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/servo.hpp</code></p>"},{"location":"api/structhal_1_1servo_1_1range__error/","title":"Struct hal::servo::range_error","text":"<p>ClassList &gt; hal &gt; servo &gt; range_error</p> <p>Error information indicating the range of the servo. </p> <ul> <li><code>#include &lt;servo.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1servo_1_1range__error/#public-attributes","title":"Public Attributes","text":"Type Name hal::degrees max Maximum range of the servo shaft in degrees. hal::degrees min Minimum range of the servo shaft in degrees."},{"location":"api/structhal_1_1servo_1_1range__error/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1servo_1_1range__error/#variable-max","title":"variable max","text":"<pre><code>hal::degrees hal::servo::range_error::max;\n</code></pre>"},{"location":"api/structhal_1_1servo_1_1range__error/#variable-min","title":"variable min","text":"<pre><code>hal::degrees hal::servo::range_error::min;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/servo.hpp</code></p>"},{"location":"api/classhal_1_1skip__past/","title":"Class hal::skip_past","text":"<p>ClassList &gt; hal &gt; skip_past</p> <p>Discard received bytes until the sequence is found. </p> <ul> <li><code>#include &lt;serial_coroutines.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1skip__past/#public-functions","title":"Public Functions","text":"Type Name result&lt; work_state &gt; operator() () skip data from the serial port until the sequence is reached. skip_past (serial &amp; p_serial, std::span&lt; const hal::byte &gt; p_sequence, size_t p_read_limit=32) Construct a new skip beyond object."},{"location":"api/classhal_1_1skip__past/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1skip__past/#function-operator","title":"function operator()","text":"<p>skip data from the serial port until the sequence is reached. <pre><code>inline result&lt; work_state &gt; hal::skip_past::operator() () \n</code></pre></p> <p>This function will return if the sequence is found or if there are no more bytes in the serial port.</p> <p>Call this function again to resume reading from the port.</p> <p>Returns:</p> <p>result&lt;work_state&gt; - work_state::in_progress if the sequence hasn't been met and the buffer still has space. </p> <p>Returns:</p> <p>result&lt;work_state&gt; - work_state::finished if the sequence was found before the buffer was filled completely. </p>"},{"location":"api/classhal_1_1skip__past/#function-skip_past","title":"function skip_past","text":"<p>Construct a new skip beyond object. <pre><code>inline hal::skip_past::skip_past (\n    serial &amp; p_serial,\n    std::span&lt; const hal::byte &gt; p_sequence,\n    size_t p_read_limit=32\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_serial</code> - serial port to skip through </li> <li><code>p_sequence</code> - sequence to search for. The lifetime of this data pointed to by this span must outlive this object, or not be used when the lifetime of that data is no longer available. </li> <li><code>p_read_limit</code> - the maximum number read attempts from the port before returning. A value 0 will result in no reads from the serial port. </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/serial_coroutines.hpp</code></p>"},{"location":"api/namespacehal_1_1soft/","title":"Namespace hal::soft","text":"<p>Namespace List &gt; hal &gt; soft</p>"},{"location":"api/namespacehal_1_1soft/#classes","title":"Classes","text":"Type Name class adc_multiplexer A driver for an ADC multiplexer that manages and reads ADC mux pins. This driver is intended to be used with multiplexers that use digital signals. An ADC multiplexer can be used to expand the number of input channels of an ADC. class adc_mux_pin A class that represents a multiplexer pin for ADC. class inert_accelerometer Inert implementation of acceleration sensing hardware. class inert_adc Inert implementation of Analog to Digital Converter (ADC) hardware. class inert_dac Inert implementation of Digital to Analog Converter (DAC) hardware. class inert_distance_sensor Inert implementation of linear distance hardware. class inert_gyroscope Inert implementation of angular velocity sensing hardware. class inert_input_pin Inert implementation of digital input pin hardware. class inert_interrupt_pin Inert implementation of digital interrupt pin hardware. class inert_magnetometer Inert implementation of magnetic field strength sensing hardware. class inert_motor Inert implementation of open loop motorized actuator hardware. class inert_output_pin Inert implementation of digital output pin hardware. class inert_pwm Inert implementation of Pulse Width Modulation (PWM) channel hardware. class inert_rotation_sensor Inert implementation of rotation measuring hardware. class inert_steady_clock Inert implementation of steady clock mechanism. class inert_temperature_sensor Inert implementation of temperature sensing hardware. class inert_timer Inert implementation of timer hardware. class input_pin_inverter class minimum_speed_i2c A i2c wrapper to ensure that the lowesti2c device frequency is used. class output_pin_inverter class rc_servo Generic RC servo driver."},{"location":"api/namespacehal_1_1soft/#public-functions","title":"Public Functions","text":"Type Name result&lt; adc_mux_pin &gt; make_adc (adc_multiplexer &amp; p_multiplexer, std::uint8_t p_channel) Returns an ADC pin from the multiplexer."},{"location":"api/namespacehal_1_1soft/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacehal_1_1soft/#function-make_adc","title":"function make_adc","text":"<p>Returns an ADC pin from the multiplexer. <pre><code>result&lt; adc_mux_pin &gt; hal::soft::make_adc (\n    adc_multiplexer &amp; p_multiplexer,\n    std::uint8_t p_channel\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_multiplexer</code> the adc multiplexer with the desire adc channel pin </li> <li><code>p_channel</code> The channel number of the pin </li> </ul> <p>Returns:</p> <p>A newly constructed ADC multiplexer pin. </p> <p>Exception:</p> <ul> <li><code>std::errc::result_out_of_range</code> if p_channel greater than the available number of channels in the multiplexer. </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/adc_mux.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1adc__multiplexer/","title":"Class hal::soft::adc_multiplexer","text":"<p>ClassList &gt; hal &gt; soft &gt; adc_multiplexer</p> <p>A driver for an ADC multiplexer that manages and reads ADC mux pins. This driver is intended to be used with multiplexers that use digital signals. An ADC multiplexer can be used to expand the number of input channels of an ADC. </p> <ul> <li><code>#include &lt;adc_mux.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1soft_1_1adc__multiplexer/#public-functions","title":"Public Functions","text":"Type Name int get_max_channel () Gets the highest capacity channel held by the ADC mux object. This is calculated based off of how many source pins are available. hal::result&lt; hal::adc::read_t &gt; read_channel (std::uint16_t p_mux_port) Reads a channel on the mux."},{"location":"api/classhal_1_1soft_1_1adc__multiplexer/#public-static-functions","title":"Public Static Functions","text":"Type Name adc_multiplexer create (std::span&lt; hal::output_pin * &gt; p_signal_pins, hal::adc &amp; p_source_pin, hal::steady_clock &amp; p_clock) Constructs a new adc_multiplexer object."},{"location":"api/classhal_1_1soft_1_1adc__multiplexer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1adc__multiplexer/#function-get_max_channel","title":"function get_max_channel","text":"<p>Gets the highest capacity channel held by the ADC mux object. This is calculated based off of how many source pins are available. <pre><code>int hal::soft::adc_multiplexer::get_max_channel () \n</code></pre></p> <p>Returns:</p> <p>The maximum channel number for this mux (2^n states, where n is number of source pins). </p>"},{"location":"api/classhal_1_1soft_1_1adc__multiplexer/#function-read_channel","title":"function read_channel","text":"<p>Reads a channel on the mux. <pre><code>hal::result&lt; hal::adc::read_t &gt; hal::soft::adc_multiplexer::read_channel (\n    std::uint16_t p_mux_port\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_mux_port</code> The port to be read. If an out of bounds port number is passed, an error-typed result is returned. </li> </ul> <p>Returns:</p> <p>The hal::adc::read_t struct of the read value or an error if an invalid port is given. </p>"},{"location":"api/classhal_1_1soft_1_1adc__multiplexer/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1adc__multiplexer/#function-create","title":"function create","text":"<p>Constructs a new adc_multiplexer object. <pre><code>static adc_multiplexer hal::soft::adc_multiplexer::create (\n    std::span&lt; hal::output_pin * &gt; p_signal_pins,\n    hal::adc &amp; p_source_pin,\n    hal::steady_clock &amp; p_clock\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_signal_pins</code> A span of the output signal pins used to determine the channel on the mux. </li> <li><code>p_source_pin</code> The output adc pin of the multiplexer. </li> <li><code>p_clock</code> A steady clock used for delaying 500ns to give time to the mux to have an updated signal. </li> </ul> <p>Returns:</p> <p>The constructed adc_multiplexer. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/adc_mux.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1adc__mux__pin/","title":"Class hal::soft::adc_mux_pin","text":"<p>ClassList &gt; hal &gt; soft &gt; adc_mux_pin</p> <p>A class that represents a multiplexer pin for ADC. </p> <ul> <li><code>#include &lt;adc_mux.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::adc</p>"},{"location":"api/classhal_1_1soft_1_1adc__mux__pin/#public-functions-inherited-from-haladc","title":"Public Functions inherited from hal::adc","text":"<p>See hal::adc</p> Type Name result&lt; read_t &gt; read () Sample the analog to digital converter and return the result. virtual ~adc () = default <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/adc_mux.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__accelerometer/","title":"Class hal::soft::inert_accelerometer","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_accelerometer</p> <p>Inert implementation of acceleration sensing hardware. </p> <ul> <li><code>#include &lt;inert_accelerometer.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::accelerometer</p>"},{"location":"api/classhal_1_1soft_1_1inert__accelerometer/#public-functions-inherited-from-halaccelerometer","title":"Public Functions inherited from hal::accelerometer","text":"<p>See hal::accelerometer</p> Type Name result&lt; read_t &gt; read () Read the latest acceleration sensed by the device. virtual ~accelerometer () = default"},{"location":"api/classhal_1_1soft_1_1inert__accelerometer/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_accelerometer &gt; create (read_t p_values) Factory function to create inert_accelerometer object."},{"location":"api/classhal_1_1soft_1_1inert__accelerometer/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__accelerometer/#function-create","title":"function create","text":"<p>Factory function to create inert_accelerometer object. <pre><code>static inline result&lt; inert_accelerometer &gt; hal::soft::inert_accelerometer::create (\n    read_t p_values\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_values</code> - Read values to return when reading the inert_accelerometer. </li> </ul> <p>Returns:</p> <p>result&lt;inert_accelerometer&gt; - Constructed inert_accelerometer object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_accelerometer.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__adc/","title":"Class hal::soft::inert_adc","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_adc</p> <p>Inert implementation of Analog to Digital Converter (ADC) hardware. </p> <ul> <li><code>#include &lt;inert_adc.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::adc</p>"},{"location":"api/classhal_1_1soft_1_1inert__adc/#public-functions-inherited-from-haladc","title":"Public Functions inherited from hal::adc","text":"<p>See hal::adc</p> Type Name result&lt; read_t &gt; read () Sample the analog to digital converter and return the result. virtual ~adc () = default"},{"location":"api/classhal_1_1soft_1_1inert__adc/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_adc &gt; create (read_t p_result) Factory function to create inert_adc object."},{"location":"api/classhal_1_1soft_1_1inert__adc/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__adc/#function-create","title":"function create","text":"<p>Factory function to create inert_adc object. <pre><code>static inline result&lt; inert_adc &gt; hal::soft::inert_adc::create (\n    read_t p_result\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_result</code> - read_t object to return when reading the inert_adc </li> </ul> <p>Returns:</p> <p>result&lt;inert_adc&gt; - Constructed inert_adc object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_adc.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__dac/","title":"Class hal::soft::inert_dac","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_dac</p> <p>Inert implementation of Digital to Analog Converter (DAC) hardware. </p> <ul> <li><code>#include &lt;inert_dac.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::dac</p>"},{"location":"api/classhal_1_1soft_1_1inert__dac/#public-functions-inherited-from-haldac","title":"Public Functions inherited from hal::dac","text":"<p>See hal::dac</p> Type Name result&lt; write_t &gt; write (float p_percentage) Set the output voltage of the DAC. virtual ~dac () = default"},{"location":"api/classhal_1_1soft_1_1inert__dac/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_dac &gt; create () Factory function to create inert_dac object."},{"location":"api/classhal_1_1soft_1_1inert__dac/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__dac/#function-create","title":"function create","text":"<p>Factory function to create inert_dac object. <pre><code>static inline result&lt; inert_dac &gt; hal::soft::inert_dac::create () \n</code></pre></p> <p>Returns:</p> <p>result&lt;inert_dac&gt; - Constructed inert_dac object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_dac.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__distance__sensor/","title":"Class hal::soft::inert_distance_sensor","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_distance_sensor</p> <p>Inert implementation of linear distance hardware. </p> <ul> <li><code>#include &lt;inert_distance_sensor.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::distance_sensor</p>"},{"location":"api/classhal_1_1soft_1_1inert__distance__sensor/#public-functions-inherited-from-haldistance_sensor","title":"Public Functions inherited from hal::distance_sensor","text":"<p>See hal::distance_sensor</p> Type Name result&lt; read_t &gt; read () Read the current distance measured by the device. virtual ~distance_sensor () = default"},{"location":"api/classhal_1_1soft_1_1inert__distance__sensor/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_distance_sensor &gt; create (read_t p_result) Factory function to create inert_distance_sensor object."},{"location":"api/classhal_1_1soft_1_1inert__distance__sensor/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__distance__sensor/#function-create","title":"function create","text":"<p>Factory function to create inert_distance_sensor object. <pre><code>static inline result&lt; inert_distance_sensor &gt; hal::soft::inert_distance_sensor::create (\n    read_t p_result\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_result</code> - read_t data to be returned when calling read() </li> </ul> <p>Returns:</p> <p>result&lt;inert_distance_sensor&gt; - Constructed inert_distance_sensor object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_distance_sensor.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__gyroscope/","title":"Class hal::soft::inert_gyroscope","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_gyroscope</p> <p>Inert implementation of angular velocity sensing hardware. </p> <ul> <li><code>#include &lt;inert_gyroscope.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::gyroscope</p>"},{"location":"api/classhal_1_1soft_1_1inert__gyroscope/#public-functions-inherited-from-halgyroscope","title":"Public Functions inherited from hal::gyroscope","text":"<p>See hal::gyroscope</p> Type Name result&lt; read_t &gt; read () Read the latest angular velocity sensed by the device. virtual ~gyroscope () = default"},{"location":"api/classhal_1_1soft_1_1inert__gyroscope/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_gyroscope &gt; create (read_t p_result) Factory function to create inert_gyroscope object."},{"location":"api/classhal_1_1soft_1_1inert__gyroscope/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__gyroscope/#function-create","title":"function create","text":"<p>Factory function to create inert_gyroscope object. <pre><code>static inline result&lt; inert_gyroscope &gt; hal::soft::inert_gyroscope::create (\n    read_t p_result\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_result</code> - Values to return when calling read() </li> </ul> <p>Returns:</p> <p>result&lt;inert_gyroscope&gt; - Constructed inert_gyroscope object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_gyroscope.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__input__pin/","title":"Class hal::soft::inert_input_pin","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_input_pin</p> <p>Inert implementation of digital input pin hardware. </p> <ul> <li><code>#include &lt;inert_input_pin.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::input_pin</p>"},{"location":"api/classhal_1_1soft_1_1inert__input__pin/#public-functions-inherited-from-halinput_pin","title":"Public Functions inherited from hal::input_pin","text":"<p>See hal::input_pin</p> Type Name status configure (const settings &amp; p_settings) Configure the input pin to match the settings supplied. result&lt; level_t &gt; level () Read the state of the input pin. virtual ~input_pin () = default"},{"location":"api/classhal_1_1soft_1_1inert__input__pin/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_input_pin &gt; create (level_t p_level) Factory function to create inert_input_pin object."},{"location":"api/classhal_1_1soft_1_1inert__input__pin/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__input__pin/#function-create","title":"function create","text":"<p>Factory function to create inert_input_pin object. <pre><code>static inline result&lt; inert_input_pin &gt; hal::soft::inert_input_pin::create (\n    level_t p_level\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_level</code> - level_t object to retrun when level() is called </li> </ul> <p>Returns:</p> <p>result&lt;inert_input_pin&gt; - Constructed inert_input_pin object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_input_pin.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__interrupt__pin/","title":"Class hal::soft::inert_interrupt_pin","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_interrupt_pin</p> <p>Inert implementation of digital interrupt pin hardware. </p> <ul> <li><code>#include &lt;inert_interrupt_pin.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::interrupt_pin</p>"},{"location":"api/classhal_1_1soft_1_1inert__interrupt__pin/#public-types-inherited-from-halinterrupt_pin","title":"Public Types inherited from hal::interrupt_pin","text":"<p>See hal::interrupt_pin</p> Type Name typedef void(bool p_state) handler Interrupt pin handler. enum trigger_edge The condition in which an interrupt it's triggered."},{"location":"api/classhal_1_1soft_1_1inert__interrupt__pin/#public-functions-inherited-from-halinterrupt_pin","title":"Public Functions inherited from hal::interrupt_pin","text":"<p>See hal::interrupt_pin</p> Type Name status configure (const settings &amp; p_settings) Configure the interrupt pin to match the settings supplied. void on_trigger (hal::callback&lt; handler &gt; p_callback) Set the callback for when the interrupt occurs. virtual ~interrupt_pin () = default"},{"location":"api/classhal_1_1soft_1_1inert__interrupt__pin/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_interrupt_pin &gt; create () Factory function to create inert_interrupt_pin object."},{"location":"api/classhal_1_1soft_1_1inert__interrupt__pin/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__interrupt__pin/#function-create","title":"function create","text":"<p>Factory function to create inert_interrupt_pin object. <pre><code>static inline result&lt; inert_interrupt_pin &gt; hal::soft::inert_interrupt_pin::create () \n</code></pre></p> <p>Returns:</p> <p>result&lt;inert_interrupt_pin&gt; - Constructed inert_interrupt_pin object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_interrupt_pin.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__magnetometer/","title":"Class hal::soft::inert_magnetometer","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_magnetometer</p> <p>Inert implementation of magnetic field strength sensing hardware. </p> <ul> <li><code>#include &lt;inert_magnetometer.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::magnetometer</p>"},{"location":"api/classhal_1_1soft_1_1inert__magnetometer/#public-functions-inherited-from-halmagnetometer","title":"Public Functions inherited from hal::magnetometer","text":"<p>See hal::magnetometer</p> Type Name result&lt; read_t &gt; read () Read the latest magnetic field strength sensed by the device. virtual ~magnetometer () = default"},{"location":"api/classhal_1_1soft_1_1inert__magnetometer/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_magnetometer &gt; create (read_t p_result) Factory function to create an inert_magnetometer object."},{"location":"api/classhal_1_1soft_1_1inert__magnetometer/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__magnetometer/#function-create","title":"function create","text":"<p>Factory function to create an inert_magnetometer object. <pre><code>static inline result&lt; inert_magnetometer &gt; hal::soft::inert_magnetometer::create (\n    read_t p_result\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_result</code> - read_t object to return when read() is called </li> </ul> <p>Returns:</p> <p>result&lt;inert_magnetometer&gt; - Constructed inert_magnetometer object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_magnetometer.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__motor/","title":"Class hal::soft::inert_motor","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_motor</p> <p>Inert implementation of open loop motorized actuator hardware. </p> <ul> <li><code>#include &lt;inert_motor.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::motor</p>"},{"location":"api/classhal_1_1soft_1_1inert__motor/#public-functions-inherited-from-halmotor","title":"Public Functions inherited from hal::motor","text":"<p>See hal::motor</p> Type Name result&lt; power_t &gt; power (float p_power) Apply power to the motor. virtual ~motor () = default"},{"location":"api/classhal_1_1soft_1_1inert__motor/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_motor &gt; create () Factory function to create inert_motor object."},{"location":"api/classhal_1_1soft_1_1inert__motor/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__motor/#function-create","title":"function create","text":"<p>Factory function to create inert_motor object. <pre><code>static inline result&lt; inert_motor &gt; hal::soft::inert_motor::create () \n</code></pre></p> <p>Returns:</p> <p>result&lt;inert_motor&gt; - Constructed inert_motor object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_motor.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__output__pin/","title":"Class hal::soft::inert_output_pin","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_output_pin</p> <p>Inert implementation of digital output pin hardware. </p> <ul> <li><code>#include &lt;inert_output_pin.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::output_pin</p>"},{"location":"api/classhal_1_1soft_1_1inert__output__pin/#public-functions-inherited-from-haloutput_pin","title":"Public Functions inherited from hal::output_pin","text":"<p>See hal::output_pin</p> Type Name status configure (const settings &amp; p_settings) Configure the output pin to match the settings supplied. result&lt; set_level_t &gt; level (bool p_high) Set the state of the pin. result&lt; level_t &gt; level () Read the current state of the output pin. virtual ~output_pin () = default"},{"location":"api/classhal_1_1soft_1_1inert__output__pin/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_output_pin &gt; create (bool p_level) Factory function to create inert_output_pin ."},{"location":"api/classhal_1_1soft_1_1inert__output__pin/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__output__pin/#function-create","title":"function create","text":"<p>Factory function to create inert_output_pin . <pre><code>static inline result&lt; inert_output_pin &gt; hal::soft::inert_output_pin::create (\n    bool p_level\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_level</code> - level_t object to return when level() is called. This value can be changed by using level(bool) after creation. </li> </ul> <p>Returns:</p> <p>result&lt;inert_output_pin&gt; - Constructed inert_output_pin object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_output_pin.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__pwm/","title":"Class hal::soft::inert_pwm","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_pwm</p> <p>Inert implementation of Pulse Width Modulation (PWM) channel hardware. </p> <ul> <li><code>#include &lt;inert_pwm.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::pwm</p>"},{"location":"api/classhal_1_1soft_1_1inert__pwm/#public-functions-inherited-from-halpwm","title":"Public Functions inherited from hal::pwm","text":"<p>See hal::pwm</p> Type Name result&lt; duty_cycle_t &gt; duty_cycle (float p_duty_cycle) Set the pwm waveform duty cycle. result&lt; frequency_t &gt; frequency (hertz p_frequency) Set the pwm waveform frequency. virtual ~pwm () = default"},{"location":"api/classhal_1_1soft_1_1inert__pwm/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_pwm &gt; create () Factory function to create inert_pwm object."},{"location":"api/classhal_1_1soft_1_1inert__pwm/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__pwm/#function-create","title":"function create","text":"<p>Factory function to create inert_pwm object. <pre><code>static inline result&lt; inert_pwm &gt; hal::soft::inert_pwm::create () \n</code></pre></p> <p>Returns:</p> <p>result&lt;inert_pwm&gt; - Constructed inert_pwm object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_pwm.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__rotation__sensor/","title":"Class hal::soft::inert_rotation_sensor","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_rotation_sensor</p> <p>Inert implementation of rotation measuring hardware. </p> <ul> <li><code>#include &lt;inert_rotation_sensor.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::rotation_sensor</p>"},{"location":"api/classhal_1_1soft_1_1inert__rotation__sensor/#public-functions-inherited-from-halrotation_sensor","title":"Public Functions inherited from hal::rotation_sensor","text":"<p>See hal::rotation_sensor</p> Type Name result&lt; read_t &gt; read () Read the current angle measured by the device. virtual ~rotation_sensor () = default"},{"location":"api/classhal_1_1soft_1_1inert__rotation__sensor/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_rotation_sensor &gt; create (read_t p_position) Factory function to create inert_rotation_sensor object."},{"location":"api/classhal_1_1soft_1_1inert__rotation__sensor/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__rotation__sensor/#function-create","title":"function create","text":"<p>Factory function to create inert_rotation_sensor object. <pre><code>static inline result&lt; inert_rotation_sensor &gt; hal::soft::inert_rotation_sensor::create (\n    read_t p_position\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_position</code> - read_t object to return when read() is called </li> </ul> <p>Returns:</p> <p>result&lt;inert_rotation_sensor&gt; - Constructed inert_rotation_sensor onject </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_rotation_sensor.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__steady__clock/","title":"Class hal::soft::inert_steady_clock","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_steady_clock</p> <p>Inert implementation of steady clock mechanism. </p> <ul> <li><code>#include &lt;inert_steady_clock.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::steady_clock</p>"},{"location":"api/classhal_1_1soft_1_1inert__steady__clock/#public-functions-inherited-from-halsteady_clock","title":"Public Functions inherited from hal::steady_clock","text":"<p>See hal::steady_clock</p> Type Name frequency_t frequency () Get the operating frequency of the steady clock. uptime_t uptime () Get the current value of the steady clock. virtual ~steady_clock () = default"},{"location":"api/classhal_1_1soft_1_1inert__steady__clock/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_steady_clock &gt; create (frequency_t p_frequency, uptime_t p_uptime) Factory function to create inert_steady_clock object."},{"location":"api/classhal_1_1soft_1_1inert__steady__clock/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__steady__clock/#function-create","title":"function create","text":"<p>Factory function to create inert_steady_clock object. <pre><code>static inline result&lt; inert_steady_clock &gt; hal::soft::inert_steady_clock::create (\n    frequency_t p_frequency,\n    uptime_t p_uptime\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_frequency</code> - frequency_t object to return when frequency() is called </li> <li><code>p_uptime</code> - uptime_t object with the starting value that will be returned when uptime() is called. The uptime will increment by 1 each time uptime() is called. </li> </ul> <p>Returns:</p> <p>result&lt;inert_steady_clock&gt; - Constructed inert_steady_clock object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_steady_clock.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__temperature__sensor/","title":"Class hal::soft::inert_temperature_sensor","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_temperature_sensor</p> <p>Inert implementation of temperature sensing hardware. </p> <ul> <li><code>#include &lt;inert_temperature_sensor.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::temperature_sensor</p>"},{"location":"api/classhal_1_1soft_1_1inert__temperature__sensor/#public-functions-inherited-from-haltemperature_sensor","title":"Public Functions inherited from hal::temperature_sensor","text":"<p>See hal::temperature_sensor</p> Type Name result&lt; read_t &gt; read () Read the current temperature measured by the device. virtual ~temperature_sensor () = default"},{"location":"api/classhal_1_1soft_1_1inert__temperature__sensor/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_temperature_sensor &gt; create (read_t p_temperature) Factory function to create inert_temperature_sensor object."},{"location":"api/classhal_1_1soft_1_1inert__temperature__sensor/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__temperature__sensor/#function-create","title":"function create","text":"<p>Factory function to create inert_temperature_sensor object. <pre><code>static inline result&lt; inert_temperature_sensor &gt; hal::soft::inert_temperature_sensor::create (\n    read_t p_temperature\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_temperature</code> - read_t object to return when read() is called </li> </ul> <p>Returns:</p> <p>result&lt;inert_temperature_sensor&gt; - Constructed inert_temperature_sensor object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_temperature_sensor.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1inert__timer/","title":"Class hal::soft::inert_timer","text":"<p>ClassList &gt; hal &gt; soft &gt; inert_timer</p> <p>Inert implementation of timer hardware. </p> <ul> <li><code>#include &lt;inert_timer.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::timer</p>"},{"location":"api/classhal_1_1soft_1_1inert__timer/#public-functions-inherited-from-haltimer","title":"Public Functions inherited from hal::timer","text":"<p>See hal::timer</p> Type Name result&lt; cancel_t &gt; cancel () Stops a scheduled event from happening. result&lt; is_running_t &gt; is_running () Determine if the timer is currently running. result&lt; schedule_t &gt; schedule (hal::callback&lt; void(void)&gt; p_callback, hal::time_duration p_delay) Schedule an callback be be executed after the delay time. virtual ~timer () = default"},{"location":"api/classhal_1_1soft_1_1inert__timer/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; inert_timer &gt; create (is_running_t p_is_running) Factory function to create inert_timer object."},{"location":"api/classhal_1_1soft_1_1inert__timer/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1inert__timer/#function-create","title":"function create","text":"<p>Factory function to create inert_timer object. <pre><code>static inline result&lt; inert_timer &gt; hal::soft::inert_timer::create (\n    is_running_t p_is_running\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_is_running</code> - is_running_t object to return when is_running() is called </li> </ul> <p>Returns:</p> <p>result&lt;inert_timer&gt; - Constructed inert_timer object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_timer.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1input__pin__inverter/","title":"Class hal::soft::input_pin_inverter","text":"<p>ClassList &gt; hal &gt; soft &gt; input_pin_inverter</p> <p>Inherits the following classes: hal::input_pin</p>"},{"location":"api/classhal_1_1soft_1_1input__pin__inverter/#public-functions","title":"Public Functions","text":"Type Name input_pin_inverter (hal::input_pin &amp; p_input_pin)"},{"location":"api/classhal_1_1soft_1_1input__pin__inverter/#public-functions-inherited-from-halinput_pin","title":"Public Functions inherited from hal::input_pin","text":"<p>See hal::input_pin</p> Type Name status configure (const settings &amp; p_settings) Configure the input pin to match the settings supplied. result&lt; level_t &gt; level () Read the state of the input pin. virtual ~input_pin () = default"},{"location":"api/classhal_1_1soft_1_1input__pin__inverter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1input__pin__inverter/#function-input_pin_inverter","title":"function input_pin_inverter","text":"<pre><code>hal::soft::input_pin_inverter::input_pin_inverter (\n    hal::input_pin &amp; p_input_pin\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inverter.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1minimum__speed__i2c/","title":"Class hal::soft::minimum_speed_i2c","text":"<p>ClassList &gt; hal &gt; soft &gt; minimum_speed_i2c</p> <p>A i2c wrapper to ensure that the lowesti2c device frequency is used.</p> <ul> <li><code>#include &lt;i2c_minimum_speed.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::i2c</p>"},{"location":"api/classhal_1_1soft_1_1minimum__speed__i2c/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr static auto default_max_speed   = = 2'000'000"},{"location":"api/classhal_1_1soft_1_1minimum__speed__i2c/#public-functions-inherited-from-hali2c","title":"Public Functions inherited from hal::i2c","text":"<p>See hal::i2c</p> Type Name status configure (const settings &amp; p_settings) Configure i2c to match the settings supplied. result&lt; transaction_t &gt; transaction (hal::byte p_address, std::span&lt; const hal::byte &gt; p_data_out, std::span&lt; hal::byte &gt; p_data_in, hal::function_ref&lt; hal::timeout_function &gt; p_timeout) perform an i2c transaction with another device on the bus. The type of transaction depends on values of input parameters. This function will block until the entire transfer is finished. virtual ~i2c () = default"},{"location":"api/classhal_1_1soft_1_1minimum__speed__i2c/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; minimum_speed_i2c &gt; create (hal::i2c &amp; p_i2c, hertz p_frequency=default_max_speed) Factory function to create minimum_speed_i2c object."},{"location":"api/classhal_1_1soft_1_1minimum__speed__i2c/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/classhal_1_1soft_1_1minimum__speed__i2c/#variable-default_max_speed","title":"variable default_max_speed","text":"<pre><code>constexpr static auto hal::soft::minimum_speed_i2c::default_max_speed;\n</code></pre>"},{"location":"api/classhal_1_1soft_1_1minimum__speed__i2c/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1minimum__speed__i2c/#function-create","title":"function create","text":"<p>Factory function to create minimum_speed_i2c object. <pre><code>static result&lt; minimum_speed_i2c &gt; hal::soft::minimum_speed_i2c::create (\n    hal::i2c &amp; p_i2c,\n    hertz p_frequency=default_max_speed\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_i2c</code> - i2c object that the device will use </li> <li><code>p_frequency</code> - the maximum starting frequency the device can use </li> </ul> <p>Returns:</p> <p>minimum_speed_i2c - the configured i2c object using the lowest seen frequency </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/i2c_minimum_speed.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1output__pin__inverter/","title":"Class hal::soft::output_pin_inverter","text":"<p>ClassList &gt; hal &gt; soft &gt; output_pin_inverter</p> <p>Inherits the following classes: hal::output_pin</p>"},{"location":"api/classhal_1_1soft_1_1output__pin__inverter/#public-functions","title":"Public Functions","text":"Type Name output_pin_inverter (hal::output_pin &amp; p_output_pin)"},{"location":"api/classhal_1_1soft_1_1output__pin__inverter/#public-functions-inherited-from-haloutput_pin","title":"Public Functions inherited from hal::output_pin","text":"<p>See hal::output_pin</p> Type Name status configure (const settings &amp; p_settings) Configure the output pin to match the settings supplied. result&lt; set_level_t &gt; level (bool p_high) Set the state of the pin. result&lt; level_t &gt; level () Read the current state of the output pin. virtual ~output_pin () = default"},{"location":"api/classhal_1_1soft_1_1output__pin__inverter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1output__pin__inverter/#function-output_pin_inverter","title":"function output_pin_inverter","text":"<pre><code>hal::soft::output_pin_inverter::output_pin_inverter (\n    hal::output_pin &amp; p_output_pin\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inverter.hpp</code></p>"},{"location":"api/classhal_1_1soft_1_1rc__servo/","title":"Class hal::soft::rc_servo","text":"<p>ClassList &gt; hal &gt; soft &gt; rc_servo</p> <p>Generic RC servo driver. </p> <ul> <li><code>#include &lt;rc_servo.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::servo</p>"},{"location":"api/classhal_1_1soft_1_1rc__servo/#classes","title":"Classes","text":"Type Name struct settings Information about the RC servo needed to control it properly."},{"location":"api/classhal_1_1soft_1_1rc__servo/#public-functions-inherited-from-halservo","title":"Public Functions inherited from hal::servo","text":"<p>See hal::servo</p> Type Name result&lt; position_t &gt; position (hal::degrees p_position) Set the position of the servo's output shaft. virtual ~servo () = default"},{"location":"api/classhal_1_1soft_1_1rc__servo/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; rc_servo &gt; create (hal::pwm &amp; p_pwm, settings p_settings) Factory function to create a rc_servo object."},{"location":"api/classhal_1_1soft_1_1rc__servo/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1soft_1_1rc__servo/#function-create","title":"function create","text":"<p>Factory function to create a rc_servo object. <pre><code>static result&lt; rc_servo &gt; hal::soft::rc_servo::create (\n    hal::pwm &amp; p_pwm,\n    settings p_settings\n) \n</code></pre></p> <p>Compile time error will occur if the min microseconds is more than the max microseconds, if the max microseconds is more than the frequency wavelength, or if the min angle is more than max angle.</p> <p>Parameters:</p> <ul> <li><code>p_pwm</code> - pwm signal connected to the RC servo </li> <li><code>p_settings</code> - </li> </ul> <p>Returns:</p> <p>result&lt;rc_servo&gt; - Constructed rc_servo object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/rc_servo.hpp</code></p>"},{"location":"api/structhal_1_1soft_1_1rc__servo_1_1settings/","title":"Struct hal::soft::rc_servo::settings","text":"<p>ClassList &gt; hal &gt; soft &gt; rc_servo &gt; settings</p> <p>Information about the RC servo needed to control it properly. </p> <ul> <li><code>#include &lt;rc_servo.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1soft_1_1rc__servo_1_1settings/#public-attributes","title":"Public Attributes","text":"Type Name hal::hertz frequency   = = 50PWM signal frequency. Check the documentation for the RC servo to determine what range of frequencies can be used with it. hal::degrees max_angle   = = 90The physical maximum angle that the servo shaft can move to. std::uint32_t max_microseconds   = = 2000The maximum pulse width in microseconds that maps to the maximum angle of the servo. hal::degrees min_angle   = = 0The physical minimum angle that the servo shaft can move to. std::uint32_t min_microseconds   = = 1000The minimum pulse width in microseconds that maps to the minimum angle of the servo."},{"location":"api/structhal_1_1soft_1_1rc__servo_1_1settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1soft_1_1rc__servo_1_1settings/#variable-frequency","title":"variable frequency","text":"<pre><code>hal::hertz hal::soft::rc_servo::settings::frequency;\n</code></pre>"},{"location":"api/structhal_1_1soft_1_1rc__servo_1_1settings/#variable-max_angle","title":"variable max_angle","text":"<pre><code>hal::degrees hal::soft::rc_servo::settings::max_angle;\n</code></pre>"},{"location":"api/structhal_1_1soft_1_1rc__servo_1_1settings/#variable-max_microseconds","title":"variable max_microseconds","text":"<pre><code>std::uint32_t hal::soft::rc_servo::settings::max_microseconds;\n</code></pre>"},{"location":"api/structhal_1_1soft_1_1rc__servo_1_1settings/#variable-min_angle","title":"variable min_angle","text":"<pre><code>hal::degrees hal::soft::rc_servo::settings::min_angle;\n</code></pre>"},{"location":"api/structhal_1_1soft_1_1rc__servo_1_1settings/#variable-min_microseconds","title":"variable min_microseconds","text":"<pre><code>std::uint32_t hal::soft::rc_servo::settings::min_microseconds;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/rc_servo.hpp</code></p>"},{"location":"api/classhal_1_1spi/","title":"Class hal::spi","text":"<p>ClassList &gt; hal &gt; spi</p> <p>Serial peripheral interface (SPI) communication protocol hardware abstract interface. </p> <ul> <li><code>#include &lt;spi.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::lpc40::spi,  hal::mock::write_only_spi</p>"},{"location":"api/classhal_1_1spi/#classes","title":"Classes","text":"Type Name struct settings Generic settings for a standard SPI device. struct transfer_t Feedback from performing a transfer on the spi bus."},{"location":"api/classhal_1_1spi/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr hal::byte default_filler   = = hal::byte"},{"location":"api/classhal_1_1spi/#public-functions","title":"Public Functions","text":"Type Name status configure (const settings &amp; p_settings) Configure spi to match the settings supplied. result&lt; transfer_t &gt; transfer (std::span&lt; const hal::byte &gt; p_data_out, std::span&lt; hal::byte &gt; p_data_in, hal::byte p_filler=default_filler) Send and receive data between a selected device on the spi bus. This function will block until the entire transfer is finished. virtual ~spi () = default"},{"location":"api/classhal_1_1spi/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/classhal_1_1spi/#variable-default_filler","title":"variable default_filler","text":"<pre><code>constexpr hal::byte hal::spi::default_filler;\n</code></pre> <p>Default filler data placed on the bus in place of actual write data when the write buffer has been exhausted. </p>"},{"location":"api/classhal_1_1spi/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1spi/#function-configure","title":"function configure","text":"<p>Configure spi to match the settings supplied. <pre><code>inline status hal::spi::configure (\n    const settings &amp; p_settings\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_settings</code> - settings to apply to spi </li> </ul> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::invalid_argument</code> if the settings could not be achieved. </li> </ul>"},{"location":"api/classhal_1_1spi/#function-transfer","title":"function transfer","text":"<p>Send and receive data between a selected device on the spi bus. This function will block until the entire transfer is finished. <pre><code>inline result&lt; transfer_t &gt; hal::spi::transfer (\n    std::span&lt; const hal::byte &gt; p_data_out,\n    std::span&lt; hal::byte &gt; p_data_in,\n    hal::byte p_filler=default_filler\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_data_out</code> - buffer to write data to the bus. If this is set to null/empty then writing is ignored and the p_filler will be written to the bus. If the length is less than p_data_in, then p_filler will be written to the bus after this buffer has been sent. </li> <li><code>p_data_in</code> - buffer to read the data off of the bus. If this is null/empty, then the transfer will be write only and the incoming data will be ignored. If the length of this buffer is less than p_data_out, once this buffer has been filled, the rest of the received bytes on the bus will be dropped. </li> <li><code>p_filler</code> - filler data placed on the bus in place of actual write data when p_data_out has been exhausted. </li> </ul> <p>Returns:</p> <p>result&lt;transfer_t&gt; - success or failure </p>"},{"location":"api/classhal_1_1spi/#function-spi","title":"function ~spi","text":"<pre><code>virtual hal::spi::~spi () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/spi.hpp</code></p>"},{"location":"api/structhal_1_1spi_1_1settings/","title":"Struct hal::spi::settings","text":"<p>ClassList &gt; hal &gt; spi &gt; settings</p> <p>Generic settings for a standard SPI device. </p> <ul> <li><code>#include &lt;spi.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1spi_1_1settings/#public-attributes","title":"Public Attributes","text":"Type Name bool clock_idles_high   = = falseThe polarity of the pins when the signal is idle. hertz clock_rate   = = 100.0_kHzSerial clock frequency in hertz. bool data_valid_on_trailing_edge   = = falseThe phase of the clock signal when communicating."},{"location":"api/structhal_1_1spi_1_1settings/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1spi_1_1settings/#variable-clock_idles_high","title":"variable clock_idles_high","text":"<pre><code>bool hal::spi::settings::clock_idles_high;\n</code></pre>"},{"location":"api/structhal_1_1spi_1_1settings/#variable-clock_rate","title":"variable clock_rate","text":"<pre><code>hertz hal::spi::settings::clock_rate;\n</code></pre>"},{"location":"api/structhal_1_1spi_1_1settings/#variable-data_valid_on_trailing_edge","title":"variable data_valid_on_trailing_edge","text":"<pre><code>bool hal::spi::settings::data_valid_on_trailing_edge;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/spi.hpp</code></p>"},{"location":"api/structhal_1_1spi_1_1transfer__t/","title":"Struct hal::spi::transfer_t","text":"<p>ClassList &gt; hal &gt; spi &gt; transfer_t</p> <p>Feedback from performing a transfer on the spi bus. More...</p> <ul> <li><code>#include &lt;spi.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1spi_1_1transfer__t/#detailed-description","title":"Detailed Description","text":"<p>This structure is currently empty as no feedback has been determined for now. This structure may be expanded in the future. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/spi.hpp</code></p>"},{"location":"api/classhal_1_1spy__handler/","title":"Class hal::spy_handler","text":"<p>template &lt;typename... args_t&gt;</p> <p>ClassList &gt; hal &gt; spy_handler</p> <p>Helper utility for making mocks for class functions that return status. More...</p> <ul> <li><code>#include &lt;testing.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1spy__handler/#public-functions","title":"Public Functions","text":"Type Name const auto &amp; call_history () constReturn the call history of the save function. const auto &amp; history (size_t p_call) constReturn argument from one of call history parameters. status record (args_t... p_args) Record the arguments of a function being spied on. void reset () Reset call recordings and turns off error trigger. void trigger_error_on_call (int p_call_count_before_trigger) Set the record function to return an error after a specified number of recordings."},{"location":"api/classhal_1_1spy__handler/#detailed-description","title":"Detailed Description","text":"<p>This class stores records of a functions call history in order to be recovered later for inspection in tests and simulations.</p> <p>See pwm_mock.hpp and tests/pwm_mock.test.cpp as an example of how this is done in practice.</p> <p>Template parameters:</p> <ul> <li><code>args_t</code> - the arguments of the class function </li> </ul>"},{"location":"api/classhal_1_1spy__handler/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1spy__handler/#function-call_history","title":"function call_history","text":"<p>Return the call history of the save function. <pre><code>inline const auto &amp; hal::spy_handler::call_history () const\n</code></pre></p> <p>Returns:</p> <p>const auto&amp; - reference to the call history vector </p>"},{"location":"api/classhal_1_1spy__handler/#function-history","title":"function history","text":"<p>Return argument from one of call history parameters. <pre><code>template&lt;size_t ArgumentIndex&gt;\ninline const auto &amp; hal::spy_handler::history (\n    size_t p_call\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_call</code> - history call from 0 to N </li> </ul> <p>Returns:</p> <p>const auto&amp; - reference to the call history vector </p> <p>Exception:</p> <ul> <li><code>std::out_of_range</code> - if p_call is beyond the size of call_history </li> </ul>"},{"location":"api/classhal_1_1spy__handler/#function-record","title":"function record","text":"<p>Record the arguments of a function being spied on. <pre><code>inline status hal::spy_handler::record (\n    args_t... p_args\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_args</code> - arguments to record </li> </ul> <p>Returns:</p> <p>status - success or failure error trigger has been reached. </p>"},{"location":"api/classhal_1_1spy__handler/#function-reset","title":"function reset","text":"<pre><code>inline void hal::spy_handler::reset () \n</code></pre>"},{"location":"api/classhal_1_1spy__handler/#function-trigger_error_on_call","title":"function trigger_error_on_call","text":"<p>Set the record function to return an error after a specified number of recordings. <pre><code>inline void hal::spy_handler::trigger_error_on_call (\n    int p_call_count_before_trigger\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_call_count_before_trigger</code> - how many calls before an error is returned. </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/testing.hpp</code></p>"},{"location":"api/classhal_1_1static__callable/","title":"Class hal::static_callable","text":"<p>template &lt;class owner_class class owner_class, int reference_designator, typename signature typename signature&gt;</p> <p>ClassList &gt; hal &gt; static_callable</p> <p>General class which will be used to allow for signature to be used and then split by the below class. More...</p>"},{"location":"api/classhal_1_1static__callable/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>owner_class</code> class that this static callable belongs to </li> <li><code>reference_designator</code> this template argument is used to generate unique static objects for each needed callback </li> <li><code>signature</code> function signature to be split up in the static_callable specialization </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/static_callable.hpp</code></p>"},{"location":"api/classhal_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4/","title":"Class hal::static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt;","text":"<p>template &lt;class owner_class class owner_class, int reference_designator, typename return_t typename return_t, typename... args_t&gt;</p> <p>ClassList &gt; hal &gt; static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt;</p> <p>Specialization of static_callable with the return type and arguments split up.More...</p> <ul> <li><code>#include &lt;static_callable.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4/#public-functions","title":"Public Functions","text":"Type Name auto * get_handler () Get the static function's address. static_callable (hal::callback&lt; return_t(args_t... p_args)&gt; p_callback) Construct a new static callable object."},{"location":"api/classhal_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>owner_class</code> see static_callable </li> <li><code>reference_designator</code> see static_callable </li> <li><code>return_t</code> function's return type </li> <li><code>args_t</code> function's set of arguments </li> </ul>"},{"location":"api/classhal_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4/#function-get_handler","title":"function get_handler","text":"<p>Get the static function's address. <pre><code>inline auto * hal::static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt;::get_handler () \n</code></pre></p> <p>Returns:</p> <p>auto* - static function's address </p>"},{"location":"api/classhal_1_1static__callable_3_01owner__class_00_01reference__designator_00_01return__t_07args__t_8_8_8_01p__args_08_4/#function-static_callable","title":"function static_callable","text":"<p>Construct a new static callable object. <pre><code>inline explicit hal::static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt;::static_callable (\n    hal::callback &lt; return_t(args_t... p_args)&gt; p_callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_callback</code> - when the static callback function is called, it will call this callback </li> </ul> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/static_callable.hpp</code></p>"},{"location":"api/classhal_1_1static__list/","title":"Class hal::static_list","text":"<p>template &lt;class Object class Object&gt;</p> <p>ClassList &gt; hal &gt; static_list</p> <p>static_list is a non-owning non-allocating doubly linked list container with O(1) memory utilization.More...</p> <ul> <li><code>#include &lt;static_list.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1static__list/#classes","title":"Classes","text":"Type Name class item Item/node within the static linked list. class item_iterator Iterator for the static list."},{"location":"api/classhal_1_1static__list/#public-types","title":"Public Types","text":"Type Name typedef const item_iterator const_iterator typedef const value_type * const_pointer typedef const Object &amp; const_reference typedef std::ptrdiff_t difference_type typedef item_iterator iterator typedef value_type * pointer typedef Object &amp; reference typedef std::size_t size_type typedef Object value_type"},{"location":"api/classhal_1_1static__list/#public-functions","title":"Public Functions","text":"Type Name constexpr auto begin ()  constexpr auto begin () const constexpr auto cbegin () const constexpr auto cend () const constexpr bool empty ()  constexpr auto end ()  constexpr auto end () const constexpr static_list &amp; operator= (static_list &amp; p_other) = delete constexpr static_list &amp; operator= (static_list &amp;&amp; p_other)  constexpr item push_back () Add default constructed item to the end of the list. constexpr item push_back (const Object &amp; p_value) Append item to the end of the static list. constexpr item push_back (Object &amp;&amp; p_value) Append item to the end of the static list. constexpr std::size_t size () const constexpr static_list ()  constexpr static_list (static_list &amp; p_other) = delete constexpr static_list (static_list &amp;&amp; p_other)  ~static_list ()"},{"location":"api/classhal_1_1static__list/#detailed-description","title":"Detailed Description","text":"<p>Items in the list cannot be destroyed by</p> <p>Template parameters:</p> <ul> <li><code>Object</code> - The type of the elements. Object must be \"MoveAssignable\" and \"MoveConstructible\". </li> </ul>"},{"location":"api/classhal_1_1static__list/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classhal_1_1static__list/#typedef-const_iterator","title":"typedef const_iterator","text":"<pre><code>using hal::static_list&lt; Object &gt;::const_iterator =  const item_iterator;\n</code></pre>"},{"location":"api/classhal_1_1static__list/#typedef-const_pointer","title":"typedef const_pointer","text":"<pre><code>using hal::static_list&lt; Object &gt;::const_pointer =  const value_type*;\n</code></pre>"},{"location":"api/classhal_1_1static__list/#typedef-const_reference","title":"typedef const_reference","text":"<pre><code>using hal::static_list&lt; Object &gt;::const_reference =  const Object&amp;;\n</code></pre>"},{"location":"api/classhal_1_1static__list/#typedef-difference_type","title":"typedef difference_type","text":"<pre><code>using hal::static_list&lt; Object &gt;::difference_type =  std::ptrdiff_t;\n</code></pre>"},{"location":"api/classhal_1_1static__list/#typedef-iterator","title":"typedef iterator","text":"<pre><code>using hal::static_list&lt; Object &gt;::iterator =  item_iterator;\n</code></pre>"},{"location":"api/classhal_1_1static__list/#typedef-pointer","title":"typedef pointer","text":"<pre><code>using hal::static_list&lt; Object &gt;::pointer =  value_type*;\n</code></pre>"},{"location":"api/classhal_1_1static__list/#typedef-reference","title":"typedef reference","text":"<pre><code>using hal::static_list&lt; Object &gt;::reference =  Object&amp;;\n</code></pre>"},{"location":"api/classhal_1_1static__list/#typedef-size_type","title":"typedef size_type","text":"<pre><code>using hal::static_list&lt; Object &gt;::size_type =  std::size_t;\n</code></pre>"},{"location":"api/classhal_1_1static__list/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using hal::static_list&lt; Object &gt;::value_type =  Object;\n</code></pre>"},{"location":"api/classhal_1_1static__list/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1static__list/#function-begin-12","title":"function begin [1/2]","text":"<pre><code>inline constexpr auto hal::static_list::begin () \n</code></pre>"},{"location":"api/classhal_1_1static__list/#function-begin-22","title":"function begin [2/2]","text":"<pre><code>inline constexpr auto hal::static_list::begin () const\n</code></pre>"},{"location":"api/classhal_1_1static__list/#function-cbegin","title":"function cbegin","text":"<pre><code>inline constexpr auto hal::static_list::cbegin () const\n</code></pre>"},{"location":"api/classhal_1_1static__list/#function-cend","title":"function cend","text":"<pre><code>inline constexpr auto hal::static_list::cend () const\n</code></pre>"},{"location":"api/classhal_1_1static__list/#function-empty","title":"function empty","text":"<pre><code>inline constexpr bool hal::static_list::empty () \n</code></pre>"},{"location":"api/classhal_1_1static__list/#function-end-12","title":"function end [1/2]","text":"<pre><code>inline constexpr auto hal::static_list::end () \n</code></pre>"},{"location":"api/classhal_1_1static__list/#function-end-22","title":"function end [2/2]","text":"<pre><code>inline constexpr auto hal::static_list::end () const\n</code></pre>"},{"location":"api/classhal_1_1static__list/#function-operator","title":"function operator=","text":"<pre><code>constexpr static_list &amp; hal::static_list::operator= (\n    static_list &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1static__list/#function-operator_1","title":"function operator=","text":"<pre><code>inline constexpr static_list &amp; hal::static_list::operator= (\n    static_list &amp;&amp; p_other\n) \n</code></pre>"},{"location":"api/classhal_1_1static__list/#function-push_back-13","title":"function push_back [1/3]","text":"<p>Add default constructed item to the end of the list. <pre><code>inline constexpr item hal::static_list::push_back () \n</code></pre></p> <p>Only works for Object's that support default construction.</p> <p>Returns:</p> <p>constexpr item - item with default constructed value </p>"},{"location":"api/classhal_1_1static__list/#function-push_back-23","title":"function push_back [2/3]","text":"<p>Append item to the end of the static list. <pre><code>inline constexpr item hal::static_list::push_back (\n    const Object &amp; p_value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_value</code> - value of node </li> </ul> <p>Returns:</p> <p>constexpr item - item with constructed value based on the input </p>"},{"location":"api/classhal_1_1static__list/#function-push_back-33","title":"function push_back [3/3]","text":"<p>Append item to the end of the static list. <pre><code>inline constexpr item hal::static_list::push_back (\n    Object &amp;&amp; p_value\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_value</code> - value of node </li> </ul> <p>Returns:</p> <p>constexpr item - item with constructed value based on the input </p>"},{"location":"api/classhal_1_1static__list/#function-size","title":"function size","text":"<pre><code>inline constexpr std::size_t hal::static_list::size () const\n</code></pre>"},{"location":"api/classhal_1_1static__list/#function-static_list-13","title":"function static_list [1/3]","text":"<pre><code>inline constexpr hal::static_list::static_list () \n</code></pre>"},{"location":"api/classhal_1_1static__list/#function-static_list-23","title":"function static_list [2/3]","text":"<pre><code>constexpr hal::static_list::static_list (\n    static_list &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1static__list/#function-static_list-33","title":"function static_list [3/3]","text":"<pre><code>inline constexpr hal::static_list::static_list (\n    static_list &amp;&amp; p_other\n) \n</code></pre>"},{"location":"api/classhal_1_1static__list/#function-static_list","title":"function ~static_list","text":"<pre><code>inline hal::static_list::~static_list () \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/static_list.hpp</code></p>"},{"location":"api/classhal_1_1static__list_1_1item/","title":"Class hal::static_list::item","text":"<p>ClassList &gt; hal &gt; static_list &gt; item</p> <p>Item/node within the static linked list. More...</p> <ul> <li><code>#include &lt;static_list.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1static__list_1_1item/#public-functions","title":"Public Functions","text":"Type Name auto &amp; get ()  const auto &amp; get () const constexpr item (static_list * p_list, const Object &amp; p_object)  constexpr item (static_list * p_list, Object &amp;&amp; p_object)  constexpr item (item &amp; p_other) = delete constexpr item (item &amp;&amp; p_other)  const auto * list () const auto &amp; operator* ()  const auto &amp; operator* () const constexpr item &amp; operator= (item &amp; p_other) = delete constexpr item &amp; operator= (item &amp;&amp; p_other)  ~item ()"},{"location":"api/classhal_1_1static__list_1_1item/#detailed-description","title":"Detailed Description","text":"<p>This object does not allow copies. When moved, the object will determine its new location in memory, and will update the linked list to the new location and invalidate the old location. This ensures that this item's position in memory, if whether returned from a function or relocated in some other way, is always tracked by the list.</p> <p>An item can only be removed from the list if it is no longer accessible (goes out of scope) or is destructed explicitly (DO NOT DO THIS).</p> <p>The return value of push_back MUST be saved to a variable. Failing to do so will result in the object being destructed and removed from the list due to it being inaccessible.  </p>"},{"location":"api/classhal_1_1static__list_1_1item/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1static__list_1_1item/#function-get-12","title":"function get [1/2]","text":"<pre><code>inline auto &amp; hal::static_list::item::get () \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item/#function-get-22","title":"function get [2/2]","text":"<pre><code>inline const auto &amp; hal::static_list::item::get () const\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item/#function-item-14","title":"function item [1/4]","text":"<pre><code>inline constexpr hal::static_list::item::item (\n    static_list * p_list,\n    const Object &amp; p_object\n) \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item/#function-item-24","title":"function item [2/4]","text":"<pre><code>inline constexpr hal::static_list::item::item (\n    static_list * p_list,\n    Object &amp;&amp; p_object\n) \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item/#function-item-34","title":"function item [3/4]","text":"<pre><code>constexpr hal::static_list::item::item (\n    item &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item/#function-item-44","title":"function item [4/4]","text":"<pre><code>inline constexpr hal::static_list::item::item (\n    item &amp;&amp; p_other\n) \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item/#function-list","title":"function list","text":"<pre><code>inline const auto * hal::static_list::item::list () const\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item/#function-operator","title":"function operator*","text":"<pre><code>inline auto &amp; hal::static_list::item::operator* () \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item/#function-operator_1","title":"function operator*","text":"<pre><code>inline const auto &amp; hal::static_list::item::operator* () const\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item/#function-operator_2","title":"function operator=","text":"<pre><code>constexpr item &amp; hal::static_list::item::operator= (\n    item &amp; p_other\n) = delete\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item/#function-operator_3","title":"function operator=","text":"<pre><code>inline constexpr item &amp; hal::static_list::item::operator= (\n    item &amp;&amp; p_other\n) \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item/#function-item","title":"function ~item","text":"<pre><code>inline hal::static_list::item::~item () \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item/#friends-documentation","title":"Friends Documentation","text":""},{"location":"api/classhal_1_1static__list_1_1item/#friend-item_iterator","title":"friend item_iterator","text":"<pre><code>class hal::static_list::item::item_iterator (\n    item_iterator\n) \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item/#friend-static_list","title":"friend static_list","text":"<pre><code>class hal::static_list::item::static_list (\n    static_list\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/static_list.hpp</code></p>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/","title":"Class hal::static_list::item_iterator","text":"<p>ClassList &gt; hal &gt; static_list &gt; item_iterator</p> <p>Iterator for the static list. More...</p> <ul> <li><code>#include &lt;static_list.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#public-types","title":"Public Types","text":"Type Name typedef std::ptrdiff_t difference_type typedef std::bidirectional_iterator_tag iterator_category typedef value_type * pointer typedef value_type &amp; reference typedef Object value_type"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#public-functions","title":"Public Functions","text":"Type Name item_iterator (item * p_item, const static_list * p_list=nullptr)  bool operator!= (const item_iterator &amp; p_other) const reference operator* ()  reference operator* () const item_iterator operator++ ()  item_iterator operator++ (] int p_other)  item_iterator operator-- ()  item_iterator operator-- (] int p_other)  pointer operator-&gt; ()  pointer operator-&gt; () const bool operator== (const item_iterator &amp; p_other) const"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#detailed-description","title":"Detailed Description","text":"<p>Implements the C++ named requirement of \"LegacyBidirectionalIterator\". </p>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/classhal_1_1static__list_1_1item__iterator/#typedef-difference_type","title":"typedef difference_type","text":"<pre><code>using hal::static_list&lt; Object &gt;::item_iterator::difference_type =  std::ptrdiff_t;\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#typedef-iterator_category","title":"typedef iterator_category","text":"<pre><code>using hal::static_list&lt; Object &gt;::item_iterator::iterator_category =  std::bidirectional_iterator_tag;\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#typedef-pointer","title":"typedef pointer","text":"<pre><code>using hal::static_list&lt; Object &gt;::item_iterator::pointer =  value_type*;\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#typedef-reference","title":"typedef reference","text":"<pre><code>using hal::static_list&lt; Object &gt;::item_iterator::reference =  value_type&amp;;\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#typedef-value_type","title":"typedef value_type","text":"<pre><code>using hal::static_list&lt; Object &gt;::item_iterator::value_type =  Object;\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1static__list_1_1item__iterator/#function-item_iterator","title":"function item_iterator","text":"<pre><code>inline explicit hal::static_list::item_iterator::item_iterator (\n    item * p_item,\n    const static_list * p_list=nullptr\n) \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#function-operator","title":"function operator!=","text":"<pre><code>inline bool hal::static_list::item_iterator::operator!= (\n    const item_iterator &amp; p_other\n) const\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#function-operator_1","title":"function operator*","text":"<pre><code>inline reference hal::static_list::item_iterator::operator* () \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#function-operator_2","title":"function operator*","text":"<pre><code>inline reference hal::static_list::item_iterator::operator* () const\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#function-operator_3","title":"function operator++","text":"<pre><code>inline item_iterator hal::static_list::item_iterator::operator++ () \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#function-operator_4","title":"function operator++","text":"<pre><code>inline item_iterator hal::static_list::item_iterator::operator++ (\n    ] int p_other\n) \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#function-operator-","title":"function operator--","text":"<pre><code>inline item_iterator hal::static_list::item_iterator::operator-- () \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#function-operator-_1","title":"function operator--","text":"<pre><code>inline item_iterator hal::static_list::item_iterator::operator-- (\n    ] int p_other\n) \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#function-operator-_2","title":"function operator-&gt;","text":"<pre><code>inline pointer hal::static_list::item_iterator::operator-&gt; () \n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#function-operator-_3","title":"function operator-&gt;","text":"<pre><code>inline pointer hal::static_list::item_iterator::operator-&gt; () const\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#function-operator_5","title":"function operator==","text":"<pre><code>inline bool hal::static_list::item_iterator::operator== (\n    const item_iterator &amp; p_other\n) const\n</code></pre>"},{"location":"api/classhal_1_1static__list_1_1item__iterator/#friends-documentation","title":"Friends Documentation","text":""},{"location":"api/classhal_1_1static__list_1_1item__iterator/#friend-static_list","title":"friend static_list","text":"<pre><code>class hal::static_list::item_iterator::static_list (\n    static_list\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/static_list.hpp</code></p>"},{"location":"api/classhal_1_1steady__clock/","title":"Class hal::steady_clock","text":"<p>ClassList &gt; hal &gt; steady_clock</p> <p>Hardware abstraction interface for a steady clock mechanism. More...</p> <ul> <li><code>#include &lt;steady_clock.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::cortex_m::dwt_counter,  hal::mock::steady_clock,  hal::soft::inert_steady_clock</p>"},{"location":"api/classhal_1_1steady__clock/#classes","title":"Classes","text":"Type Name struct frequency_t Result from requesting the operating frequency of the steady clock. struct uptime_t Result from calling uptime."},{"location":"api/classhal_1_1steady__clock/#public-functions","title":"Public Functions","text":"Type Name frequency_t frequency () Get the operating frequency of the steady clock. uptime_t uptime () Get the current value of the steady clock. virtual ~steady_clock () = default"},{"location":"api/classhal_1_1steady__clock/#detailed-description","title":"Detailed Description","text":"<p>Implementations of this interface must follow the same requirements as a std::chrono::steady_clock, in that the clock is monotonic &amp; steady. An additional requirement is added to ensure that the clock is reliable. Meaning calls to the interface functions do not return errors because this clock should be infallible. To ensure this, this clock should be driven by the platform's peripheral drivers or some other mechanism that is unlikely to go offline while the platform is in a normal operating state.</p> <p>This clock is steady meaning that subsequent calls to get the uptime of this clock cannot decrease as physical time moves forward and the time between ticks of this clock are constant and defined by the clock's frequency.</p> <p>This can be used to get the time since the boot up, or to be more accurate, the time when the steady clock object is created. This clock is most suitable for measuring time intervals.</p> <p>After creation of this clock, the operating frequency shall not change. </p>"},{"location":"api/classhal_1_1steady__clock/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1steady__clock/#function-frequency","title":"function frequency","text":"<p>Get the operating frequency of the steady clock. <pre><code>inline frequency_t hal::steady_clock::frequency () \n</code></pre></p> <p>Returns:</p> <p>result&lt;frequency_t&gt; - operating frequency of the steady clock. Guaranteed to be a positive value by the implementing driver. </p>"},{"location":"api/classhal_1_1steady__clock/#function-uptime","title":"function uptime","text":"<p>Get the current value of the steady clock. <pre><code>inline uptime_t hal::steady_clock::uptime () \n</code></pre></p> <p>Returns:</p> <p>uptime_t - uptime information </p>"},{"location":"api/classhal_1_1steady__clock/#function-steady_clock","title":"function ~steady_clock","text":"<pre><code>virtual hal::steady_clock::~steady_clock () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/steady_clock.hpp</code></p>"},{"location":"api/structhal_1_1steady__clock_1_1frequency__t/","title":"Struct hal::steady_clock::frequency_t","text":"<p>ClassList &gt; hal &gt; steady_clock &gt; frequency_t</p> <p>Result from requesting the operating frequency of the steady clock. </p> <ul> <li><code>#include &lt;steady_clock.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1steady__clock_1_1frequency__t/#public-attributes","title":"Public Attributes","text":"Type Name hertz operating_frequency the frequency of the steady clock."},{"location":"api/structhal_1_1steady__clock_1_1frequency__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1steady__clock_1_1frequency__t/#variable-operating_frequency","title":"variable operating_frequency","text":"<p>the frequency of the steady clock. <pre><code>hertz hal::steady_clock::frequency_t::operating_frequency;\n</code></pre></p> <p>Guaranteed to be a positive value by the implementing driver. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/steady_clock.hpp</code></p>"},{"location":"api/structhal_1_1steady__clock_1_1uptime__t/","title":"Struct hal::steady_clock::uptime_t","text":"<p>ClassList &gt; hal &gt; steady_clock &gt; uptime_t</p> <p>Result from calling uptime. </p> <ul> <li><code>#include &lt;steady_clock.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1steady__clock_1_1uptime__t/#public-attributes","title":"Public Attributes","text":"Type Name std::uint64_t ticks Number of counts that the steady clock has counted since it started."},{"location":"api/structhal_1_1steady__clock_1_1uptime__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1steady__clock_1_1uptime__t/#variable-ticks","title":"variable ticks","text":"<pre><code>std::uint64_t hal::steady_clock::uptime_t::ticks;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/steady_clock.hpp</code></p>"},{"location":"api/classhal_1_1steady__clock__timeout/","title":"Class hal::steady_clock_timeout","text":"<p>ClassList &gt; hal &gt; steady_clock_timeout</p> <p>Timeout object based on hal::steady_clock .More...</p> <ul> <li><code>#include &lt;steady_clock.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1steady__clock__timeout/#public-functions","title":"Public Functions","text":"Type Name status operator() () Call this object to check if it has timed out. steady_clock_timeout &amp; operator= (const steady_clock_timeout &amp; p_timeout) = defaultAssign construct a new counter timeout object. steady_clock_timeout &amp; operator= (steady_clock_timeout &amp;&amp; p_timeout) = defaultMove assign construct a new counter timeout object. steady_clock_timeout (const steady_clock_timeout &amp; p_timeout) = defaultConstruct a new counter timeout object. steady_clock_timeout (steady_clock_timeout &amp;&amp; p_timeout) = defaultConstruct a new counter timeout object."},{"location":"api/classhal_1_1steady__clock__timeout/#public-static-functions","title":"Public Static Functions","text":"Type Name steady_clock_timeout create (hal::steady_clock &amp; p_steady_clock, hal::time_duration p_duration) Create a steady_clock_timeout ."},{"location":"api/classhal_1_1steady__clock__timeout/#detailed-description","title":"Detailed Description","text":"<p>Do not use this class directly. Use <code>hal::create_timeout(hal::steady_clock&amp;)</code> instead of instantiating this class directly. </p>"},{"location":"api/classhal_1_1steady__clock__timeout/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1steady__clock__timeout/#function-operator","title":"function operator()","text":"<p>Call this object to check if it has timed out. <pre><code>status hal::steady_clock_timeout::operator() () \n</code></pre></p> <p>Returns:</p> <p>status - success or failure </p> <p>Exception:</p> <ul> <li><code>std::errc::timed_out</code> - if the timeout time has been exceeded. </li> </ul>"},{"location":"api/classhal_1_1steady__clock__timeout/#function-operator_1","title":"function operator=","text":"<p>Assign construct a new counter timeout object. <pre><code>steady_clock_timeout &amp; hal::steady_clock_timeout::operator= (\n    const steady_clock_timeout &amp; p_timeout\n) = default\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_timeout</code> - other steady_clock_timeout </li> </ul> <p>Returns:</p> <p>steady_clock_timeout&amp; </p>"},{"location":"api/classhal_1_1steady__clock__timeout/#function-operator_2","title":"function operator=","text":"<p>Move assign construct a new counter timeout object. <pre><code>steady_clock_timeout &amp; hal::steady_clock_timeout::operator= (\n    steady_clock_timeout &amp;&amp; p_timeout\n) = default\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_timeout</code> - other steady_clock_timeout </li> </ul> <p>Returns:</p> <p>steady_clock_timeout&amp; </p>"},{"location":"api/classhal_1_1steady__clock__timeout/#function-steady_clock_timeout-13","title":"function steady_clock_timeout [1/3]","text":"<p>Construct a new counter timeout object. <pre><code>hal::steady_clock_timeout::steady_clock_timeout (\n    const steady_clock_timeout &amp; p_timeout\n) = default\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_timeout</code> - other steady_clock_timeout </li> </ul>"},{"location":"api/classhal_1_1steady__clock__timeout/#function-steady_clock_timeout-23","title":"function steady_clock_timeout [2/3]","text":"<p>Construct a new counter timeout object. <pre><code>hal::steady_clock_timeout::steady_clock_timeout (\n    steady_clock_timeout &amp;&amp; p_timeout\n) = default\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_timeout</code> - other steady_clock_timeout </li> </ul>"},{"location":"api/classhal_1_1steady__clock__timeout/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1steady__clock__timeout/#function-create","title":"function create","text":"<p>Create a steady_clock_timeout . <pre><code>static steady_clock_timeout hal::steady_clock_timeout::create (\n    hal::steady_clock &amp; p_steady_clock,\n    hal::time_duration p_duration\n) \n</code></pre></p> <p>Returns:</p> <p>steady_clock_timeout - steady_clock_timeout object </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/steady_clock.hpp</code></p>"},{"location":"api/namespacehal_1_1stm32f1/","title":"Namespace hal::stm32f1","text":"<p>Namespace List &gt; hal &gt; stm32f1</p>"},{"location":"api/namespacehal_1_1stm32f1/#classes","title":"Classes","text":"Type Name struct clock_tree class output_pin Output pin implementation for the stm32::f10x."},{"location":"api/namespacehal_1_1stm32f1/#public-types","title":"Public Types","text":"Type Name enum std::uint8_t adc_divider Available dividers for the ADC bus. enum std::uint8_t ahb_divider Available dividers for the AHB bus. enum std::uint8_t apb_divider Available dividers for the APB bus. enum std::uint16_t error_t Error types for stm32f1. enum std::uint16_t irq List of interrupt request numbers for this platform. enum std::uint8_t peripheral List of each peripheral and their power on id number for this platform. enum std::uint8_t pll_multiply PLL frequency multiplication options. enum std::uint8_t pll_source Available clock sources for the PLL. enum std::uint8_t rtc_source Available clock sources for the RTC. enum std::uint8_t system_clock_select Available clock sources available for the system clock. enum std::uint8_t usb_divider Available dividers for the USB peripheral."},{"location":"api/namespacehal_1_1stm32f1/#public-attributes","title":"Public Attributes","text":"Type Name constexpr auto flash_clock   = = internal_high_speed_oscillatorConstant for the frequency of the Flash Controller. constexpr auto internal_high_speed_oscillator   = = 8.0_MHzConstant for the frequency of the HSE. constexpr auto internal_low_speed_oscillator   = = 20.0_kHzConstant for the frequency of the LSE. constexpr auto watchdog_clock_rate   = = internal_low_speed_oscillatorConstant for the frequency of the Watch Dog Peripheral."},{"location":"api/namespacehal_1_1stm32f1/#public-static-attributes","title":"Public Static Attributes","text":"Type Name constexpr std::uint32_t ahb_bus   = = bus_id_offset * 0Bit position of AHB. constexpr std::uint32_t apb1_bus   = = bus_id_offset * 1Bit position of APB1. constexpr std::uint32_t apb2_bus   = = bus_id_offset * 2Bit position of AHB2. constexpr std::uint32_t beyond_bus   = = bus_id_offset * 3Bit position of systems outside of any bus. constexpr std::uint32_t bus_id_offset   = = 32Number of bits between each enable register."},{"location":"api/namespacehal_1_1stm32f1/#public-functions","title":"Public Functions","text":"Type Name void configure_clocks (clock_tree p_clock_tree)  hal::hertz frequency (peripheral p_id)  void release_jtag_pins () Make JTAG pins not associated with SWD available as IO."},{"location":"api/namespacehal_1_1stm32f1/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"api/namespacehal_1_1stm32f1/#enum-adc_divider","title":"enum adc_divider","text":"<pre><code>enum hal::stm32f1::adc_divider {\n    divide_by_2 = 0b00,\n    divide_by_4 = 0b01,\n    divide_by_6 = 0b10,\n    divide_by_8 = 0b11\n};\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#enum-ahb_divider","title":"enum ahb_divider","text":"<pre><code>enum hal::stm32f1::ahb_divider {\n    divide_by_1 = 0,\n    divide_by_2 = 0b1000,\n    divide_by_4 = 0b1001,\n    divide_by_8 = 0b1010,\n    divide_by_16 = 0b1011,\n    divide_by_64 = 0b1100,\n    divide_by_128 = 0b1101,\n    divide_by_256 = 0b1110,\n    divide_by_512 = 0b1111\n};\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#enum-apb_divider","title":"enum apb_divider","text":"<pre><code>enum hal::stm32f1::apb_divider {\n    divide_by_1 = 0,\n    divide_by_2 = 0b100,\n    divide_by_4 = 0b101,\n    divide_by_8 = 0b110,\n    divide_by_16 = 0b111\n};\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#enum-error_t","title":"enum error_t","text":"<pre><code>enum hal::stm32f1::error_t {\n    max\n};\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#enum-irq","title":"enum irq","text":"<pre><code>enum hal::stm32f1::irq {\n    window_watchdog = 0,\n    pvd = 1,\n    tamper = 2,\n    rtc = 3,\n    flash = 4,\n    rcc = 5,\n    exti0 = 6,\n    exti1 = 7,\n    exti2 = 8,\n    exti3 = 9,\n    exti4 = 10,\n    dma1_channel1 = 11,\n    dma1_channel2 = 12,\n    dma1_channel3 = 13,\n    dma1_channel4 = 14,\n    dma1_channel5 = 15,\n    dma1_channel6 = 16,\n    dma1_channel7 = 17,\n    adc1 = 18,\n    adc1_2 = 18,\n    usb_hp_can1_tx = 19,\n    can1_tx = 19,\n    usb_lp_can1_rx0 = 20,\n    can1_rx0 = 20,\n    can1_rx1 = 21,\n    can1_sce = 22,\n    exti9_5 = 23,\n    tim1_brk = 24,\n    tim1_brk_tim15 = 24,\n    tim1_brk_tim9 = 24,\n    tim1_up = 25,\n    tim1_up_tim16 = 25,\n    tim1_up_tim10 = 25,\n    tim1_trg_com = 26,\n    tim1_trg_com_tim11 = 26,\n    tim1_cc = 27,\n    tim2 = 28,\n    tim3 = 29,\n    tim4 = 30,\n    i2c1_ev = 31,\n    i2c1_er = 32,\n    i2c2_ev = 33,\n    i2c2_er = 34,\n    spi1 = 35,\n    spi2 = 36,\n    usart1 = 37,\n    usart2 = 38,\n    usart3 = 39,\n    exti15_10 = 40,\n    rtcalarm = 41,\n    usbwakeup = 42,\n    cec = 42,\n    otg_fs_wkup = 42,\n    tim8_brk = 43,\n    tim12 = 43,\n    tim8_brk_tim12 = 43,\n    tim8_up = 44,\n    tim13 = 44,\n    tim8_up_tim13 = 44,\n    tim8_trg_com = 45,\n    tim14 = 45,\n    tim8_trg_com_tim14 = 45,\n    tim8_cc = 46,\n    adc3 = 47,\n    fsmc = 48,\n    sdio = 49,\n    tim5 = 50,\n    spi3 = 51,\n    uart4 = 52,\n    uart5 = 53,\n    tim6_dac = 54,\n    tim6 = 54,\n    tim7 = 55,\n    dma2_channel1 = 56,\n    dma2_channel2 = 57,\n    dma2_channel3 = 58,\n    dma2_channel4_5 = 59,\n    dma2_channel4 = 59,\n    dma2_channel5 = 60,\n    eth = 61,\n    eth_wkup = 62,\n    can2_tx = 63,\n    can2_rx0 = 64,\n    can2_rx1 = 65,\n    can2_sce = 66,\n    otg_fs = 67,\n    max\n};\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#enum-peripheral","title":"enum peripheral","text":"<pre><code>enum hal::stm32f1::peripheral {\n    dma1 = ahb_bus + 0,\n    dma2 = ahb_bus + 1,\n    sram = ahb_bus + 2,\n    flitf = ahb_bus + 4,\n    crc = ahb_bus + 6,\n    fsmc = ahb_bus + 8,\n    sdio = ahb_bus + 10,\n    timer2 = apb1_bus + 0,\n    timer3 = apb1_bus + 1,\n    timer4 = apb1_bus + 2,\n    timer5 = apb1_bus + 3,\n    timer6 = apb1_bus + 4,\n    timer7 = apb1_bus + 5,\n    timer12 = apb1_bus + 6,\n    timer13 = apb1_bus + 7,\n    timer14 = apb1_bus + 8,\n    window_watchdog = apb1_bus + 11,\n    spi2 = apb1_bus + 14,\n    spi3 = apb1_bus + 15,\n    usart2 = apb1_bus + 17,\n    usart3 = apb1_bus + 18,\n    uart4 = apb1_bus + 19,\n    uart5 = apb1_bus + 20,\n    i2c1 = apb1_bus + 21,\n    i2c2 = apb1_bus + 22,\n    usb = apb1_bus + 23,\n    can1 = apb1_bus + 25,\n    backup_clock = apb1_bus + 27,\n    power = apb1_bus + 28,\n    dac = apb1_bus + 29,\n    afio = apb2_bus + 0,\n    gpio_a = apb2_bus + 2,\n    gpio_b = apb2_bus + 3,\n    gpio_c = apb2_bus + 4,\n    gpio_d = apb2_bus + 5,\n    gpio_e = apb2_bus + 6,\n    gpio_f = apb2_bus + 7,\n    gpio_g = apb2_bus + 8,\n    adc1 = apb2_bus + 9,\n    adc2 = apb2_bus + 10,\n    timer1 = apb2_bus + 11,\n    spi1 = apb2_bus + 12,\n    timer8 = apb2_bus + 13,\n    usart1 = apb2_bus + 14,\n    adc3 = apb2_bus + 15,\n    timer9 = apb2_bus + 19,\n    timer10 = apb2_bus + 20,\n    timer11 = apb2_bus + 21,\n    cpu = beyond_bus + 0,\n    system_timer = beyond_bus + 1,\n    i2s = beyond_bus + 2\n};\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#enum-pll_multiply","title":"enum pll_multiply","text":"<pre><code>enum hal::stm32f1::pll_multiply {\n    multiply_by_2 = 0b0000,\n    multiply_by_3 = 0b0001,\n    multiply_by_4 = 0b0010,\n    multiply_by_5 = 0b0011,\n    multiply_by_6 = 0b0100,\n    multiply_by_7 = 0b0101,\n    multiply_by_8 = 0b0110,\n    multiply_by_9 = 0b0111,\n    multiply_by_10 = 0b1000,\n    multiply_by_11 = 0b1001,\n    multiply_by_12 = 0b1010,\n    multiply_by_13 = 0b1011,\n    multiply_by_14 = 0b1100,\n    multiply_by_15 = 0b1101,\n    multiply_by_16 = 0b1110\n};\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#enum-pll_source","title":"enum pll_source","text":"<pre><code>enum hal::stm32f1::pll_source {\n    high_speed_internal = 0b0,\n    high_speed_external = 0b1,\n    high_speed_external_divided_by_2 = 0b11\n};\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#enum-rtc_source","title":"enum rtc_source","text":"<pre><code>enum hal::stm32f1::rtc_source {\n    no_clock = 0b00,\n    low_speed_internal = 0b01,\n    low_speed_external = 0b10,\n    high_speed_external_divided_by_128 = 0b11\n};\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#enum-system_clock_select","title":"enum system_clock_select","text":"<pre><code>enum hal::stm32f1::system_clock_select {\n    high_speed_internal = 0b00,\n    high_speed_external = 0b01,\n    pll = 0b10\n};\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#enum-usb_divider","title":"enum usb_divider","text":"<pre><code>enum hal::stm32f1::usb_divider {\n    divide_by_1 = 1,\n    divide_by_1_point_5 = 0\n};\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/namespacehal_1_1stm32f1/#variable-flash_clock","title":"variable flash_clock","text":"<pre><code>constexpr auto hal::stm32f1::flash_clock;\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#variable-internal_high_speed_oscillator","title":"variable internal_high_speed_oscillator","text":"<pre><code>constexpr auto hal::stm32f1::internal_high_speed_oscillator;\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#variable-internal_low_speed_oscillator","title":"variable internal_low_speed_oscillator","text":"<pre><code>constexpr auto hal::stm32f1::internal_low_speed_oscillator;\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#variable-watchdog_clock_rate","title":"variable watchdog_clock_rate","text":"<pre><code>constexpr auto hal::stm32f1::watchdog_clock_rate;\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"api/namespacehal_1_1stm32f1/#variable-ahb_bus","title":"variable ahb_bus","text":"<pre><code>constexpr std::uint32_t hal::stm32f1::ahb_bus;\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#variable-apb1_bus","title":"variable apb1_bus","text":"<pre><code>constexpr std::uint32_t hal::stm32f1::apb1_bus;\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#variable-apb2_bus","title":"variable apb2_bus","text":"<pre><code>constexpr std::uint32_t hal::stm32f1::apb2_bus;\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#variable-beyond_bus","title":"variable beyond_bus","text":"<pre><code>constexpr std::uint32_t hal::stm32f1::beyond_bus;\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#variable-bus_id_offset","title":"variable bus_id_offset","text":"<pre><code>constexpr std::uint32_t hal::stm32f1::bus_id_offset;\n</code></pre>"},{"location":"api/namespacehal_1_1stm32f1/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/namespacehal_1_1stm32f1/#function-configure_clocks","title":"function configure_clocks","text":"<pre><code>void hal::stm32f1::configure_clocks (\n    clock_tree p_clock_tree\n) \n</code></pre> <p>Attention:</p> <p>If configuration of the system clocks is desired, one should consult the user manual of the target MCU in use to determine the valid clock configuration values that can/should be used. The Initialize() method is only responsible for configuring the clock system based on configurations in the clock_configuration. Incorrect configurations may result in a hard fault or cause the clock system(s) to supply incorrect clock rate(s).</p> <p>See also: Figure 11. Clock Tree https://www.st.com/resource/en/reference_manual/cd00171190-stm32f101xx-stm32f102xx-stm32f103xx-stm32f105xx-and-stm32f107xx-advanced-arm-based-32-bit-mcus-stmicroelectronics.pdf#page=126 </p>"},{"location":"api/namespacehal_1_1stm32f1/#function-frequency","title":"function frequency","text":"<pre><code>hal::hertz hal::stm32f1::frequency (\n    peripheral p_id\n) \n</code></pre> <p>Returns:</p> <p>the clock rate frequency of a peripheral </p>"},{"location":"api/namespacehal_1_1stm32f1/#function-release_jtag_pins","title":"function release_jtag_pins","text":"<p>Make JTAG pins not associated with SWD available as IO. <pre><code>void hal::stm32f1::release_jtag_pins () \n</code></pre></p> <p>The GPIO pins PB3, PB4, and PA15 are default initalized to be used for JTAG purposes. If you are using SWD and want to use these pins as GPIO or as other alternative functions, this function MUST be called. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/clock.hpp</code></p>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree/","title":"Struct hal::stm32f1::clock_tree","text":"<p>ClassList &gt; hal &gt; stm32f1 &gt; clock_tree</p>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree/#classes","title":"Classes","text":"Type Name struct ahb_t Defines the configuration of the dividers beyond system clock mux. struct pll_t Defines the configuration of the PLL. struct rtc_t Defines the configuration for the RTC."},{"location":"api/structhal_1_1stm32f1_1_1clock__tree/#public-attributes","title":"Public Attributes","text":"Type Name struct hal::stm32f1::clock_tree::ahb_t ahb   = = {} hal::hertz high_speed_external   = = 0.0_MHzDefines the frequency of the high speed external clock signal. hal::hertz low_speed_external   = = 0.0_MHzDefines the frequency of the low speed external clock signal. struct hal::stm32f1::clock_tree::pll_t pll   = = {} struct hal::stm32f1::clock_tree::rtc_t rtc   = = {} system_clock_select system_clock   = = system_clock_select::high_speed_internal"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1stm32f1_1_1clock__tree/#variable-ahb","title":"variable ahb","text":"<pre><code>struct hal::stm32f1::clock_tree::ahb_t hal::stm32f1::clock_tree::ahb;\n</code></pre>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree/#variable-high_speed_external","title":"variable high_speed_external","text":"<pre><code>hal::hertz hal::stm32f1::clock_tree::high_speed_external;\n</code></pre>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree/#variable-low_speed_external","title":"variable low_speed_external","text":"<pre><code>hal::hertz hal::stm32f1::clock_tree::low_speed_external;\n</code></pre>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree/#variable-pll","title":"variable pll","text":"<pre><code>struct hal::stm32f1::clock_tree::pll_t hal::stm32f1::clock_tree::pll;\n</code></pre>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree/#variable-rtc","title":"variable rtc","text":"<pre><code>struct hal::stm32f1::clock_tree::rtc_t hal::stm32f1::clock_tree::rtc;\n</code></pre>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree/#variable-system_clock","title":"variable system_clock","text":"<pre><code>system_clock_select hal::stm32f1::clock_tree::system_clock;\n</code></pre> <p>Defines which clock source will be use for the system. </p> <p>Warning:</p> <p>System will lock up in the following situations: * Select PLL, but PLL is not enabled * Select PLL, but PLL frequency is too high * Select High Speed External, but the frequency is kept at 0_Mhz. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/clock.hpp</code></p>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t/","title":"Struct hal::stm32f1::clock_tree::ahb_t","text":"<p>ClassList &gt; hal &gt; stm32f1 &gt; clock_tree &gt; ahb_t</p> <p>Defines the configuration of the dividers beyond system clock mux. </p> <ul> <li><code>#include &lt;clock.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t/#classes","title":"Classes","text":"Type Name struct apb1_t Maximum rate of 36 MHz. struct apb2_t"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t/#public-attributes","title":"Public Attributes","text":"Type Name struct hal::stm32f1::clock_tree::ahb_t::apb1_t apb1   = = {} struct hal::stm32f1::clock_tree::ahb_t::apb2_t apb2   = = {} ahb_divider divider   = = ahb_divider::divide_by_1"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t/#variable-apb1","title":"variable apb1","text":"<pre><code>struct hal::stm32f1::clock_tree::ahb_t::apb1_t hal::stm32f1::clock_tree::ahb_t::apb1;\n</code></pre>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t/#variable-apb2","title":"variable apb2","text":"<pre><code>struct hal::stm32f1::clock_tree::ahb_t::apb2_t hal::stm32f1::clock_tree::ahb_t::apb2;\n</code></pre>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t/#variable-divider","title":"variable divider","text":"<pre><code>ahb_divider hal::stm32f1::clock_tree::ahb_t::divider;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/clock.hpp</code></p>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb1__t/","title":"Struct hal::stm32f1::clock_tree::ahb_t::apb1_t","text":"<p>ClassList &gt; hal &gt; stm32f1 &gt; clock_tree &gt; ahb_t &gt; apb1_t</p> <p>Maximum rate of 36 MHz. </p> <ul> <li><code>#include &lt;clock.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb1__t/#public-attributes","title":"Public Attributes","text":"Type Name apb_divider divider   = = apb_divider::divide_by_1"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb1__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb1__t/#variable-divider","title":"variable divider","text":"<pre><code>apb_divider hal::stm32f1::clock_tree::ahb_t::apb1_t::divider;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/clock.hpp</code></p>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb2__t/","title":"Struct hal::stm32f1::clock_tree::ahb_t::apb2_t","text":"<p>ClassList &gt; hal &gt; stm32f1 &gt; clock_tree &gt; ahb_t &gt; apb2_t</p>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb2__t/#classes","title":"Classes","text":"Type Name struct adc_t"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb2__t/#public-attributes","title":"Public Attributes","text":"Type Name struct hal::stm32f1::clock_tree::ahb_t::apb2_t::adc_t adc   = = {} apb_divider divider   = = apb_divider::divide_by_1"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb2__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb2__t/#variable-adc","title":"variable adc","text":"<pre><code>struct hal::stm32f1::clock_tree::ahb_t::apb2_t::adc_t hal::stm32f1::clock_tree::ahb_t::apb2_t::adc;\n</code></pre>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb2__t/#variable-divider","title":"variable divider","text":"<pre><code>apb_divider hal::stm32f1::clock_tree::ahb_t::apb2_t::divider;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/clock.hpp</code></p>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb2__t_1_1adc__t/","title":"Struct hal::stm32f1::clock_tree::ahb_t::apb2_t::adc_t","text":"<p>ClassList &gt; hal &gt; stm32f1 &gt; clock_tree &gt; ahb_t &gt; apb2_t &gt; adc_t</p>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb2__t_1_1adc__t/#public-attributes","title":"Public Attributes","text":"Type Name adc_divider divider   = = adc_divider::divide_by_2Maximum of 14 MHz."},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb2__t_1_1adc__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1ahb__t_1_1apb2__t_1_1adc__t/#variable-divider","title":"variable divider","text":"<pre><code>adc_divider hal::stm32f1::clock_tree::ahb_t::apb2_t::adc_t::divider;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/clock.hpp</code></p>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1pll__t/","title":"Struct hal::stm32f1::clock_tree::pll_t","text":"<p>ClassList &gt; hal &gt; stm32f1 &gt; clock_tree &gt; pll_t</p> <p>Defines the configuration of the PLL. </p> <ul> <li><code>#include &lt;clock.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1pll__t/#classes","title":"Classes","text":"Type Name struct usb_divider_t"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1pll__t/#public-attributes","title":"Public Attributes","text":"Type Name bool enable   = = false pll_multiply multiply   = = pll_multiply::multiply_by_2 pll_source source   = = pll_source::high_speed_internal struct hal::stm32f1::clock_tree::pll_t::usb_divider_t usb   = = {}"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1pll__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1pll__t/#variable-enable","title":"variable enable","text":"<pre><code>bool hal::stm32f1::clock_tree::pll_t::enable;\n</code></pre>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1pll__t/#variable-multiply","title":"variable multiply","text":"<pre><code>pll_multiply hal::stm32f1::clock_tree::pll_t::multiply;\n</code></pre>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1pll__t/#variable-source","title":"variable source","text":"<pre><code>pll_source hal::stm32f1::clock_tree::pll_t::source;\n</code></pre>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1pll__t/#variable-usb","title":"variable usb","text":"<pre><code>struct hal::stm32f1::clock_tree::pll_t::usb_divider_t hal::stm32f1::clock_tree::pll_t::usb;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/clock.hpp</code></p>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1pll__t_1_1usb__divider__t/","title":"Struct hal::stm32f1::clock_tree::pll_t::usb_divider_t","text":"<p>ClassList &gt; hal &gt; stm32f1 &gt; clock_tree &gt; pll_t &gt; usb_divider_t</p>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1pll__t_1_1usb__divider__t/#public-attributes","title":"Public Attributes","text":"Type Name usb_divider divider   = = usb_divider::divide_by_1_point_5"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1pll__t_1_1usb__divider__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1pll__t_1_1usb__divider__t/#variable-divider","title":"variable divider","text":"<pre><code>usb_divider hal::stm32f1::clock_tree::pll_t::usb_divider_t::divider;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/clock.hpp</code></p>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1rtc__t/","title":"Struct hal::stm32f1::clock_tree::rtc_t","text":"<p>ClassList &gt; hal &gt; stm32f1 &gt; clock_tree &gt; rtc_t</p> <p>Defines the configuration for the RTC. </p> <ul> <li><code>#include &lt;clock.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1rtc__t/#public-attributes","title":"Public Attributes","text":"Type Name bool enable   = = false rtc_source source   = = rtc_source::low_speed_internal"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1rtc__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1rtc__t/#variable-enable","title":"variable enable","text":"<pre><code>bool hal::stm32f1::clock_tree::rtc_t::enable;\n</code></pre>"},{"location":"api/structhal_1_1stm32f1_1_1clock__tree_1_1rtc__t/#variable-source","title":"variable source","text":"<pre><code>rtc_source hal::stm32f1::clock_tree::rtc_t::source;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/clock.hpp</code></p>"},{"location":"api/classhal_1_1stm32f1_1_1output__pin/","title":"Class hal::stm32f1::output_pin","text":"<p>ClassList &gt; hal &gt; stm32f1 &gt; output_pin</p> <p>Output pin implementation for the stm32::f10x. </p> <ul> <li><code>#include &lt;output_pin.hpp&gt;</code></li> </ul> <p>Inherits the following classes: hal::output_pin</p>"},{"location":"api/classhal_1_1stm32f1_1_1output__pin/#public-functions-inherited-from-haloutput_pin","title":"Public Functions inherited from hal::output_pin","text":"<p>See hal::output_pin</p> Type Name status configure (const settings &amp; p_settings) Configure the output pin to match the settings supplied. result&lt; set_level_t &gt; level (bool p_high) Set the state of the pin. result&lt; level_t &gt; level () Read the current state of the output pin. virtual ~output_pin () = default"},{"location":"api/classhal_1_1stm32f1_1_1output__pin/#public-static-functions","title":"Public Static Functions","text":"Type Name result&lt; output_pin &gt; get (std::uint8_t p_port, std::uint8_t p_pin, output_pin::settings p_settings={}) Get the output pin object."},{"location":"api/classhal_1_1stm32f1_1_1output__pin/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"api/classhal_1_1stm32f1_1_1output__pin/#function-get","title":"function get","text":"<p>Get the output pin object. <pre><code>static result&lt; output_pin &gt; hal::stm32f1::output_pin::get (\n    std::uint8_t p_port,\n    std::uint8_t p_pin,\n    output_pin::settings p_settings={}\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_port</code> - selects pin port to use </li> <li><code>p_pin</code> - selects which pin within the port to use </li> <li><code>p_settings</code> - initial pin settings </li> </ul> <p>Returns:</p> <p>result&lt;output_pin&gt; - reference to the statically allocated output pin </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/output_pin.hpp</code></p>"},{"location":"api/classhal_1_1stream__fill/","title":"Class hal::stream_fill","text":"<p>ClassList &gt; hal &gt; stream_fill</p> <p>Non-blocking callable for reading serial data into a buffer. </p> <ul> <li><code>#include &lt;streams.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1stream__fill/#public-functions","title":"Public Functions","text":"Type Name work_state state ()  stream_fill (std::span&lt; hal::byte &gt; p_buffer) Construct a new fill object. stream_fill (std::span&lt; hal::byte &gt; p_buffer, const size_t &amp; p_fill_amount) Construct a new fill object."},{"location":"api/classhal_1_1stream__fill/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1stream__fill/#function-state","title":"function state","text":"<pre><code>work_state hal::stream_fill::state () \n</code></pre>"},{"location":"api/classhal_1_1stream__fill/#function-stream_fill-12","title":"function stream_fill [1/2]","text":"<p>Construct a new fill object. <pre><code>explicit hal::stream_fill::stream_fill (\n    std::span&lt; hal::byte &gt; p_buffer\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_buffer</code> - buffer to read data into </li> </ul>"},{"location":"api/classhal_1_1stream__fill/#function-stream_fill-22","title":"function stream_fill [2/2]","text":"<p>Construct a new fill object. <pre><code>hal::stream_fill::stream_fill (\n    std::span&lt; hal::byte &gt; p_buffer,\n    const size_t &amp; p_fill_amount\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_buffer</code> - buffer to read data into </li> <li><code>p_fill_amount</code> - reference to a size value to limit the fill amount by. <pre><code>## Friends Documentation\n</code></pre> </li> </ul>"},{"location":"api/classhal_1_1stream__fill/#friend-operator","title":"friend operator|","text":"<pre><code>std::span&lt; const hal::byte &gt; hal::stream_fill::operator| (\n    const std::span&lt; const hal::byte &gt; &amp; p_input_data,\n    stream_fill &amp; p_self\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/streams.hpp</code></p>"},{"location":"api/classhal_1_1stream__fill__upto/","title":"Class hal::stream_fill_upto","text":"<p>ClassList &gt; hal &gt; stream_fill_upto</p> <p>Discard received bytes until the sequence is found. </p> <ul> <li><code>#include &lt;streams.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1stream__fill__upto/#public-functions","title":"Public Functions","text":"Type Name std::span&lt; hal::byte &gt; span ()  work_state state ()  stream_fill_upto (std::span&lt; const hal::byte &gt; p_sequence, std::span&lt; hal::byte &gt; p_buffer) Construct a new fill upto object. std::span&lt; hal::byte &gt; unfilled ()"},{"location":"api/classhal_1_1stream__fill__upto/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1stream__fill__upto/#function-span","title":"function span","text":"<pre><code>std::span&lt; hal::byte &gt; hal::stream_fill_upto::span () \n</code></pre>"},{"location":"api/classhal_1_1stream__fill__upto/#function-state","title":"function state","text":"<pre><code>work_state hal::stream_fill_upto::state () \n</code></pre>"},{"location":"api/classhal_1_1stream__fill__upto/#function-stream_fill_upto","title":"function stream_fill_upto","text":"<p>Construct a new fill upto object. <pre><code>hal::stream_fill_upto::stream_fill_upto (\n    std::span&lt; const hal::byte &gt; p_sequence,\n    std::span&lt; hal::byte &gt; p_buffer\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_sequence</code> - sequence to search for. The lifetime of this data pointed to by this span must outlive this object, or not be used when the lifetime of that data is no longer available. </li> <li><code>p_buffer</code> - buffer to fill data into </li> </ul>"},{"location":"api/classhal_1_1stream__fill__upto/#function-unfilled","title":"function unfilled","text":"<pre><code>std::span&lt; hal::byte &gt; hal::stream_fill_upto::unfilled () \n</code></pre>"},{"location":"api/classhal_1_1stream__fill__upto/#friends-documentation","title":"Friends Documentation","text":""},{"location":"api/classhal_1_1stream__fill__upto/#friend-operator","title":"friend operator|","text":"<pre><code>std::span&lt; const hal::byte &gt; hal::stream_fill_upto::operator| (\n    const std::span&lt; const hal::byte &gt; &amp; p_input_data,\n    stream_fill_upto &amp; p_self\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/streams.hpp</code></p>"},{"location":"api/classhal_1_1stream__find/","title":"Class hal::stream_find","text":"<p>ClassList &gt; hal &gt; stream_find</p> <p>Discard received bytes until the sequence is found. </p> <ul> <li><code>#include &lt;streams.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1stream__find/#public-functions","title":"Public Functions","text":"Type Name work_state state ()  stream_find (std::span&lt; const hal::byte &gt; p_sequence) Construct a new find object."},{"location":"api/classhal_1_1stream__find/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1stream__find/#function-state","title":"function state","text":"<pre><code>work_state hal::stream_find::state () \n</code></pre>"},{"location":"api/classhal_1_1stream__find/#function-stream_find","title":"function stream_find","text":"<p>Construct a new find object. <pre><code>explicit hal::stream_find::stream_find (\n    std::span&lt; const hal::byte &gt; p_sequence\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>p_sequence</code> - sequence to search for. The lifetime of this data pointed to by this span must outlive this object, or not be used when the lifetime of that data is no longer available. <pre><code>## Friends Documentation\n</code></pre> </li> </ul>"},{"location":"api/classhal_1_1stream__find/#friend-operator","title":"friend operator|","text":"<pre><code>std::span&lt; const hal::byte &gt; hal::stream_find::operator| (\n    const std::span&lt; const hal::byte &gt; &amp; p_input_data,\n    stream_find &amp; p_self\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/streams.hpp</code></p>"},{"location":"api/classhal_1_1stream__parse/","title":"Class hal::stream_parse","text":"<p>template &lt;std::unsigned_integral T&gt;</p> <p>ClassList &gt; hal &gt; stream_parse</p> <p>Read bytes from stream and convert to integer. </p> <ul> <li><code>#include &lt;streams.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1stream__parse/#public-functions","title":"Public Functions","text":"Type Name work_state state ()  stream_parse () = defaultConstruct a new parse object. const T &amp; value ()"},{"location":"api/classhal_1_1stream__parse/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1stream__parse/#function-state","title":"function state","text":"<pre><code>inline work_state hal::stream_parse::state () \n</code></pre>"},{"location":"api/classhal_1_1stream__parse/#function-stream_parse","title":"function stream_parse","text":"<pre><code>explicit hal::stream_parse::stream_parse () = default\n</code></pre>"},{"location":"api/classhal_1_1stream__parse/#function-value","title":"function value","text":"<pre><code>inline const T &amp; hal::stream_parse::value () \n</code></pre> <p>Returns:</p> <p>T&amp; - return an immutable reference to the value </p> <pre><code>    ## Friends Documentation\n</code></pre>"},{"location":"api/classhal_1_1stream__parse/#friend-operator","title":"friend operator|","text":"<pre><code>inline std::span&lt; const hal::byte &gt; hal::stream_parse::operator| (\n    const std::span&lt; const hal::byte &gt; &amp; p_input_data,\n    stream_parse &amp; p_self\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/streams.hpp</code></p>"},{"location":"api/classhal_1_1stream__skip/","title":"Class hal::stream_skip","text":"<p>ClassList &gt; hal &gt; stream_skip</p> <p>Skip number of bytes in a byte stream. </p> <ul> <li><code>#include &lt;streams.hpp&gt;</code></li> </ul>"},{"location":"api/classhal_1_1stream__skip/#public-functions","title":"Public Functions","text":"Type Name work_state state ()  stream_skip (size_t p_skip) Construct a new skip object."},{"location":"api/classhal_1_1stream__skip/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1stream__skip/#function-state","title":"function state","text":"<pre><code>work_state hal::stream_skip::state () \n</code></pre>"},{"location":"api/classhal_1_1stream__skip/#function-stream_skip","title":"function stream_skip","text":"<pre><code>explicit hal::stream_skip::stream_skip (\n    size_t p_skip\n) \n</code></pre>"},{"location":"api/classhal_1_1stream__skip/#friends-documentation","title":"Friends Documentation","text":""},{"location":"api/classhal_1_1stream__skip/#friend-operator","title":"friend operator|","text":"<pre><code>std::span&lt; const hal::byte &gt; hal::stream_skip::operator| (\n    const std::span&lt; const hal::byte &gt; &amp; p_input_data,\n    stream_skip &amp; p_self\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/streams.hpp</code></p>"},{"location":"api/classhal_1_1temperature__sensor/","title":"Class hal::temperature_sensor","text":"<p>ClassList &gt; hal &gt; temperature_sensor</p> <p>Temperature sensing hardware abstraction interface. </p> <ul> <li><code>#include &lt;temperature_sensor.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::rmd::drc_temperature_sensor,  hal::rmd::mc_x_temperature,  hal::soft::inert_temperature_sensor</p>"},{"location":"api/classhal_1_1temperature__sensor/#classes","title":"Classes","text":"Type Name struct read_t Result from reading the temperature sensor."},{"location":"api/classhal_1_1temperature__sensor/#public-functions","title":"Public Functions","text":"Type Name result&lt; read_t &gt; read () Read the current temperature measured by the device. virtual ~temperature_sensor () = default"},{"location":"api/classhal_1_1temperature__sensor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1temperature__sensor/#function-read","title":"function read","text":"<p>Read the current temperature measured by the device. <pre><code>inline result&lt; read_t &gt; hal::temperature_sensor::read () \n</code></pre></p> <p>Returns:</p> <p>result&lt;read_t&gt; - temperature data </p>"},{"location":"api/classhal_1_1temperature__sensor/#function-temperature_sensor","title":"function ~temperature_sensor","text":"<pre><code>virtual hal::temperature_sensor::~temperature_sensor () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/temperature_sensor.hpp</code></p>"},{"location":"api/structhal_1_1temperature__sensor_1_1read__t/","title":"Struct hal::temperature_sensor::read_t","text":"<p>ClassList &gt; hal &gt; temperature_sensor &gt; read_t</p> <p>Result from reading the temperature sensor. </p> <ul> <li><code>#include &lt;temperature_sensor.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1temperature__sensor_1_1read__t/#public-attributes","title":"Public Attributes","text":"Type Name celsius temperature Measured temperature."},{"location":"api/structhal_1_1temperature__sensor_1_1read__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1temperature__sensor_1_1read__t/#variable-temperature","title":"variable temperature","text":"<pre><code>celsius hal::temperature_sensor::read_t::temperature;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/temperature_sensor.hpp</code></p>"},{"location":"api/classhal_1_1timer/","title":"Class hal::timer","text":"<p>ClassList &gt; hal &gt; timer</p> <p>Timer hardware abstraction interface. More...</p> <ul> <li><code>#include &lt;timer.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: hal::cortex_m::systick_timer,  hal::mock::timer,  hal::soft::inert_timer</p>"},{"location":"api/classhal_1_1timer/#classes","title":"Classes","text":"Type Name struct cancel_t Feedback from cancelling a timer. struct is_running_t Feedback after checking if the timer is running. struct out_of_bounds_error Error type indicating that the desired time delay is not achievable with this timer. struct schedule_t Feedback from scheduling a timer."},{"location":"api/classhal_1_1timer/#public-functions","title":"Public Functions","text":"Type Name result&lt; cancel_t &gt; cancel () Stops a scheduled event from happening. result&lt; is_running_t &gt; is_running () Determine if the timer is currently running. result&lt; schedule_t &gt; schedule (hal::callback&lt; void(void)&gt; p_callback, hal::time_duration p_delay) Schedule an callback be be executed after the delay time. virtual ~timer () = default"},{"location":"api/classhal_1_1timer/#detailed-description","title":"Detailed Description","text":"<p>Use this interface for devices and peripherals that have timer like capabilities, such that, when a timer's time has expired, an event, interrupt, or signal is generated.</p> <p>Timer drivers tick period must be an integer multiple of 1 nanosecond, meaning that the only tick period allowed are 1ns, 2ns, up to the maximum holdable in a std::chrono::nanosecond type. sub-nanosecond tick periods are not allowed. </p>"},{"location":"api/classhal_1_1timer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1timer/#function-cancel","title":"function cancel","text":"<p>Stops a scheduled event from happening. <pre><code>inline result&lt; cancel_t &gt; hal::timer::cancel () \n</code></pre></p> <p>Does nothing if the timer is not currently running.</p> <p>Note that there must be sufficient time between the this call finishing and the scheduled event's termination. If this call is too close to when the schedule event expires, this function may not complete before the hardware calls the callback.</p> <p>Returns:</p> <p>result&lt;cancel_t&gt; - success or failure </p>"},{"location":"api/classhal_1_1timer/#function-is_running","title":"function is_running","text":"<p>Determine if the timer is currently running. <pre><code>inline result&lt; is_running_t &gt; hal::timer::is_running () \n</code></pre></p> <p>Returns:</p> <p>result&lt;is_running_t&gt; - information about the timer </p>"},{"location":"api/classhal_1_1timer/#function-schedule","title":"function schedule","text":"<p>Schedule an callback be be executed after the delay time. <pre><code>inline result&lt; schedule_t &gt; hal::timer::schedule (\n    hal::callback &lt; void(void)&gt; p_callback,\n    hal::time_duration p_delay\n) \n</code></pre></p> <p>If this is called and the timer has already scheduled an event (in other words, <code>is_running()</code> returns true), then the previous scheduled event will be canceled and the new scheduled event will be started.</p> <p>If the delay time result in a tick period of 0, then the timer will execute after 1 tick period. For example, if the tick period is 1ms and the requested time delay is 500us, then the event will be scheduled for 1ms.</p> <p>If the tick period is 1ms and the requested time is 2.5ms then the event will be scheduled after 2 tick periods or in 2ms.</p> <p>Parameters:</p> <ul> <li><code>p_callback</code> - callback function to be called when the timer expires </li> <li><code>p_delay</code> - the amount of time until the timer expires </li> </ul> <p>Returns:</p> <p>result&lt;schedule_t&gt; - success or failure </p> <p>Exception:</p> <ul> <li>out_of_bounds_error - if p_interval is greater than what can be cannot be achieved </li> </ul>"},{"location":"api/classhal_1_1timer/#function-timer","title":"function ~timer","text":"<pre><code>virtual hal::timer::~timer () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/timer.hpp</code></p>"},{"location":"api/structhal_1_1timer_1_1cancel__t/","title":"Struct hal::timer::cancel_t","text":"<p>ClassList &gt; hal &gt; timer &gt; cancel_t</p> <p>Feedback from cancelling a timer. More...</p> <ul> <li><code>#include &lt;timer.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1timer_1_1cancel__t/#detailed-description","title":"Detailed Description","text":"<p>This structure is currently empty as no feedback has been determined for now. This structure may be expanded in the future. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/timer.hpp</code></p>"},{"location":"api/structhal_1_1timer_1_1is__running__t/","title":"Struct hal::timer::is_running_t","text":"<p>ClassList &gt; hal &gt; timer &gt; is_running_t</p> <p>Feedback after checking if the timer is running. </p> <ul> <li><code>#include &lt;timer.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1timer_1_1is__running__t/#public-attributes","title":"Public Attributes","text":"Type Name bool is_running Determines if the timer is currently running."},{"location":"api/structhal_1_1timer_1_1is__running__t/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1timer_1_1is__running__t/#variable-is_running","title":"variable is_running","text":"<p>Determines if the timer is currently running. <pre><code>bool hal::timer::is_running_t::is_running;\n</code></pre></p> <p>If this value is false, then the timer is not running. If this value is true, then the timer is currently running and a callback is scheduled to be executed at some point in the future. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/timer.hpp</code></p>"},{"location":"api/structhal_1_1timer_1_1out__of__bounds__error/","title":"Struct hal::timer::out_of_bounds_error","text":"<p>ClassList &gt; hal &gt; timer &gt; out_of_bounds_error</p> <p>Error type indicating that the desired time delay is not achievable with this timer. More...</p> <ul> <li><code>#include &lt;timer.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1timer_1_1out__of__bounds__error/#public-attributes","title":"Public Attributes","text":"Type Name std::chrono::nanoseconds maximum The maximum possible delay allowed. std::chrono::nanoseconds tick_period The tick period."},{"location":"api/structhal_1_1timer_1_1out__of__bounds__error/#detailed-description","title":"Detailed Description","text":"<p>This occurs if the time delay is too large based on the tick period of the timer. </p>"},{"location":"api/structhal_1_1timer_1_1out__of__bounds__error/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1timer_1_1out__of__bounds__error/#variable-maximum","title":"variable maximum","text":"<pre><code>std::chrono::nanoseconds hal::timer::out_of_bounds_error::maximum;\n</code></pre>"},{"location":"api/structhal_1_1timer_1_1out__of__bounds__error/#variable-tick_period","title":"variable tick_period","text":"<pre><code>std::chrono::nanoseconds hal::timer::out_of_bounds_error::tick_period;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/timer.hpp</code></p>"},{"location":"api/structhal_1_1timer_1_1schedule__t/","title":"Struct hal::timer::schedule_t","text":"<p>ClassList &gt; hal &gt; timer &gt; schedule_t</p> <p>Feedback from scheduling a timer. More...</p> <ul> <li><code>#include &lt;timer.hpp&gt;</code></li> </ul>"},{"location":"api/structhal_1_1timer_1_1schedule__t/#detailed-description","title":"Detailed Description","text":"<p>This structure is currently empty as no feedback has been determined for now. This structure may be expanded in the future. </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/timer.hpp</code></p>"},{"location":"api/classhal_1_1esp8266_1_1at_1_1packet__manager/","title":"Class hal::esp8266::at::packet_manager","text":"<p>ClassList &gt; packet_manager</p>"},{"location":"api/classhal_1_1esp8266_1_1at_1_1packet__manager/#public-functions","title":"Public Functions","text":"Type Name void find (hal::serial &amp; p_serial)  bool is_complete_header ()  std::uint16_t packet_length ()  packet_manager ()  hal::result&lt; std::span&lt; hal::byte &gt; &gt; read_packet (hal::serial &amp; p_serial, std::span&lt; hal::byte &gt; p_buffer)  void reset ()  void set_state (std::uint8_t p_state)"},{"location":"api/classhal_1_1esp8266_1_1at_1_1packet__manager/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/classhal_1_1esp8266_1_1at_1_1packet__manager/#function-find","title":"function find","text":"<pre><code>void packet_manager::find (\n    hal::serial &amp; p_serial\n) \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at_1_1packet__manager/#function-is_complete_header","title":"function is_complete_header","text":"<pre><code>bool packet_manager::is_complete_header () \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at_1_1packet__manager/#function-packet_length","title":"function packet_length","text":"<pre><code>std::uint16_t packet_manager::packet_length () \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at_1_1packet__manager/#function-packet_manager","title":"function packet_manager","text":"<pre><code>packet_manager::packet_manager () \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at_1_1packet__manager/#function-read_packet","title":"function read_packet","text":"<pre><code>hal::result&lt; std::span&lt; hal::byte &gt; &gt; packet_manager::read_packet (\n    hal::serial &amp; p_serial,\n    std::span&lt; hal::byte &gt; p_buffer\n) \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at_1_1packet__manager/#function-reset","title":"function reset","text":"<pre><code>void packet_manager::reset () \n</code></pre>"},{"location":"api/classhal_1_1esp8266_1_1at_1_1packet__manager/#function-set_state","title":"function set_state","text":"<pre><code>void packet_manager::set_state (\n    std::uint8_t p_state\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-esp8266/at.hpp</code></p>"},{"location":"api/structhal_1_1soft_1_1rc__servo_1_1ranges/","title":"Struct hal::soft::rc_servo::ranges","text":"<p>ClassList &gt; ranges</p>"},{"location":"api/structhal_1_1soft_1_1rc__servo_1_1ranges/#public-attributes","title":"Public Attributes","text":"Type Name std::pair&lt; float, float &gt; angle std::pair&lt; float, float &gt; percent"},{"location":"api/structhal_1_1soft_1_1rc__servo_1_1ranges/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/structhal_1_1soft_1_1rc__servo_1_1ranges/#variable-angle","title":"variable angle","text":"<pre><code>std::pair&lt;float, float&gt; hal::soft::rc_servo::ranges::angle;\n</code></pre>"},{"location":"api/structhal_1_1soft_1_1rc__servo_1_1ranges/#variable-percent","title":"variable percent","text":"<pre><code>std::pair&lt;float, float&gt; hal::soft::rc_servo::ranges::percent;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/rc_servo.hpp</code></p>"},{"location":"api/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"api/dir_bc0718b08fb2015b8e59c47b2805f60c/","title":"Dir libraries","text":"<p>FileList &gt; libraries</p>"},{"location":"api/dir_bc0718b08fb2015b8e59c47b2805f60c/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>libraries/</code></p>"},{"location":"api/dir_cba0faac6e93618a6e2539705915bd70/","title":"Dir libraries/include","text":"<p>FileList &gt; include</p>"},{"location":"api/dir_cba0faac6e93618a6e2539705915bd70/#directories","title":"Directories","text":"Type Name dir libhal dir libhal-armcortex dir libhal-canrouter dir libhal-esp8266 dir libhal-lpc40 dir libhal-micromod dir libhal-mock dir libhal-mpl dir libhal-rmd dir libhal-soft dir libhal-stm32f1 dir libhal-util <p>The documentation for this class was generated from the following file <code>libraries/include/</code></p>"},{"location":"api/dir_c21661262b37aa135a14febc024e67d7/","title":"Dir libraries/include/libhal","text":"<p>FileList &gt; include &gt; libhal</p>"},{"location":"api/dir_c21661262b37aa135a14febc024e67d7/#files","title":"Files","text":"Type Name file accelerometer.hpp file adc.hpp file can.hpp file dac.hpp file distance_sensor.hpp file error.hpp file functional.hpp file gyroscope.hpp file i2c.hpp file input_pin.hpp file interrupt_pin.hpp file magnetometer.hpp file motor.hpp file output_pin.hpp file pwm.hpp file rotation_sensor.hpp file serial.hpp file servo.hpp file spi.hpp file steady_clock.hpp file temperature_sensor.hpp file timeout.hpp Provides the hal::timeout type and utility functions that use that type. file timer.hpp file units.hpp <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/</code></p>"},{"location":"api/accelerometer_8hpp/","title":"File accelerometer.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; accelerometer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/accelerometer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/accelerometer_8hpp/#classes","title":"Classes","text":"Type Name class accelerometer Acceleration sensing hardware abstraction interface. struct read_t Result from reading the accelerometer. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/accelerometer.hpp</code></p>"},{"location":"api/accelerometer_8hpp_source/","title":"File accelerometer.hpp","text":"<p>File List &gt; include &gt; libhal &gt; accelerometer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"error.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass accelerometer\n{\npublic:\n  struct read_t\n  {\n    g_force x;\n    g_force y;\n    g_force z;\n  };\n\n  [[nodiscard]] result&lt;read_t&gt; read()\n  {\n    return driver_read();\n  }\n\n  virtual ~accelerometer() = default;\n\nprivate:\n  virtual result&lt;read_t&gt; driver_read() = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2adc_8hpp/","title":"File adc.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; adc.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error.hpp\"</code></li> </ul>"},{"location":"api/libhal_2adc_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal_2adc_8hpp/#classes","title":"Classes","text":"Type Name class adc Analog to Digital Converter (ADC) hardware abstraction interface. struct read_t Result from reading the adc. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/adc.hpp</code></p>"},{"location":"api/libhal_2adc_8hpp_source/","title":"File adc.hpp","text":"<p>File List &gt; include &gt; libhal &gt; adc.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"error.hpp\"\n\nnamespace hal {\nclass adc\n{\npublic:\n  struct read_t\n  {\n    float sample;\n  };\n\n  [[nodiscard]] result&lt;read_t&gt; read()\n  {\n    return driver_read();\n  }\n\n  virtual ~adc() = default;\n\nprivate:\n  virtual result&lt;read_t&gt; driver_read() = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2can_8hpp/","title":"File can.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; can.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"functional.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/libhal_2can_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal_2can_8hpp/#classes","title":"Classes","text":"Type Name class can Controller Area Network (CAN bus) hardware abstraction interface. struct message_t A CAN message. struct send_t Feedback from sending data over the CAN BUS. struct settings Generic settings for a can peripheral. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/can.hpp</code></p>"},{"location":"api/libhal_2can_8hpp_source/","title":"File can.hpp","text":"<p>File List &gt; include &gt; libhal &gt; can.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;array&gt;\n#include &lt;cstdint&gt;\n\n#include \"error.hpp\"\n#include \"functional.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass can\n{\npublic:\n  using id_t = uint32_t;\n\n  struct settings\n  {\n    hertz baud_rate = 100.0_kHz;\n\n    static constexpr std::uint8_t sync_segment = 1;\n\n    std::uint8_t propagation_delay = 3;\n\n    std::uint8_t phase_segment1 = 3;\n\n    std::uint8_t phase_segment2 = 3;\n\n    std::uint8_t synchronization_jump_width = 1;\n  };\n\n  struct message_t\n  {\n    id_t id;\n    std::array&lt;hal::byte, 8&gt; payload{};\n    uint8_t length = 0;\n    bool is_remote_request = false;\n  };\n\n  using handler = void(const message_t&amp; p_message);\n\n  struct send_t\n  {};\n\n  [[nodiscard]] status configure(const settings&amp; p_settings)\n  {\n    return driver_configure(p_settings);\n  }\n\n  [[nodiscard]] status bus_on()\n  {\n    return driver_bus_on();\n  }\n\n  [[nodiscard]] result&lt;send_t&gt; send(const message_t&amp; p_message)\n  {\n    return driver_send(p_message);\n  }\n\n  void on_receive(hal::callback&lt;handler&gt; p_handler)\n  {\n    return driver_on_receive(p_handler);\n  }\n\n  virtual ~can() = default;\n\nprivate:\n  virtual status driver_configure(const settings&amp; p_settings) = 0;\n  virtual status driver_bus_on() = 0;\n  virtual result&lt;send_t&gt; driver_send(const message_t&amp; p_message) = 0;\n  virtual void driver_on_receive(hal::callback&lt;handler&gt; p_handler) = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2dac_8hpp/","title":"File dac.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; dac.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include \"error.hpp\"</code></li> </ul>"},{"location":"api/libhal_2dac_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal_2dac_8hpp/#classes","title":"Classes","text":"Type Name class dac Digital to Analog Converter (DAC) hardware abstraction interface. struct write_t Feedback from writing a voltage to the dac. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/dac.hpp</code></p>"},{"location":"api/libhal_2dac_8hpp_source/","title":"File dac.hpp","text":"<p>File List &gt; include &gt; libhal &gt; dac.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include \"error.hpp\"\n\nnamespace hal {\nclass dac\n{\npublic:\n  struct write_t\n  {};\n\n  [[nodiscard]] result&lt;write_t&gt; write(float p_percentage)\n  {\n    auto clamped_percentage = std::clamp(p_percentage, 0.0f, 1.0f);\n    return driver_write(clamped_percentage);\n  }\n\n  virtual ~dac() = default;\n\nprivate:\n  virtual result&lt;write_t&gt; driver_write(float p_percentage) = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/distance__sensor_8hpp/","title":"File distance_sensor.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; distance_sensor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/distance__sensor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/distance__sensor_8hpp/#classes","title":"Classes","text":"Type Name class distance_sensor Linear distance hardware abstraction interface. struct read_t Result from sampling the distance sensor. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/distance_sensor.hpp</code></p>"},{"location":"api/distance__sensor_8hpp_source/","title":"File distance_sensor.hpp","text":"<p>File List &gt; include &gt; libhal &gt; distance_sensor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"error.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass distance_sensor\n{\npublic:\n  struct read_t\n  {\n    meters distance;\n  };\n\n  [[nodiscard]] result&lt;read_t&gt; read()\n  {\n    return driver_read();\n  }\n\n  virtual ~distance_sensor() = default;\n\nprivate:\n  virtual result&lt;read_t&gt; driver_read() = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/error_8hpp/","title":"File error.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; error.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;system_error&gt;</code></li> <li><code>#include &lt;boost/leaf/detail/all.hpp&gt;</code></li> </ul>"},{"location":"api/error_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace error Error objects, templates, and constants."},{"location":"api/error_8hpp/#classes","title":"Classes","text":"Type Name struct invalid_option_t &lt;options&gt;Used for defining static_asserts that should always fail, but only if the static_assert line is hit via <code>if constexpr</code> control block. Prefer to NOT use this directly but to use<code>invalid_option</code> instead."},{"location":"api/error_8hpp/#macros","title":"Macros","text":"Type Name define HAL_CHECK  BOOST_LEAF_CHECK"},{"location":"api/error_8hpp/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"api/error_8hpp/#define-hal_check","title":"define HAL_CHECK","text":"<pre><code>#define HAL_CHECK BOOST_LEAF_CHECK\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/error.hpp</code></p>"},{"location":"api/error_8hpp_source/","title":"File error.hpp","text":"<p>File List &gt; include &gt; libhal &gt; error.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;system_error&gt;\n\n#include &lt;boost/leaf/detail/all.hpp&gt;\n\n#define HAL_CHECK BOOST_LEAF_CHECK\n\nnamespace hal {\n\ntemplate&lt;typename T, T... value&gt;\nusing match = boost::leaf::match&lt;T, value...&gt;;\ntemplate&lt;class T&gt;\nusing result = boost::leaf::result&lt;T&gt;;\nusing status = result&lt;void&gt;;\nusing error_handler = void(void);\n\ninline error_handler* on_error_callback = nullptr;\n\ninline status success()\n{\n  // Default initialize the status object using the brace initialization, which\n  // will set the status to the default \"success\" state.\n  status successful_status{};\n  return successful_status;\n}\n\ntemplate&lt;class TryBlock, class... H&gt;\n[[nodiscard]] constexpr auto attempt(TryBlock&amp;&amp; p_try_block, H&amp;&amp;... p_handlers)\n{\n  return boost::leaf::try_handle_some(p_try_block, p_handlers...);\n}\n\ntemplate&lt;class TryBlock, class... H&gt;\n[[nodiscard]] constexpr auto attempt_all(TryBlock&amp;&amp; p_try_block,\n                                         H&amp;&amp;... p_handlers)\n{\n  return boost::leaf::try_handle_all(p_try_block, p_handlers...);\n}\n\ntemplate&lt;class... Item&gt;\n[[nodiscard]] inline auto new_error(Item&amp;&amp;... p_item)\n{\n  if (on_error_callback) {\n    on_error_callback();\n  }\n\n  return boost::leaf::new_error(std::forward&lt;Item&gt;(p_item)...);\n}\n\n[[noreturn]] inline void halt()\n{\n  while (true) {\n    continue;\n  }\n}\n\nnamespace error {\ntemplate&lt;auto... options&gt;\nstruct invalid_option_t : std::false_type\n{};\ntemplate&lt;auto... options&gt;\ninline constexpr bool invalid_option = invalid_option_t&lt;options...&gt;::value;\n}  // namespace error\n}  // namespace hal\n</code></pre>"},{"location":"api/functional_8hpp/","title":"File functional.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; functional.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include \"third_party/inplace_function.hpp\"</code></li> <li><code>#include &lt;tl/function_ref.hpp&gt;</code></li> </ul>"},{"location":"api/functional_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/functional.hpp</code></p>"},{"location":"api/functional_8hpp_source/","title":"File functional.hpp","text":"<p>File List &gt; include &gt; libhal &gt; functional.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include \"third_party/inplace_function.hpp\"\n#include &lt;tl/function_ref.hpp&gt;\n\nnamespace hal {\ntemplate&lt;typename F&gt;\nusing function_ref = tl::function_ref&lt;F&gt;;\n\ntemplate&lt;typename F, size_t Capacity&gt;\nusing inplace_function = stdext::inplace_function&lt;F, Capacity&gt;;\n\ntemplate&lt;typename F&gt;\nusing callback = inplace_function&lt;F, sizeof(std::intptr_t) * 2&gt;;\n}  // namespace hal\n</code></pre>"},{"location":"api/gyroscope_8hpp/","title":"File gyroscope.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; gyroscope.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/gyroscope_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/gyroscope_8hpp/#classes","title":"Classes","text":"Type Name class gyroscope Angular velocity sensing hardware abstraction interface. struct read_t Result from reading the gyroscope. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/gyroscope.hpp</code></p>"},{"location":"api/gyroscope_8hpp_source/","title":"File gyroscope.hpp","text":"<p>File List &gt; include &gt; libhal &gt; gyroscope.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"error.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass gyroscope\n{\npublic:\n  struct read_t\n  {\n    rpm x;\n    rpm y;\n    rpm z;\n  };\n\n  [[nodiscard]] result&lt;read_t&gt; read()\n  {\n    return driver_read();\n  }\n\n  virtual ~gyroscope() = default;\n\nprivate:\n  virtual result&lt;read_t&gt; driver_read() = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2i2c_8hpp/","title":"File i2c.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; i2c.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;span&gt;</code></li> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"functional.hpp\"</code></li> <li><code>#include \"timeout.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/libhal_2i2c_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal_2i2c_8hpp/#classes","title":"Classes","text":"Type Name class i2c Inter-integrated Circuit (I2C) hardware abstract interface. struct settings Generic settings for a standard I2C device. struct transaction_t Feedback from performing a transaction on the i2c bus. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/i2c.hpp</code></p>"},{"location":"api/libhal_2i2c_8hpp_source/","title":"File i2c.hpp","text":"<p>File List &gt; include &gt; libhal &gt; i2c.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;span&gt;\n\n#include \"error.hpp\"\n#include \"functional.hpp\"\n#include \"timeout.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass i2c\n{\npublic:\n  struct settings\n  {\n    hertz clock_rate = 100.0_kHz;\n  };\n\n  struct transaction_t\n  {};\n\n  [[nodiscard]] status configure(const settings&amp; p_settings)\n  {\n    return driver_configure(p_settings);\n  }\n\n  [[nodiscard]] result&lt;transaction_t&gt; transaction(\n    hal::byte p_address,\n    std::span&lt;const hal::byte&gt; p_data_out,\n    std::span&lt;hal::byte&gt; p_data_in,\n    hal::function_ref&lt;hal::timeout_function&gt; p_timeout)\n  {\n    return driver_transaction(p_address, p_data_out, p_data_in, p_timeout);\n  }\n\n  virtual ~i2c() = default;\n\nprivate:\n  virtual status driver_configure(const settings&amp; p_settings) = 0;\n  virtual result&lt;transaction_t&gt; driver_transaction(\n    hal::byte p_address,\n    std::span&lt;const hal::byte&gt; p_data_out,\n    std::span&lt;hal::byte&gt; p_data_in,\n    hal::function_ref&lt;hal::timeout_function&gt; p_timeout) = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2input__pin_8hpp/","title":"File input_pin.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; input_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/libhal_2input__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal_2input__pin_8hpp/#classes","title":"Classes","text":"Type Name class input_pin Digital input pin hardware abstraction interface. struct level_t Input pin level reading structure. struct settings Generic settings for input pins. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/input_pin.hpp</code></p>"},{"location":"api/libhal_2input__pin_8hpp_source/","title":"File input_pin.hpp","text":"<p>File List &gt; include &gt; libhal &gt; input_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"error.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass input_pin\n{\npublic:\n  struct settings\n  {\n    pin_resistor resistor = pin_resistor::pull_up;\n  };\n\n  struct level_t\n  {\n    bool state;\n  };\n\n  [[nodiscard]] status configure(const settings&amp; p_settings)\n  {\n    return driver_configure(p_settings);\n  }\n\n  [[nodiscard]] result&lt;level_t&gt; level()\n  {\n    return driver_level();\n  }\n\n  virtual ~input_pin() = default;\n\nprivate:\n  virtual status driver_configure(const settings&amp; p_settings) = 0;\n  virtual result&lt;level_t&gt; driver_level() = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2interrupt__pin_8hpp/","title":"File interrupt_pin.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; interrupt_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"functional.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/libhal_2interrupt__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal_2interrupt__pin_8hpp/#classes","title":"Classes","text":"Type Name class interrupt_pin Digital interrupt pin hardware abstraction. struct settings Generic settings for interrupt pins. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/interrupt_pin.hpp</code></p>"},{"location":"api/libhal_2interrupt__pin_8hpp_source/","title":"File interrupt_pin.hpp","text":"<p>File List &gt; include &gt; libhal &gt; interrupt_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"error.hpp\"\n#include \"functional.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass interrupt_pin\n{\npublic:\n  enum class trigger_edge\n  {\n    falling = 0,\n    rising = 1,\n    both = 2,\n  };\n\n  struct settings\n  {\n    pin_resistor resistor = pin_resistor::pull_up;\n\n    trigger_edge trigger = trigger_edge::rising;\n  };\n\n  using handler = void(bool p_state);\n\n  [[nodiscard]] status configure(const settings&amp; p_settings)\n  {\n    return driver_configure(p_settings);\n  }\n\n  void on_trigger(hal::callback&lt;handler&gt; p_callback)\n  {\n    return driver_on_trigger(p_callback);\n  }\n\n  virtual ~interrupt_pin() = default;\n\nprivate:\n  virtual status driver_configure(const settings&amp; p_settings) = 0;\n  virtual void driver_on_trigger(hal::callback&lt;handler&gt; p_callback) = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/magnetometer_8hpp/","title":"File magnetometer.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; magnetometer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/magnetometer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/magnetometer_8hpp/#classes","title":"Classes","text":"Type Name class magnetometer Magnetic field strength sensing hardware abstraction interface. struct read_t Result from reading the accelerometer. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/magnetometer.hpp</code></p>"},{"location":"api/magnetometer_8hpp_source/","title":"File magnetometer.hpp","text":"<p>File List &gt; include &gt; libhal &gt; magnetometer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"error.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass magnetometer\n{\npublic:\n  struct read_t\n  {\n    gauss x;\n\n    gauss y;\n\n    gauss z;\n  };\n\n  [[nodiscard]] result&lt;read_t&gt; read()\n  {\n    return driver_read();\n  }\n\n  virtual ~magnetometer() = default;\n\nprivate:\n  virtual result&lt;read_t&gt; driver_read() = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2motor_8hpp/","title":"File motor.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; motor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error.hpp\"</code></li> </ul>"},{"location":"api/libhal_2motor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal_2motor_8hpp/#classes","title":"Classes","text":"Type Name class motor Hardware abstraction for an open loop rotational actuator. struct power_t Feedback from setting the motor power. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/motor.hpp</code></p>"},{"location":"api/libhal_2motor_8hpp_source/","title":"File motor.hpp","text":"<p>File List &gt; include &gt; libhal &gt; motor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"error.hpp\"\n\nnamespace hal {\nclass motor\n{\npublic:\n  struct power_t\n  {};\n\n  [[nodiscard]] result&lt;power_t&gt; power(float p_power)\n  {\n    auto clamped_power = std::clamp(p_power, -1.0f, +1.0f);\n    return driver_power(clamped_power);\n  }\n\n  virtual ~motor() = default;\n\nprivate:\n  virtual result&lt;power_t&gt; driver_power(float p_power) = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2output__pin_8hpp/","title":"File output_pin.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; output_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/libhal_2output__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal_2output__pin_8hpp/#classes","title":"Classes","text":"Type Name class output_pin Digital output pin hardware abstraction. struct level_t Pin level reading structure. struct set_level_t Feedback from setting the pin state. struct settings Generic settings for output pins. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/output_pin.hpp</code></p>"},{"location":"api/libhal_2output__pin_8hpp_source/","title":"File output_pin.hpp","text":"<p>File List &gt; include &gt; libhal &gt; output_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"error.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass output_pin\n{\npublic:\n  struct settings\n  {\n    pin_resistor resistor = pin_resistor::none;\n\n    bool open_drain = false;\n  };\n\n  struct set_level_t\n  {};\n\n  struct level_t\n  {\n    bool state;\n  };\n\n  [[nodiscard]] status configure(const settings&amp; p_settings)\n  {\n    return driver_configure(p_settings);\n  }\n\n  [[nodiscard]] result&lt;set_level_t&gt; level(bool p_high)\n  {\n    return driver_level(p_high);\n  }\n\n  [[nodiscard]] result&lt;level_t&gt; level()\n  {\n    return driver_level();\n  }\n\n  virtual ~output_pin() = default;\n\nprivate:\n  virtual status driver_configure(const settings&amp; p_settings) = 0;\n  virtual result&lt;set_level_t&gt; driver_level(bool p_high) = 0;\n  virtual result&lt;level_t&gt; driver_level() = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2pwm_8hpp/","title":"File pwm.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; pwm.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/libhal_2pwm_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal_2pwm_8hpp/#classes","title":"Classes","text":"Type Name class pwm Pulse Width Modulation (PWM) channel hardware abstraction. struct duty_cycle_t Feedback setting the pwm duty cycle. struct frequency_t Feedback setting the pwm frequency. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/pwm.hpp</code></p>"},{"location":"api/libhal_2pwm_8hpp_source/","title":"File pwm.hpp","text":"<p>File List &gt; include &gt; libhal &gt; pwm.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;cstdint&gt;\n\n#include \"error.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass pwm\n{\npublic:\n  struct duty_cycle_t\n  {};\n\n  struct frequency_t\n  {};\n\n  [[nodiscard]] result&lt;frequency_t&gt; frequency(hertz p_frequency)\n  {\n    auto clamped_frequency = std::clamp(p_frequency, 1.0_Hz, 1.0_GHz);\n    return driver_frequency(clamped_frequency);\n  }\n\n  [[nodiscard]] result&lt;duty_cycle_t&gt; duty_cycle(float p_duty_cycle)\n  {\n    auto clamped_duty_cycle = std::clamp(p_duty_cycle, 0.0f, 1.0f);\n    return driver_duty_cycle(clamped_duty_cycle);\n  }\n\n  virtual ~pwm() = default;\n\nprivate:\n  virtual result&lt;frequency_t&gt; driver_frequency(hertz p_frequency) = 0;\n  virtual result&lt;duty_cycle_t&gt; driver_duty_cycle(float p_duty_cycle) = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/rotation__sensor_8hpp/","title":"File rotation_sensor.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; rotation_sensor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/rotation__sensor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/rotation__sensor_8hpp/#classes","title":"Classes","text":"Type Name class rotation_sensor Rotation measuring hardware abstraction interface. struct read_t Result from reading the rotation sensor. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/rotation_sensor.hpp</code></p>"},{"location":"api/rotation__sensor_8hpp_source/","title":"File rotation_sensor.hpp","text":"<p>File List &gt; include &gt; libhal &gt; rotation_sensor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"error.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass rotation_sensor\n{\npublic:\n  struct read_t\n  {\n    degrees angle;\n  };\n\n  [[nodiscard]] result&lt;read_t&gt; read()\n  {\n    return driver_read();\n  }\n\n  virtual ~rotation_sensor() = default;\n\nprivate:\n  virtual result&lt;read_t&gt; driver_read() = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2serial_8hpp/","title":"File serial.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; serial.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/libhal_2serial_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal_2serial_8hpp/#classes","title":"Classes","text":"Type Name class serial Hardware abstract interface for the serial communication protocol. struct flush_t Feedback from performing a flush operation. struct read_t Return type for serial read operations. struct settings Generic settings for a standard serial device. struct write_t Return type for serial write operations. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/serial.hpp</code></p>"},{"location":"api/libhal_2serial_8hpp_source/","title":"File serial.hpp","text":"<p>File List &gt; include &gt; libhal &gt; serial.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;optional&gt;\n#include &lt;span&gt;\n\n#include \"error.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass serial\n{\npublic:\n  struct settings\n  {\n    enum class stop_bits : uint8_t\n    {\n      one = 0,\n      two,\n    };\n\n    enum class parity : uint8_t\n    {\n      none = 0,\n      odd,\n      even,\n      forced1,\n      forced0,\n    };\n\n    hertz baud_rate = 115200.0f;\n\n    stop_bits stop = stop_bits::one;\n\n    parity parity = parity::none;\n  };\n  struct read_t\n  {\n    std::span&lt;hal::byte&gt; data;\n\n    size_t available;\n\n    size_t capacity;\n  };\n\n  struct write_t\n  {\n    std::span&lt;const hal::byte&gt; data;\n  };\n\n  struct flush_t\n  {};\n\n  [[nodiscard]] status configure(const settings&amp; p_settings)\n  {\n    return driver_configure(p_settings);\n  }\n\n  [[nodiscard]] result&lt;write_t&gt; write(std::span&lt;const hal::byte&gt; p_data)\n  {\n    return driver_write(p_data);\n  }\n\n  [[nodiscard]] result&lt;read_t&gt; read(std::span&lt;hal::byte&gt; p_data)\n  {\n    return driver_read(p_data);\n  }\n  [[nodiscard]] result&lt;flush_t&gt; flush()\n  {\n    return driver_flush();\n  }\n\n  virtual ~serial() = default;\n\nprivate:\n  virtual status driver_configure(const settings&amp; p_settings) = 0;\n  virtual result&lt;write_t&gt; driver_write(std::span&lt;const hal::byte&gt; p_data) = 0;\n  virtual result&lt;read_t&gt; driver_read(std::span&lt;hal::byte&gt; p_data) = 0;\n  virtual result&lt;flush_t&gt; driver_flush() = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/servo_8hpp/","title":"File servo.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; servo.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/servo_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/servo_8hpp/#classes","title":"Classes","text":"Type Name class servo Hardware abstraction for a closed loop position controlled rotational actuator. struct position_t Feedback from setting the servo position. struct range_error Error information indicating the range of the servo. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/servo.hpp</code></p>"},{"location":"api/servo_8hpp_source/","title":"File servo.hpp","text":"<p>File List &gt; include &gt; libhal &gt; servo.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"error.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass servo\n{\npublic:\n  struct position_t\n  {};\n\n  struct range_error\n  {\n    hal::degrees min;\n    hal::degrees max;\n  };\n\n  [[nodiscard]] result&lt;position_t&gt; position(hal::degrees p_position)\n  {\n    return driver_position(p_position);\n  }\n\n  virtual ~servo() = default;\n\nprivate:\n  virtual result&lt;position_t&gt; driver_position(hal::degrees p_position) = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2spi_8hpp/","title":"File spi.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; spi.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/libhal_2spi_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal_2spi_8hpp/#classes","title":"Classes","text":"Type Name class spi Serial peripheral interface (SPI) communication protocol hardware abstract interface. struct settings Generic settings for a standard SPI device. struct transfer_t Feedback from performing a transfer on the spi bus. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/spi.hpp</code></p>"},{"location":"api/libhal_2spi_8hpp_source/","title":"File spi.hpp","text":"<p>File List &gt; include &gt; libhal &gt; spi.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;span&gt;\n\n#include \"error.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass spi\n{\npublic:\n  struct settings\n  {\n    hertz clock_rate = 100.0_kHz;\n    bool clock_idles_high = false;\n    bool data_valid_on_trailing_edge = false;\n  };\n\n  struct transfer_t\n  {};\n\n  static constexpr hal::byte default_filler = hal::byte{ 0xFF };\n\n  [[nodiscard]] status configure(const settings&amp; p_settings)\n  {\n    return driver_configure(p_settings);\n  }\n  [[nodiscard]] result&lt;transfer_t&gt; transfer(\n    std::span&lt;const hal::byte&gt; p_data_out,\n    std::span&lt;hal::byte&gt; p_data_in,\n    hal::byte p_filler = default_filler)\n  {\n    return driver_transfer(p_data_out, p_data_in, p_filler);\n  }\n\n  virtual ~spi() = default;\n\nprivate:\n  virtual status driver_configure(const settings&amp; p_settings) = 0;\n  virtual result&lt;transfer_t&gt; driver_transfer(\n    std::span&lt;const hal::byte&gt; p_data_out,\n    std::span&lt;hal::byte&gt; p_data_in,\n    hal::byte p_filler) = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2steady__clock_8hpp/","title":"File steady_clock.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; steady_clock.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/libhal_2steady__clock_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal_2steady__clock_8hpp/#classes","title":"Classes","text":"Type Name class steady_clock Hardware abstraction interface for a steady clock mechanism. struct frequency_t Result from requesting the operating frequency of the steady clock. struct uptime_t Result from calling uptime. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/steady_clock.hpp</code></p>"},{"location":"api/libhal_2steady__clock_8hpp_source/","title":"File steady_clock.hpp","text":"<p>File List &gt; include &gt; libhal &gt; steady_clock.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include \"error.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass steady_clock\n{\npublic:\n  struct frequency_t\n  {\n    hertz operating_frequency;\n  };\n\n  struct uptime_t\n  {\n    std::uint64_t ticks;\n  };\n\n  [[nodiscard]] frequency_t frequency()\n  {\n    return driver_frequency();\n  }\n\n  [[nodiscard]] uptime_t uptime()\n  {\n    return driver_uptime();\n  }\n\n  virtual ~steady_clock() = default;\n\nprivate:\n  virtual frequency_t driver_frequency() = 0;\n  virtual uptime_t driver_uptime() = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/temperature__sensor_8hpp/","title":"File temperature_sensor.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; temperature_sensor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/temperature__sensor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/temperature__sensor_8hpp/#classes","title":"Classes","text":"Type Name class temperature_sensor Temperature sensing hardware abstraction interface. struct read_t Result from reading the temperature sensor. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/temperature_sensor.hpp</code></p>"},{"location":"api/temperature__sensor_8hpp_source/","title":"File temperature_sensor.hpp","text":"<p>File List &gt; include &gt; libhal &gt; temperature_sensor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"error.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass temperature_sensor\n{\npublic:\n  struct read_t\n  {\n    celsius temperature;\n  };\n\n  [[nodiscard]] result&lt;read_t&gt; read()\n  {\n    return driver_read();\n  }\n\n  virtual ~temperature_sensor() = default;\n\nprivate:\n  virtual result&lt;read_t&gt; driver_read() = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2timeout_8hpp/","title":"File timeout.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; timeout.hpp</p> <p>Go to the source code of this file</p> <p>Provides the hal::timeout type and utility functions that use that type. </p> <ul> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"functional.hpp\"</code></li> </ul>"},{"location":"api/libhal_2timeout_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/timeout.hpp</code></p>"},{"location":"api/libhal_2timeout_8hpp_source/","title":"File timeout.hpp","text":"<p>File List &gt; include &gt; libhal &gt; timeout.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"error.hpp\"\n#include \"functional.hpp\"\n\nnamespace hal {\nenum class work_state\n{\n  // Callable is in progress and has not yet finished performing its work.\n  in_progress,\n  // Callable was able to determine that it failed to do what it was tasked to\n  // do and has terminated.\n  failed,\n  // Callable finished the work it needed to perform and has terminated.\n  finished,\n};\n\nusing timeout_function = status(void);\n\ntemplate&lt;class T&gt;\nconcept timeout = std::convertible_to&lt;T, hal::function_ref&lt;timeout_function&gt;&gt;;\n\nusing work_function = result&lt;work_state&gt;();\n\ntemplate&lt;class T&gt;\nconcept worker = std::convertible_to&lt;T, hal::function_ref&lt;work_function&gt;&gt;;\n\n[[nodiscard]] inline status delay(timeout auto p_timeout)\n{\n  bool waiting = true;\n\n  // This lambda catches a `std::errc::timed_out` handle them by changing\n  // `waiting` from true to false in order to break the while loop below.\n  auto timeout_catcher =\n    [&amp;waiting](hal::match&lt;std::errc, std::errc::timed_out&gt; p_errc) -&gt; status {\n    (void)p_errc;\n    // Simply change the waiting bool\n    waiting = false;\n    // return successful\n    return {};\n  };\n\n  HAL_CHECK(hal::attempt(\n    [&amp;p_timeout]() -&gt; status {\n      // Continuously call p_callback until it either returns\n      // `std::errc::timeout_out`\n      while (true) {\n        HAL_CHECK(p_timeout());\n      }\n      // Unreachable!\n      return {};\n    },\n    timeout_catcher));\n\n  return {};\n}\n\n[[nodiscard]] inline auto never_timeout()\n{\n  return []() -&gt; status { return {}; };\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2timer_8hpp/","title":"File timer.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; timer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include \"error.hpp\"</code></li> <li><code>#include \"functional.hpp\"</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/libhal_2timer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal_2timer_8hpp/#classes","title":"Classes","text":"Type Name class timer Timer hardware abstraction interface. struct cancel_t Feedback from cancelling a timer. struct is_running_t Feedback after checking if the timer is running. struct out_of_bounds_error Error type indicating that the desired time delay is not achievable with this timer. struct schedule_t Feedback from scheduling a timer. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/timer.hpp</code></p>"},{"location":"api/libhal_2timer_8hpp_source/","title":"File timer.hpp","text":"<p>File List &gt; include &gt; libhal &gt; timer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;chrono&gt;\n\n#include \"error.hpp\"\n#include \"functional.hpp\"\n#include \"units.hpp\"\n\nnamespace hal {\nclass timer\n{\npublic:\n  struct out_of_bounds_error\n  {\n    std::chrono::nanoseconds tick_period;\n    std::chrono::nanoseconds maximum;\n  };\n\n  struct is_running_t\n  {\n    bool is_running;\n  };\n\n  struct cancel_t\n  {};\n\n  struct schedule_t\n  {};\n\n  [[nodiscard]] result&lt;is_running_t&gt; is_running()\n  {\n    return driver_is_running();\n  }\n\n  [[nodiscard]] result&lt;cancel_t&gt; cancel()\n  {\n    return driver_cancel();\n  }\n\n  [[nodiscard]] result&lt;schedule_t&gt; schedule(\n    hal::callback&lt;void(void)&gt; p_callback,\n    hal::time_duration p_delay)\n  {\n    return driver_schedule(p_callback, p_delay);\n  }\n\n  virtual ~timer() = default;\n\nprivate:\n  virtual result&lt;is_running_t&gt; driver_is_running() = 0;\n  virtual result&lt;cancel_t&gt; driver_cancel() = 0;\n  virtual result&lt;schedule_t&gt; driver_schedule(\n    hal::callback&lt;void(void)&gt; p_callback,\n    hal::time_duration p_delay) = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal_2units_8hpp/","title":"File units.hpp","text":"<p>FileList &gt; include &gt; libhal &gt; units.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include \"error.hpp\"</code></li> </ul>"},{"location":"api/libhal_2units_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace literals Namespace containing user defined literals for the hal standard units. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal/units.hpp</code></p>"},{"location":"api/libhal_2units_8hpp_source/","title":"File units.hpp","text":"<p>File List &gt; include &gt; libhal &gt; units.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;cstdint&gt;\n\n#include \"error.hpp\"\n\nnamespace hal {\nusing time_duration = std::chrono::nanoseconds;\n\nusing byte = std::uint8_t;\n\nusing hertz = float;\n\nusing g_force = float;\n\nusing ampere = float;\n\nusing volts = float;\n\nusing celsius = float;\n\nusing rpm = float;\n\nusing meters = float;\n\nusing degrees = float;\n\nusing gauss = float;\n\nenum class pin_resistor\n{\n  none = 0,\n  pull_down,\n  pull_up,\n};\n\nnamespace literals {\n\n// =============================================================================\n// Frequency\n// =============================================================================\n\n[[nodiscard]] consteval hertz operator\"\"_Hz(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value);\n}\n\n[[nodiscard]] consteval hertz operator\"\"_kHz(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value * std::kilo::num);\n}\n\n[[nodiscard]] consteval hertz operator\"\"_MHz(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value * std::mega::num);\n}\n\n[[nodiscard]] consteval hertz operator\"\"_GHz(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value * std::giga::num);\n}\n\n// =============================================================================\n// G force\n// =============================================================================\n\n[[nodiscard]] consteval g_force operator\"\"_g(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value);\n}\n\n// =============================================================================\n// Ampere\n// =============================================================================\n\n[[nodiscard]] consteval ampere operator\"\"_kA(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value * std::kilo::num);\n}\n\n[[nodiscard]] consteval ampere operator\"\"_A(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value);\n}\n\n[[nodiscard]] consteval ampere operator\"\"_mA(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value / std::milli::den);\n}\n\n[[nodiscard]] consteval ampere operator\"\"_uA(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value / std::micro::den);\n}\n\n// =============================================================================\n// Voltage\n// =============================================================================\n\n[[nodiscard]] consteval volts operator\"\"_kV(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value * std::kilo::num);\n}\n\n[[nodiscard]] consteval volts operator\"\"_V(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value);\n}\n\n[[nodiscard]] consteval volts operator\"\"_mV(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value / std::milli::den);\n}\n\n[[nodiscard]] consteval volts operator\"\"_uV(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value / std::micro::den);\n}\n\n// =============================================================================\n// Temperature\n// =============================================================================\n\n[[nodiscard]] consteval celsius operator\"\"_C(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value);\n}\n\n[[nodiscard]] consteval celsius operator\"\"_F(long double p_value) noexcept\n{\n  p_value = (p_value - 32.0L) * (5.0L / 9.0L);\n  return static_cast&lt;float&gt;(p_value);\n}\n\n[[nodiscard]] consteval celsius operator\"\"_K(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value - 273.15L);\n}\n\n// =============================================================================\n// Rotational Velocity\n// =============================================================================\n\n[[nodiscard]] consteval rpm operator\"\"_rpm(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value);\n}\n\n[[nodiscard]] consteval rpm operator\"\"_deg_per_sec(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value / 6.0L);\n}\n\n// =============================================================================\n// Angle\n// =============================================================================\n\n[[nodiscard]] consteval degrees operator\"\"_deg(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value);\n}\n\n// =============================================================================\n// Lengths\n// =============================================================================\n\n[[nodiscard]] consteval meters operator\"\"_um(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value / std::micro::den);\n}\n\n[[nodiscard]] consteval meters operator\"\"_mm(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value / std::milli::den);\n}\n\n[[nodiscard]] consteval meters operator\"\"_m(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value);\n}\n\n[[nodiscard]] consteval meters operator\"\"_km(long double p_value) noexcept\n{\n  return static_cast&lt;float&gt;(p_value * std::kilo::num);\n}\n\n[[nodiscard]] consteval meters operator\"\"_inch(long double p_value) noexcept\n{\n  constexpr long double inch_to_meter = 0.0254L;\n  return static_cast&lt;float&gt;(p_value * inch_to_meter);\n}\n\n[[nodiscard]] consteval meters operator\"\"_yards(long double p_value) noexcept\n{\n  constexpr long double yard_to_meter = 0.9144L;\n  return static_cast&lt;float&gt;(p_value * yard_to_meter);\n}\n\n[[nodiscard]] consteval meters operator\"\"_miles(long double p_value) noexcept\n{\n  constexpr long double miles_to_meter = 1609.344L;\n  return static_cast&lt;float&gt;(p_value * miles_to_meter);\n}\n}  // namespace literals\n\n// Make user defined namespaces available to any library within the hal\n// namespace\nusing namespace literals;\n}  // namespace hal\n</code></pre>"},{"location":"api/dir_b3459571a2adf19d50d3ad84e10dbc87/","title":"Dir libraries/include/libhal-armcortex","text":"<p>FileList &gt; include &gt; libhal-armcortex</p>"},{"location":"api/dir_b3459571a2adf19d50d3ad84e10dbc87/#files","title":"Files","text":"Type Name file dwt_counter.hpp file interrupt.hpp file startup.hpp file system_control.hpp file systick_timer.hpp <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-armcortex/</code></p>"},{"location":"api/dwt__counter_8hpp/","title":"File dwt_counter.hpp","text":"<p>FileList &gt; include &gt; libhal-armcortex &gt; dwt_counter.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal-util/overflow_counter.hpp&gt;</code></li> <li><code>#include &lt;libhal/steady_clock.hpp&gt;</code></li> </ul>"},{"location":"api/dwt__counter_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace cortex_m libhal drivers for the ARM Cortex-M series of processors"},{"location":"api/dwt__counter_8hpp/#classes","title":"Classes","text":"Type Name class dwt_counter A counter with a frequency fixed to the CPU clock rate. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-armcortex/dwt_counter.hpp</code></p>"},{"location":"api/dwt__counter_8hpp_source/","title":"File dwt_counter.hpp","text":"<p>File List &gt; include &gt; libhal-armcortex &gt; dwt_counter.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal-util/overflow_counter.hpp&gt;\n#include &lt;libhal/steady_clock.hpp&gt;\n\nnamespace hal::cortex_m {\nclass dwt_counter : public hal::steady_clock\n{\npublic:\n  dwt_counter(hertz p_cpu_frequency);\n\n  void register_cpu_frequency(hertz p_cpu_frequency);\n\nprivate:\n  uptime_t driver_uptime() override;\n  frequency_t driver_frequency() override;\n\n  overflow_counter&lt;32&gt; m_uptime{};\n  hertz m_cpu_frequency{ 1'000'000 };\n};\n}  // namespace hal::cortex_m\n</code></pre>"},{"location":"api/interrupt_8hpp/","title":"File interrupt.hpp","text":"<p>FileList &gt; include &gt; libhal-armcortex &gt; interrupt.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> <li><code>#include &lt;libhal/error.hpp&gt;</code></li> </ul>"},{"location":"api/interrupt_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace cortex_m libhal drivers for the ARM Cortex-M series of processors"},{"location":"api/interrupt_8hpp/#classes","title":"Classes","text":"Type Name class interrupt Cortex M series interrupt controller. class exception_number represents an interrupt request number along with helper functions for setting up the interrupt controller registers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-armcortex/interrupt.hpp</code></p>"},{"location":"api/interrupt_8hpp_source/","title":"File interrupt.hpp","text":"<p>File List &gt; include &gt; libhal-armcortex &gt; interrupt.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;array&gt;\n#include &lt;span&gt;\n#include &lt;utility&gt;\n\n#include &lt;libhal/error.hpp&gt;\n\nnamespace hal::cortex_m {\nusing interrupt_pointer = void (*)();\n\nenum class irq\n{\n  top_of_stack = 0,\n  reset = 1,\n  nmi = 2,\n  hard_fault = 3,\n  memory_management_fault = 4,\n  bus_fault = 5,\n  usage_fault = 6,\n  reserve7 = 7,\n  reserve8 = 8,\n  reserve9 = 9,\n  reserve10 = 10,\n  sv_call = 11,\n  reserve12 = 12,\n  reserve13 = 13,\n  pend_sv = 14,\n  systick = 15,\n};\n\nclass interrupt\n{\npublic:\n  static constexpr size_t core_interrupts = 16;\n\n  class exception_number\n  {\n  public:\n    constexpr exception_number(std::uint16_t p_id)\n      : m_id(p_id)\n    {\n    }\n\n    constexpr exception_number(exception_number&amp; p_id) = default;\n    constexpr exception_number&amp; operator=(exception_number&amp; p_id) = default;\n\n    static constexpr uint32_t index_position = 5;\n\n    static constexpr uint32_t enable_mask_code = 0x1F;\n\n    [[nodiscard]] constexpr bool default_enabled() const\n    {\n      return m_id &lt; core_interrupts;\n    }\n\n    [[nodiscard]] constexpr std::uint32_t to_irq_number() const\n    {\n      return static_cast&lt;std::uint32_t&gt;(m_id - core_interrupts);\n    }\n\n    [[nodiscard]] constexpr std::uint32_t register_index() const\n    {\n      return to_irq_number() &gt;&gt; index_position;\n    }\n\n    [[nodiscard]] constexpr std::uint32_t enable_mask() const\n    {\n      return 1U &lt;&lt; (to_irq_number() &amp; enable_mask_code);\n    }\n\n    [[nodiscard]] constexpr size_t vector_index() const\n    {\n      return m_id;\n    }\n\n    [[nodiscard]] bool is_valid() const\n    {\n      return m_id &lt; get_vector_table().size();\n    }\n\n    [[nodiscard]] constexpr std::uint16_t get_event_number()\n    {\n      return m_id;\n    }\n\n  private:\n    std::uint16_t m_id = 0;\n  };\n\n  static void nop();\n\n  template&lt;size_t VectorCount&gt;\n  static void initialize()\n  {\n    // Statically allocate a buffer of vectors to be used as the new IVT.\n    static constexpr size_t total_vector_count = VectorCount + core_interrupts;\n    alignas(512) static std::array&lt;interrupt_pointer, total_vector_count&gt;\n      vector_buffer{};\n    setup(vector_buffer);\n  }\n\n  template&lt;size_t VectorCount&gt;\n  static void reinitialize()\n  {\n    reset();\n    initialize&lt;VectorCount&gt;();\n  }\n\n  static const std::span&lt;interrupt_pointer&gt; get_vector_table();\n\n  static void disable_interrupts();\n\n  static void enable_interrupts();\n\n  explicit interrupt(exception_number p_id);\n\n  void enable(interrupt_pointer p_handler);\n\n  void disable();\n\n  [[nodiscard]] bool verify_vector_enabled(interrupt_pointer p_handler);\n\nprivate:\n  static void reset();\n  static void setup(std::span&lt;interrupt_pointer&gt; p_vector_table);\n\n  exception_number m_id;\n};\n}  // namespace hal::cortex_m\n</code></pre>"},{"location":"api/startup_8hpp/","title":"File startup.hpp","text":"<p>FileList &gt; include &gt; libhal-armcortex &gt; startup.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> </ul>"},{"location":"api/startup_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace cortex_m libhal drivers for the ARM Cortex-M series of processors"},{"location":"api/startup_8hpp/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t __bss_size This is the length of the bss section to write zeros to. uint32_t __bss_start this symbol is placed at the start of the bss section in RAM. uint32_t __data_size This is the length of the data to be copied from ROM to RAM. uint32_t __data_source this symbol is place at the start of the data contents in ROM. This is where the globally defined values for each statically allocated variable is saved. uint32_t __data_start this symbol is placed at the start of the data section in RAM."},{"location":"api/startup_8hpp/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"api/startup_8hpp/#variable-__bss_size","title":"variable __bss_size","text":"<pre><code>uint32_t __bss_size;\n</code></pre>"},{"location":"api/startup_8hpp/#variable-__bss_start","title":"variable __bss_start","text":"<pre><code>uint32_t __bss_start;\n</code></pre>"},{"location":"api/startup_8hpp/#variable-__data_size","title":"variable __data_size","text":"<pre><code>uint32_t __data_size;\n</code></pre>"},{"location":"api/startup_8hpp/#variable-__data_source","title":"variable __data_source","text":"<pre><code>uint32_t __data_source;\n</code></pre>"},{"location":"api/startup_8hpp/#variable-__data_start","title":"variable __data_start","text":"<pre><code>uint32_t __data_start;\n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-armcortex/startup.hpp</code></p>"},{"location":"api/startup_8hpp_source/","title":"File startup.hpp","text":"<p>File List &gt; include &gt; libhal-armcortex &gt; startup.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n\n// These need to be supplied by the linker script if the application developer\n// in order to call hal::cortex::initialize_data_section()\nextern \"C\"\n{\n  extern uint32_t __data_start;\n  extern uint32_t __data_source;\n  extern uint32_t __data_size;\n  extern uint32_t __bss_start;\n  extern uint32_t __bss_size;\n}\n\nnamespace hal::cortex_m {\ninline void initialize_data_section()\n{\n  // Initialize statically allocated data by coping the data section from ROM to\n  // RAM. CRT0.o/.s does not perform .data section initialization so it must be\n  // done by initialize_platform.\n  intptr_t data_size = reinterpret_cast&lt;intptr_t&gt;(&amp;__data_size);\n  memcpy(&amp;__data_start, &amp;__data_source, data_size);\n}\ninline void initialize_bss_section()\n{\n  // Initialize statically allocated data by coping the data section from ROM to\n  // RAM. CRT0.o/.s does not perform .data section initialization so it must be\n  // done by initialize_platform.\n  intptr_t bss_size = reinterpret_cast&lt;intptr_t&gt;(&amp;__bss_size);\n  memset(&amp;__bss_start, 0, bss_size);\n}\n}  // namespace hal::cortex_m\n</code></pre>"},{"location":"api/system__control_8hpp/","title":"File system_control.hpp","text":"<p>FileList &gt; include &gt; libhal-armcortex &gt; system_control.hpp</p> <p>Go to the source code of this file</p>"},{"location":"api/system__control_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace cortex_m libhal drivers for the ARM Cortex-M series of processors <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-armcortex/system_control.hpp</code></p>"},{"location":"api/system__control_8hpp_source/","title":"File system_control.hpp","text":"<p>File List &gt; include &gt; libhal-armcortex &gt; system_control.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\nnamespace hal::cortex_m {\nvoid initialize_floating_point_unit();\n\nvoid set_interrupt_vector_table_address(void* p_table_location);\n\nvoid* get_interrupt_vector_table_address();\n\nvoid reset();\n\nvoid wait_for_interrupt();\n\nvoid wait_for_event();\n}  // namespace hal::cortex_m\n</code></pre>"},{"location":"api/systick__timer_8hpp/","title":"File systick_timer.hpp","text":"<p>FileList &gt; include &gt; libhal-armcortex &gt; systick_timer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;libhal-util/units.hpp&gt;</code></li> <li><code>#include &lt;libhal/timer.hpp&gt;</code></li> </ul>"},{"location":"api/systick__timer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace cortex_m libhal drivers for the ARM Cortex-M series of processors"},{"location":"api/systick__timer_8hpp/#classes","title":"Classes","text":"Type Name class systick_timer SysTick driver for the ARM Cortex Mx series chips. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-armcortex/systick_timer.hpp</code></p>"},{"location":"api/systick__timer_8hpp_source/","title":"File systick_timer.hpp","text":"<p>File List &gt; include &gt; libhal-armcortex &gt; systick_timer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include &lt;libhal-util/units.hpp&gt;\n#include &lt;libhal/timer.hpp&gt;\n\nnamespace hal::cortex_m {\nclass systick_timer : public hal::timer\n{\npublic:\n  enum class clock_source : std::uint8_t\n  {\n    external = 0,\n    processor = 1,\n  };\n\n  systick_timer(hertz p_frequency,\n                clock_source p_source = clock_source::processor);\n\n  void register_cpu_frequency(hertz p_frequency,\n                              clock_source p_source = clock_source::processor);\n\n  ~systick_timer();\n\nprivate:\n  result&lt;is_running_t&gt; driver_is_running() override;\n  result&lt;cancel_t&gt; driver_cancel() override;\n  result&lt;schedule_t&gt; driver_schedule(hal::callback&lt;void(void)&gt; p_callback,\n                                     hal::time_duration p_delay) override;\n\n  hertz m_frequency = 1'000'000.0f;\n};\n}  // namespace hal::cortex_m\n</code></pre>"},{"location":"api/dir_2c64ce4d64c558a00b906bdd8bb48b1b/","title":"Dir libraries/include/libhal-canrouter","text":"<p>FileList &gt; include &gt; libhal-canrouter</p>"},{"location":"api/dir_2c64ce4d64c558a00b906bdd8bb48b1b/#files","title":"Files","text":"Type Name file can_router.hpp <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-canrouter/</code></p>"},{"location":"api/can__router_8hpp/","title":"File can_router.hpp","text":"<p>FileList &gt; include &gt; libhal-canrouter &gt; can_router.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal-util/static_list.hpp&gt;</code></li> <li><code>#include &lt;libhal/can.hpp&gt;</code></li> </ul>"},{"location":"api/can__router_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/can__router_8hpp/#classes","title":"Classes","text":"Type Name class can_router Route CAN messages received on the can bus to callbacks based on ID. struct route <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-canrouter/can_router.hpp</code></p>"},{"location":"api/can__router_8hpp_source/","title":"File can_router.hpp","text":"<p>File List &gt; include &gt; libhal-canrouter &gt; can_router.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal-util/static_list.hpp&gt;\n#include &lt;libhal/can.hpp&gt;\n\nnamespace hal {\nclass can_router\n{\npublic:\n  static constexpr auto noop =\n    []([[maybe_unused]] const can::message_t&amp; p_message) {};\n\n  using message_handler = hal::callback&lt;hal::can::handler&gt;;\n\n  struct route\n  {\n    hal::can::id_t id = 0;\n    message_handler handler = noop;\n  };\n\n  using route_item = static_list&lt;route&gt;::item;\n\n  static result&lt;can_router&gt; create(hal::can&amp; p_can);\n\n  explicit can_router(hal::can&amp; p_can);\n\n  can_router() = delete;\n  can_router(can_router&amp; p_other) = delete;\n  can_router&amp; operator=(can_router&amp; p_other) = delete;\n  can_router&amp; operator=(can_router&amp;&amp; p_other) noexcept;\n  can_router(can_router&amp;&amp; p_other) noexcept;\n  ~can_router();\n\n  [[nodiscard]] hal::can&amp; bus();\n\n  [[nodiscard]] static_list&lt;route&gt;::item add_message_callback(\n    hal::can::id_t p_id);\n\n  [[nodiscard]] static_list&lt;route&gt;::item add_message_callback(\n    hal::can::id_t p_id,\n    message_handler p_handler);\n\n  [[nodiscard]] const static_list&lt;route&gt;&amp; handlers();\n\n  void operator()(const can::message_t&amp; p_message);\n\nprivate:\n  static_list&lt;route&gt; m_handlers{};\n  hal::can* m_can = nullptr;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/dir_b51c311201f953ecf0af8480d3c6c210/","title":"Dir libraries/include/libhal-esp8266","text":"<p>FileList &gt; include &gt; libhal-esp8266</p>"},{"location":"api/dir_b51c311201f953ecf0af8480d3c6c210/#files","title":"Files","text":"Type Name file at.hpp <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-esp8266/</code></p>"},{"location":"api/at_8hpp/","title":"File at.hpp","text":"<p>FileList &gt; include &gt; libhal-esp8266 &gt; at.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> <li><code>#include &lt;libhal/functional.hpp&gt;</code></li> <li><code>#include &lt;libhal/serial.hpp&gt;</code></li> <li><code>#include &lt;libhal/timeout.hpp&gt;</code></li> </ul>"},{"location":"api/at_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace esp8266 libhal compatible libraries for the esp8266 device and microcontroller"},{"location":"api/at_8hpp/#classes","title":"Classes","text":"Type Name class at AT Command network driver for the esp8266 . struct read_t struct socket_config struct write_t <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-esp8266/at.hpp</code></p>"},{"location":"api/at_8hpp_source/","title":"File at.hpp","text":"<p>File List &gt; include &gt; libhal-esp8266 &gt; at.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;array&gt;\n#include &lt;cstdint&gt;\n#include &lt;string_view&gt;\n\n#include &lt;libhal/functional.hpp&gt;\n#include &lt;libhal/serial.hpp&gt;\n#include &lt;libhal/timeout.hpp&gt;\n\nnamespace hal::esp8266 {\n\nclass at\n{\npublic:\n  using deadline = hal::function_ref&lt;hal::timeout_function&gt;;\n\n  enum class socket_type : std::uint8_t\n  {\n    tcp,\n    udp,\n  };\n\n  struct socket_config\n  {\n    socket_type type = socket_type::tcp;\n    std::string_view domain;\n    std::uint16_t port = 80;\n  };\n\n  struct read_t\n  {\n    // The buffer containing the bytes read from the server\n    std::span&lt;hal::byte&gt; data;\n  };\n\n  struct write_t\n  {\n    // The buffer that was written to the server\n    std::span&lt;const hal::byte&gt; data;\n  };\n\n  [[nodiscard]] static result&lt;at&gt; create(hal::serial&amp; p_serial,\n                                         deadline p_timeout);\n  template&lt;unsigned id&gt;\n  [[nodiscard]] static result&lt;at&amp;&gt; initialize(hal::serial&amp; p_serial,\n                                              deadline p_timeout);\n\n  // System Control Commands\n  [[nodiscard]] hal::status reset(deadline p_timeout);\n\n  // WiFi access point commands\n  [[nodiscard]] hal::status connect_to_ap(std::string_view p_ssid,\n                                          std::string_view p_password,\n                                          deadline p_timeout);\n  [[nodiscard]] hal::status set_ip_address(std::string_view p_ip,\n                                           deadline p_timeout);\n  [[nodiscard]] hal::result&lt;bool&gt; is_connected_to_ap(deadline p_timeout);\n  [[nodiscard]] hal::status disconnect_from_ap(deadline p_timeout);\n\n  // TCP/UDP AT commands\n  [[nodiscard]] hal::status connect_to_server(socket_config p_config,\n                                              deadline p_timeout);\n  [[nodiscard]] hal::result&lt;bool&gt; is_connected_to_server(deadline p_timeout);\n  [[nodiscard]] hal::result&lt;write_t&gt; server_write(\n    std::span&lt;const hal::byte&gt; p_data,\n    deadline p_timeout);\n  [[nodiscard]] hal::result&lt;read_t&gt; server_read(std::span&lt;hal::byte&gt; p_data);\n  [[nodiscard]] hal::status disconnect_from_server(deadline p_timeout);\n\nprivate:\n  class packet_manager\n  {\n  public:\n    packet_manager();\n    void find(hal::serial&amp; p_serial);\n    bool is_complete_header();\n    std::uint16_t packet_length();\n    hal::result&lt;std::span&lt;hal::byte&gt;&gt; read_packet(\n      hal::serial&amp; p_serial,\n      std::span&lt;hal::byte&gt; p_buffer);\n    void reset();\n    void set_state(std::uint8_t p_state);\n\n  private:\n    void update_state(hal::byte p_byte);\n    std::uint8_t m_state;\n    std::uint16_t m_length;\n  };\n\n  at(hal::serial&amp; p_serial);\n\n  hal::serial* m_serial;\n  packet_manager m_packet_manager;\n};\n}  // namespace hal::esp8266\n</code></pre>"},{"location":"api/dir_2fff134b595a3a874b0307aab0eea726/","title":"Dir libraries/include/libhal-lpc40","text":"<p>FileList &gt; include &gt; libhal-lpc40</p>"},{"location":"api/dir_2fff134b595a3a874b0307aab0eea726/#files","title":"Files","text":"Type Name file adc.hpp file can.hpp file clock.hpp file constants.hpp file i2c.hpp file input_pin.hpp file interrupt_pin.hpp file output_pin.hpp file pin.hpp file power.hpp file pwm.hpp file spi.hpp file uart.hpp <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/</code></p>"},{"location":"api/libhal-lpc40_2adc_8hpp/","title":"File adc.hpp","text":"<p>FileList &gt; include &gt; libhal-lpc40 &gt; adc.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;libhal/adc.hpp&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> <li><code>#include \"constants.hpp\"</code></li> <li><code>#include \"pin.hpp\"</code></li> </ul>"},{"location":"api/libhal-lpc40_2adc_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP"},{"location":"api/libhal-lpc40_2adc_8hpp/#classes","title":"Classes","text":"Type Name class adc Analog to digital converter. struct channel Channel specific information. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/adc.hpp</code></p>"},{"location":"api/libhal-lpc40_2adc_8hpp_source/","title":"File adc.hpp","text":"<p>File List &gt; include &gt; libhal-lpc40 &gt; adc.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include &lt;libhal/adc.hpp&gt;\n#include &lt;libhal/units.hpp&gt;\n\n#include \"constants.hpp\"\n#include \"pin.hpp\"\n\nnamespace hal::lpc40 {\nclass adc : public hal::adc\n{\npublic:\n  struct channel\n  {\n    hertz clock_rate = 1'000'000.0f;\n    pin adc_pin;\n    uint8_t index;\n    uint8_t pin_function;\n  };\n\n  static result&lt;adc&gt; get(size_t p_channel);\n\n  static result&lt;adc&gt; construct_custom_channel(const channel&amp; p_channel);\n\n  virtual ~adc() = default;\n\nprivate:\n  adc(const channel&amp; p_channel);\n  result&lt;read_t&gt; driver_read() override;\n\n  volatile uint32_t* m_sample = nullptr;\n};\n}  // namespace hal::lpc40\n</code></pre>"},{"location":"api/libhal-lpc40_2can_8hpp/","title":"File can.hpp","text":"<p>FileList &gt; include &gt; libhal-lpc40 &gt; can.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;libhal/can.hpp&gt;</code></li> <li><code>#include \"constants.hpp\"</code></li> <li><code>#include \"pin.hpp\"</code></li> </ul>"},{"location":"api/libhal-lpc40_2can_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP"},{"location":"api/libhal-lpc40_2can_8hpp/#classes","title":"Classes","text":"Type Name class can struct port <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/can.hpp</code></p>"},{"location":"api/libhal-lpc40_2can_8hpp_source/","title":"File can.hpp","text":"<p>File List &gt; include &gt; libhal-lpc40 &gt; can.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include &lt;libhal/can.hpp&gt;\n\n#include \"constants.hpp\"\n#include \"pin.hpp\"\n\nnamespace hal::lpc40 {\nclass can final : public hal::can\n{\npublic:\n  struct port\n  {\n    pin td;\n    std::uint8_t td_function_code;\n    pin rd;\n    std::uint8_t rd_function_code;\n    peripheral id;\n    irq irq_number;\n    std::uint8_t sync_jump = 0;\n    std::uint8_t tseg1 = 6;\n    std::uint8_t tseg2 = 1;\n  };\n\n  static result&lt;can&gt; get(std::uint8_t p_port,\n                         const can::settings&amp; p_settings = {});\n\n  can(can&amp; p_other) = delete;\n  can&amp; operator=(can&amp; p_other) = delete;\n  can(can&amp;&amp; p_other) noexcept;\n  can&amp; operator=(can&amp;&amp; p_other) noexcept;\n  ~can();\n\nprivate:\n  can(port p_port);\n\n  status driver_configure(const settings&amp; p_settings) override;\n  status driver_bus_on() override;\n  result&lt;send_t&gt; driver_send(const message_t&amp; p_message) override;\n  void driver_on_receive(\n    hal::callback&lt;can::handler&gt; p_receive_handler) override;\n\n  port m_port;\n  hal::callback&lt;can::handler&gt; m_receive_handler;\n  bool m_moved = false;\n};\n}  // namespace hal::lpc40\n</code></pre>"},{"location":"api/libhal-lpc40_2clock_8hpp/","title":"File clock.hpp","text":"<p>FileList &gt; include &gt; libhal-lpc40 &gt; clock.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;libhal-util/bit.hpp&gt;</code></li> <li><code>#include &lt;libhal-util/enum.hpp&gt;</code></li> <li><code>#include &lt;libhal/error.hpp&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> <li><code>#include \"constants.hpp\"</code></li> </ul>"},{"location":"api/libhal-lpc40_2clock_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP"},{"location":"api/libhal-lpc40_2clock_8hpp/#classes","title":"Classes","text":"Type Name class clock Allows user code to manipulate and retrieve the various system clocks speeds. struct configuration Clock configuration object. struct cpu_t cpu clock control config struct struct pll_t phase locked loops config struct struct spifi_t spifi clock control config struct struct usb_t usb clock control config struct <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/clock.hpp</code></p>"},{"location":"api/libhal-lpc40_2clock_8hpp_source/","title":"File clock.hpp","text":"<p>File List &gt; include &gt; libhal-lpc40 &gt; clock.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;array&gt;\n#include &lt;cstdint&gt;\n\n#include &lt;libhal-util/bit.hpp&gt;\n#include &lt;libhal-util/enum.hpp&gt;\n#include &lt;libhal/error.hpp&gt;\n#include &lt;libhal/units.hpp&gt;\n\n#include \"constants.hpp\"\n\nnamespace hal::lpc40 {\nclass clock\n{\npublic:\n  static constexpr hertz irc_frequency = 12'000'000.0f;\n  static constexpr uint32_t default_peripheral_divider = 4;\n\n  enum class usb_clock_source : uint8_t\n  {\n    system_clock = 0b00,\n    pll0 = 0b01,\n    pll1 = 0b10,\n  };\n\n  enum class usb_divider : uint8_t\n  {\n    divide_by1 = 0,\n    divide_by2,\n    divide_by3,\n    divide_by4,\n  };\n\n  enum class spifi_clock_source : uint8_t\n  {\n    system_clock = 0b00,\n    pll0 = 0b01,\n    pll1 = 0b10,\n  };\n\n  enum class flash_configuration : uint32_t\n  {\n    clock1 = 0b0000 &lt;&lt; 12,\n    clock2 = 0b0001 &lt;&lt; 12,\n    clock3 = 0b0010 &lt;&lt; 12,\n    clock4 = 0b0011 &lt;&lt; 12,\n    clock5 = 0b0100 &lt;&lt; 12,\n    clock6 = 0b0101 &lt;&lt; 12,\n  };\n\n  struct configuration\n  {\n    hertz oscillator_frequency = irc_frequency;\n    bool use_external_oscillator = false;\n    struct pll_t\n    {\n      bool enabled = false;\n      uint8_t multiply = 1;\n    };\n    std::array&lt;pll_t, 2&gt; pll = {};\n    struct cpu_t\n    {\n      bool use_pll0 = false;\n      uint8_t divider = 1;\n    };\n    cpu_t cpu = {};\n\n    struct usb_t\n    {\n      usb_clock_source clock = usb_clock_source::system_clock;\n      usb_divider divider = usb_divider::divide_by1;\n    };\n    usb_t usb = {};\n\n    struct spifi_t\n    {\n      spifi_clock_source clock = spifi_clock_source::system_clock;\n      uint8_t divider = 1;\n    };\n    spifi_t spifi = {};\n\n    uint8_t peripheral_divider = 4;\n\n    bool emc_half_cpu_divider = false;\n  };\n\n  static clock&amp; get();\n\n  static status maximum(hertz p_external_crystal_frequency);\n\n  hertz get_frequency(peripheral p_peripheral);\n\n  configuration&amp; config();\n\n  [[nodiscard]] status reconfigure_clocks();\n\nprivate:\n  constexpr clock()\n  {\n  }\n\n  configuration m_config{};\n  hertz m_cpu_clock_rate = irc_frequency;\n  hertz m_emc_clock_rate = irc_frequency;\n  hertz m_usb_clock_rate = irc_frequency;\n  hertz m_spifi_clock_source_rate = irc_frequency;\n  hertz m_peripheral_clock_rate = irc_frequency / default_peripheral_divider;\n};\n}  // namespace hal::lpc40\n</code></pre>"},{"location":"api/libhal-lpc40_2constants_8hpp/","title":"File constants.hpp","text":"<p>FileList &gt; include &gt; libhal-lpc40 &gt; constants.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"api/libhal-lpc40_2constants_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/constants.hpp</code></p>"},{"location":"api/libhal-lpc40_2constants_8hpp_source/","title":"File constants.hpp","text":"<p>File List &gt; include &gt; libhal-lpc40 &gt; constants.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\nnamespace hal::lpc40 {\nenum class peripheral : std::uint8_t\n{\n  lcd = 0,\n  timer0 = 1,\n  timer1 = 2,\n  uart0 = 3,\n  uart1 = 4,\n  pwm0 = 5,\n  pwm1 = 6,\n  i2c0 = 7,\n  uart4 = 8,\n  rtc = 9,\n  ssp1 = 10,\n  emc = 11,\n  adc = 12,\n  can1 = 13,\n  can2 = 14,\n  gpio = 15,\n  spifi = 16,\n  motor_control_pwm = 17,\n  quadrature_encoder = 18,\n  i2c1 = 19,\n  ssp2 = 20,\n  ssp0 = 21,\n  timer2 = 22,\n  timer3 = 23,\n  uart2 = 24,\n  uart3 = 25,\n  i2c2 = 26,\n  i2s = 27,\n  sdcard = 28,\n  gpdma = 29,\n  ethernet = 30,\n  usb = 31,\n  cpu,\n};\n\nenum class irq : std::uint16_t\n{\n  wdt = 16 + 0,\n  timer0 = 16 + 1,\n  timer1 = 16 + 2,\n  timer2 = 16 + 3,\n  timer3 = 16 + 4,\n  uart0 = 16 + 5,\n  uart1 = 16 + 6,\n  uart2 = 16 + 7,\n  uart3 = 16 + 8,\n  pwm1 = 16 + 9,\n  i2c0 = 16 + 10,\n  i2c1 = 16 + 11,\n  i2c2 = 16 + 12,\n  reserved0 = 16 + 13,\n  ssp0 = 16 + 14,\n  ssp1 = 16 + 15,\n  pll0 = 16 + 16,\n  rtc = 16 + 17,\n  eint0 = 16 + 18,\n  eint1 = 16 + 19,\n  eint2 = 16 + 20,\n  eint3 = 16 + 21,\n  adc = 16 + 22,\n  bod = 16 + 23,\n  usb = 16 + 24,\n  can = 16 + 25,\n  dma = 16 + 26,\n  i2s = 16 + 27,\n  enet = 16 + 28,\n  mci = 16 + 29,\n  mcpwm = 16 + 30,\n  qei = 16 + 31,\n  pll1 = 16 + 32,\n  usbactivity = 16 + 33,\n  canactivity = 16 + 34,\n  uart4 = 16 + 35,\n  ssp2 = 16 + 36,\n  lcd = 16 + 37,\n  gpio = 16 + 38,\n  pwm0 = 16 + 39,\n  eeprom = 16 + 40,\n  cmp0 = 16 + 41,\n  cmp1 = 16 + 42,\n  max,\n};\nenum class error_t\n{\n  requires_usage_of_external_oscillator,\n  baud_rate_impossible,\n};\n}  // namespace hal::lpc40\n</code></pre>"},{"location":"api/libhal-lpc40_2i2c_8hpp/","title":"File i2c.hpp","text":"<p>FileList &gt; include &gt; libhal-lpc40 &gt; i2c.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;libhal/i2c.hpp&gt;</code></li> <li><code>#include \"constants.hpp\"</code></li> <li><code>#include \"pin.hpp\"</code></li> </ul>"},{"location":"api/libhal-lpc40_2i2c_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP"},{"location":"api/libhal-lpc40_2i2c_8hpp/#classes","title":"Classes","text":"Type Name class i2c struct bus_info <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/i2c.hpp</code></p>"},{"location":"api/libhal-lpc40_2i2c_8hpp_source/","title":"File i2c.hpp","text":"<p>File List &gt; include &gt; libhal-lpc40 &gt; i2c.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;cstdint&gt;\n#include &lt;span&gt;\n\n#include &lt;libhal/i2c.hpp&gt;\n\n#include \"constants.hpp\"\n#include \"pin.hpp\"\n\nnamespace hal::lpc40 {\nclass i2c : public hal::i2c\n{\npublic:\n  using write_iterator = std::span&lt;const hal::byte&gt;::iterator;\n  using read_iterator = std::span&lt;hal::byte&gt;::iterator;\n\n  struct bus_info\n  {\n    peripheral peripheral_id;\n    irq irq_number;\n    pin sda;\n    std::uint8_t sda_function;\n    pin scl;\n    std::uint8_t scl_function;\n    float duty_cycle = 0.5f;\n  };\n\n  static result&lt;i2c&gt; get(std::uint8_t p_bus,\n                         const i2c::settings&amp; p_settings = {});\n\n  i2c(i2c&amp; p_other) = delete;\n  i2c&amp; operator=(i2c&amp; p_other) = delete;\n  i2c(i2c&amp;&amp; p_other) noexcept;\n  i2c&amp; operator=(i2c&amp;&amp; p_other) noexcept;\n  ~i2c();\n\nprivate:\n  i2c(bus_info p_bus);\n\n  status driver_configure(const settings&amp; p_settings) override;\n  result&lt;transaction_t&gt; driver_transaction(\n    hal::byte p_address,\n    std::span&lt;const hal::byte&gt; p_data_out,\n    std::span&lt;hal::byte&gt; p_data_in,\n    hal::function_ref&lt;hal::timeout_function&gt; p_timeout) override;\n\n  void setup_interrupt();\n  void interrupt();\n\n  bus_info m_bus;\n  write_iterator m_write_iterator;\n  write_iterator m_write_end;\n  read_iterator m_read_iterator;\n  read_iterator m_read_end;\n  std::errc m_status{};\n  hal::byte m_address = hal::byte{ 0x00 };\n  bool m_busy = false;\n  bool m_moved = false;\n};\n}  // namespace hal::lpc40\n</code></pre>"},{"location":"api/libhal-lpc40_2input__pin_8hpp/","title":"File input_pin.hpp","text":"<p>FileList &gt; include &gt; libhal-lpc40 &gt; input_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;libhal/input_pin.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-lpc40_2input__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP"},{"location":"api/libhal-lpc40_2input__pin_8hpp/#classes","title":"Classes","text":"Type Name class input_pin Input pin implementation for the lpc40xx. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/input_pin.hpp</code></p>"},{"location":"api/libhal-lpc40_2input__pin_8hpp_source/","title":"File input_pin.hpp","text":"<p>File List &gt; include &gt; libhal-lpc40 &gt; input_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include &lt;libhal/input_pin.hpp&gt;\n\nnamespace hal::lpc40 {\nclass input_pin : public hal::input_pin\n{\npublic:\n  static result&lt;input_pin&gt; get(std::uint8_t p_port,\n                               std::uint8_t p_pin,\n                               input_pin::settings p_settings = {});\n\nprivate:\n  input_pin(uint8_t p_port, uint8_t p_pin);\n\n  status driver_configure(const settings&amp; p_settings) override;\n  result&lt;level_t&gt; driver_level() override;\n\n  uint8_t m_port{};\n  uint8_t m_pin{};\n};\n}  // namespace hal::lpc40\n</code></pre>"},{"location":"api/libhal-lpc40_2interrupt__pin_8hpp/","title":"File interrupt_pin.hpp","text":"<p>FileList &gt; include &gt; libhal-lpc40 &gt; interrupt_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;bit&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;libhal/interrupt_pin.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-lpc40_2interrupt__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP"},{"location":"api/libhal-lpc40_2interrupt__pin_8hpp/#classes","title":"Classes","text":"Type Name class interrupt_pin Interrupt pin implementation for the lpc40xx. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/interrupt_pin.hpp</code></p>"},{"location":"api/libhal-lpc40_2interrupt__pin_8hpp_source/","title":"File interrupt_pin.hpp","text":"<p>File List &gt; include &gt; libhal-lpc40 &gt; interrupt_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;array&gt;\n#include &lt;bit&gt;\n#include &lt;cstdint&gt;\n\n#include &lt;libhal/interrupt_pin.hpp&gt;\n\nnamespace hal::lpc40 {\nclass interrupt_pin : public hal::interrupt_pin\n{\npublic:\n  static result&lt;interrupt_pin&gt; get(std::uint8_t port,\n                                   std::uint8_t pin,\n                                   settings p_settings = {});\n\n  interrupt_pin(interrupt_pin&amp; p_other) = delete;\n  interrupt_pin&amp; operator=(interrupt_pin&amp; p_other) = delete;\n  interrupt_pin(interrupt_pin&amp;&amp; p_other) noexcept;\n  interrupt_pin&amp; operator=(interrupt_pin&amp;&amp; p_other) noexcept;\n  ~interrupt_pin();\n\nprivate:\n  interrupt_pin(std::uint8_t p_port, std::uint8_t p_pin);\n\n  status driver_configure(const settings&amp; p_settings) override;\n  void driver_on_trigger(hal::callback&lt;handler&gt; p_callback) override;\n\n  uint8_t m_port;\n  uint8_t m_pin;\n  bool m_moved = false;\n};\n\n}  // namespace hal::lpc40\n</code></pre>"},{"location":"api/libhal-lpc40_2output__pin_8hpp/","title":"File output_pin.hpp","text":"<p>FileList &gt; include &gt; libhal-lpc40 &gt; output_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;libhal/output_pin.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-lpc40_2output__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP"},{"location":"api/libhal-lpc40_2output__pin_8hpp/#classes","title":"Classes","text":"Type Name class output_pin Output pin implementation for the lpc40xx. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/output_pin.hpp</code></p>"},{"location":"api/libhal-lpc40_2output__pin_8hpp_source/","title":"File output_pin.hpp","text":"<p>File List &gt; include &gt; libhal-lpc40 &gt; output_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include &lt;libhal/output_pin.hpp&gt;\n\nnamespace hal::lpc40 {\nclass output_pin : public hal::output_pin\n{\npublic:\n  static result&lt;output_pin&gt; get(std::uint8_t p_port,\n                                std::uint8_t p_pin,\n                                output_pin::settings p_settings = {});\n\nprivate:\n  output_pin(std::uint8_t p_port, std::uint8_t p_pin);\n\n  status driver_configure(const settings&amp; p_settings) override;\n  result&lt;set_level_t&gt; driver_level(bool p_high) override;\n  result&lt;level_t&gt; driver_level() override;\n\n  std::uint8_t m_port{};\n  std::uint8_t m_pin{};\n};\n}  // namespace hal::lpc40\n</code></pre>"},{"location":"api/libhal-lpc40_2pin_8hpp/","title":"File pin.hpp","text":"<p>FileList &gt; include &gt; libhal-lpc40 &gt; pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-lpc40_2pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP"},{"location":"api/libhal-lpc40_2pin_8hpp/#classes","title":"Classes","text":"Type Name class pin lpc40xx pin multiplexing and control driver used drivers and apps seeking to tune the pins. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/pin.hpp</code></p>"},{"location":"api/libhal-lpc40_2pin_8hpp_source/","title":"File pin.hpp","text":"<p>File List &gt; include &gt; libhal-lpc40 &gt; pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include &lt;libhal/units.hpp&gt;\n\nnamespace hal::lpc40 {\nclass pin\n{\npublic:\n  constexpr pin(std::uint8_t p_port, std::uint8_t p_pin)\n    : m_port(p_port)\n    , m_pin(p_pin)\n  {\n  }\n\n  constexpr pin() = default;\n\n  const pin&amp; function(uint8_t p_function_code) const;\n\n  const pin&amp; resistor(hal::pin_resistor p_resistor) const;\n\n  const pin&amp; hysteresis(bool p_enable) const;\n\n  const pin&amp; input_invert(bool p_enable) const;\n\n  const pin&amp; analog(bool p_enable) const;\n\n  const pin&amp; digital_filter(bool p_enable) const;\n\n  const pin&amp; highspeed_i2c(bool p_enable = true) const;\n\n  const pin&amp; high_slew_rate(bool p_enable = true) const;\n\n  const pin&amp; i2c_high_current(bool p_enable = true) const;\n\n  const pin&amp; open_drain(bool p_enable = true) const;\n\n  const pin&amp; dac(bool p_enable = true) const;\n\nprivate:\n  std::uint8_t m_port{};\n  std::uint8_t m_pin{};\n};\n}  // namespace hal::lpc40\n</code></pre>"},{"location":"api/power_8hpp/","title":"File power.hpp","text":"<p>FileList &gt; include &gt; libhal-lpc40 &gt; power.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"constants.hpp\"</code></li> </ul>"},{"location":"api/power_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP"},{"location":"api/power_8hpp/#classes","title":"Classes","text":"Type Name class power Power control for lpc40xx peripherals. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/power.hpp</code></p>"},{"location":"api/power_8hpp_source/","title":"File power.hpp","text":"<p>File List &gt; include &gt; libhal-lpc40 &gt; power.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"constants.hpp\"\n\nnamespace hal::lpc40 {\nclass power\n{\npublic:\n  power(peripheral p_peripheral);\n\n  void on();\n\n  [[nodiscard]] bool is_on();\n\n  void off();\n\nprivate:\n  peripheral m_peripheral;\n};\n}  // namespace hal::lpc40\n</code></pre>"},{"location":"api/libhal-lpc40_2pwm_8hpp/","title":"File pwm.hpp","text":"<p>FileList &gt; include &gt; libhal-lpc40 &gt; pwm.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;libhal/pwm.hpp&gt;</code></li> <li><code>#include \"constants.hpp\"</code></li> <li><code>#include \"pin.hpp\"</code></li> </ul>"},{"location":"api/libhal-lpc40_2pwm_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP"},{"location":"api/libhal-lpc40_2pwm_8hpp/#classes","title":"Classes","text":"Type Name class pwm pwm driver for the lpc40xx series of micro controllers struct channel Channel specific information. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/pwm.hpp</code></p>"},{"location":"api/libhal-lpc40_2pwm_8hpp_source/","title":"File pwm.hpp","text":"<p>File List &gt; include &gt; libhal-lpc40 &gt; pwm.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include &lt;libhal/pwm.hpp&gt;\n\n#include \"constants.hpp\"\n#include \"pin.hpp\"\n\nnamespace hal::lpc40 {\nclass pwm : public hal::pwm\n{\npublic:\n  struct channel\n  {\n    peripheral peripheral_id;\n    pin pwm_pin;\n    uint8_t index;\n    uint8_t pin_function;\n  };\n\n  [[nodiscard]] static result&lt;pwm&gt; get(std::uint8_t p_peripheral,\n                                       std::uint8_t p_channel);\n\nprivate:\n  pwm(channel p_channel);\n  result&lt;frequency_t&gt; driver_frequency(hertz p_frequency) override;\n  result&lt;duty_cycle_t&gt; driver_duty_cycle(float p_duty_cycle) override;\n\n  channel m_channel;\n};\n}  // namespace hal::lpc40\n</code></pre>"},{"location":"api/libhal-lpc40_2spi_8hpp/","title":"File spi.hpp","text":"<p>FileList &gt; include &gt; libhal-lpc40 &gt; spi.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;libhal/spi.hpp&gt;</code></li> <li><code>#include \"constants.hpp\"</code></li> <li><code>#include \"pin.hpp\"</code></li> </ul>"},{"location":"api/libhal-lpc40_2spi_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP"},{"location":"api/libhal-lpc40_2spi_8hpp/#classes","title":"Classes","text":"Type Name class spi struct bus_info Information used to configure the spi bus. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/spi.hpp</code></p>"},{"location":"api/libhal-lpc40_2spi_8hpp_source/","title":"File spi.hpp","text":"<p>File List &gt; include &gt; libhal-lpc40 &gt; spi.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;cstdint&gt;\n#include &lt;span&gt;\n\n#include &lt;libhal/spi.hpp&gt;\n\n#include \"constants.hpp\"\n#include \"pin.hpp\"\n\nnamespace hal::lpc40 {\nclass spi : public hal::spi\n{\npublic:\n  struct bus_info\n  {\n    peripheral peripheral_id;\n    pin clock;\n    pin data_out;\n    pin data_in;\n    std::uint8_t clock_function;\n    std::uint8_t data_out_function;\n    std::uint8_t data_in_function;\n  };\n\n  static result&lt;spi&gt; get(std::uint8_t p_bus,\n                         const spi::settings&amp; p_settings = {});\n\n  spi(spi&amp; p_other) = delete;\n  spi&amp; operator=(spi&amp; p_other) = delete;\n  spi(spi&amp;&amp; p_other) noexcept;\n  spi&amp; operator=(spi&amp;&amp; p_other) noexcept;\n  ~spi();\n\nprivate:\n  spi(bus_info p_bus);\n\n  status driver_configure(const settings&amp; p_settings) override;\n  result&lt;transfer_t&gt; driver_transfer(std::span&lt;const hal::byte&gt; p_data_out,\n                                     std::span&lt;hal::byte&gt; p_data_in,\n                                     hal::byte p_filler) override;\n\n  bus_info m_info;\n  bool m_moved = false;\n};\n}  // namespace hal::lpc40\n</code></pre>"},{"location":"api/uart_8hpp/","title":"File uart.hpp","text":"<p>FileList &gt; include &gt; libhal-lpc40 &gt; uart.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/serial.hpp&gt;</code></li> <li><code>#include &lt;nonstd/ring_span.hpp&gt;</code></li> <li><code>#include \"constants.hpp\"</code></li> <li><code>#include \"pin.hpp\"</code></li> </ul>"},{"location":"api/uart_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP"},{"location":"api/uart_8hpp/#classes","title":"Classes","text":"Type Name class uart Implementation of the UART peripheral for the LPC40xx family of microcontrollers. struct port <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-lpc40/uart.hpp</code></p>"},{"location":"api/uart_8hpp_source/","title":"File uart.hpp","text":"<p>File List &gt; include &gt; libhal-lpc40 &gt; uart.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/serial.hpp&gt;\n#include &lt;nonstd/ring_span.hpp&gt;\n\n#include \"constants.hpp\"\n#include \"pin.hpp\"\n\nnamespace hal::lpc40 {\nclass uart : public hal::serial\n{\npublic:\n  struct port\n  {\n    peripheral id;\n    irq irq_number;\n    pin tx;\n    pin rx;\n    std::uint8_t tx_function;\n    std::uint8_t rx_function;\n  };\n\n  static result&lt;uart&gt; get(std::uint8_t p_port_number,\n                          std::span&lt;hal::byte&gt; p_receive_buffer,\n                          serial::settings p_settings = {});\n\n  static result&lt;uart&gt; construct_custom(\n    uart::port p_port,\n    std::span&lt;hal::byte&gt; p_receive_working_buffer,\n    serial::settings p_settings = {});\n\n  uart(uart&amp; p_other) = delete;\n  uart&amp; operator=(uart&amp; p_other) = delete;\n  uart(uart&amp;&amp; p_other) noexcept;\n  uart&amp; operator=(uart&amp;&amp; p_other) noexcept;\n\nprivate:\n  explicit uart(const port&amp; p_port, std::span&lt;hal::byte&gt; p_receive_buffer);\n\n  status driver_configure(const settings&amp; p_settings) override;\n  result&lt;write_t&gt; driver_write(std::span&lt;const hal::byte&gt; p_data) override;\n  result&lt;read_t&gt; driver_read(std::span&lt;hal::byte&gt; p_data) override;\n  result&lt;flush_t&gt; driver_flush() override;\n\n  void setup_receive_interrupt();\n  void interrupt_handler();\n\n  port m_port;\n  nonstd::ring_span&lt;hal::byte&gt; m_receive_buffer;\n};\n}  // namespace hal::lpc40\n</code></pre>"},{"location":"api/dir_3d3c07370f433c90fd72adf4c7e715ce/","title":"Dir libraries/include/libhal-micromod","text":"<p>FileList &gt; include &gt; libhal-micromod</p>"},{"location":"api/dir_3d3c07370f433c90fd72adf4c7e715ce/#files","title":"Files","text":"Type Name file micromod.hpp <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-micromod/</code></p>"},{"location":"api/micromod_8hpp/","title":"File micromod.hpp","text":"<p>FileList &gt; include &gt; libhal-micromod &gt; micromod.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/adc.hpp&gt;</code></li> <li><code>#include &lt;libhal/can.hpp&gt;</code></li> <li><code>#include &lt;libhal/dac.hpp&gt;</code></li> <li><code>#include &lt;libhal/i2c.hpp&gt;</code></li> <li><code>#include &lt;libhal/input_pin.hpp&gt;</code></li> <li><code>#include &lt;libhal/interrupt_pin.hpp&gt;</code></li> <li><code>#include &lt;libhal/output_pin.hpp&gt;</code></li> <li><code>#include &lt;libhal/pwm.hpp&gt;</code></li> <li><code>#include &lt;libhal/serial.hpp&gt;</code></li> <li><code>#include &lt;libhal/spi.hpp&gt;</code></li> <li><code>#include &lt;libhal/steady_clock.hpp&gt;</code></li> <li><code>#include &lt;libhal/timer.hpp&gt;</code></li> </ul>"},{"location":"api/micromod_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace micromod namespace v1 <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-micromod/micromod.hpp</code></p>"},{"location":"api/micromod_8hpp_source/","title":"File micromod.hpp","text":"<p>File List &gt; include &gt; libhal-micromod &gt; micromod.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/adc.hpp&gt;\n#include &lt;libhal/can.hpp&gt;\n#include &lt;libhal/dac.hpp&gt;\n#include &lt;libhal/i2c.hpp&gt;\n#include &lt;libhal/input_pin.hpp&gt;\n#include &lt;libhal/interrupt_pin.hpp&gt;\n#include &lt;libhal/output_pin.hpp&gt;\n#include &lt;libhal/pwm.hpp&gt;\n#include &lt;libhal/serial.hpp&gt;\n#include &lt;libhal/spi.hpp&gt;\n#include &lt;libhal/steady_clock.hpp&gt;\n#include &lt;libhal/timer.hpp&gt;\n\nnamespace hal::micromod::v1 {\n// =============================================================================\n// CORE\n// =============================================================================\n\nvoid initialize_platform();\n\nhal::steady_clock&amp; uptime_clock();\n\nhal::timer&amp; system_timer();\n\nvoid enter_power_saving_mode();\n\nhal::serial&amp; console(std::span&lt;hal::byte&gt; p_receive_buffer);\n\n[[noreturn]] void reset();\n\n// =============================================================================\n// ON CHIP DEVICES\n// =============================================================================\n\nhal::output_pin&amp; led();\n\n// =============================================================================\n// ANALOG\n// =============================================================================\n\nhal::adc&amp; a0();\n\nhal::adc&amp; a1();\n\nhal::adc&amp; battery();\n\nhal::dac&amp; d0();\n\nhal::dac&amp; d1();\n\nhal::pwm&amp; pwm0();\n\nhal::pwm&amp; pwm1();\n\n// =============================================================================\n// Serial Communication\n// =============================================================================\n\nhal::i2c&amp; i2c();\n\nhal::interrupt_pin&amp; i2c_interrupt_pin();\n\nhal::i2c&amp; i2c1();\n\nhal::spi&amp; spi();\n\nhal::interrupt_pin&amp; spi_interrupt_pin();\n\nhal::spi&amp; spi1();\n\nhal::serial&amp; uart1(std::span&lt;hal::byte&gt; p_receive_buffer);\n\nhal::serial&amp; uart2(std::span&lt;hal::byte&gt; p_receive_buffer);\n\nhal::can&amp; can();\n\n// =============================================================================\n// DIGITAL\n// =============================================================================\n\nhal::output_pin&amp; output_g0();\nhal::output_pin&amp; output_g1();\nhal::output_pin&amp; output_g2();\nhal::output_pin&amp; output_g3();\nhal::output_pin&amp; output_g4();\nhal::output_pin&amp; output_g5();\nhal::output_pin&amp; output_g6();\nhal::output_pin&amp; output_g7();\nhal::output_pin&amp; output_g8();\nhal::output_pin&amp; output_g9();\nhal::output_pin&amp; output_g10();\n\nhal::input_pin&amp; input_g0();\nhal::input_pin&amp; input_g1();\nhal::input_pin&amp; input_g2();\nhal::input_pin&amp; input_g3();\nhal::input_pin&amp; input_g4();\nhal::input_pin&amp; input_g5();\nhal::input_pin&amp; input_g6();\nhal::input_pin&amp; input_g7();\nhal::input_pin&amp; input_g8();\nhal::input_pin&amp; input_g9();\nhal::input_pin&amp; input_g10();\n\nhal::interrupt_pin&amp; interrupt_g0();\nhal::interrupt_pin&amp; interrupt_g1();\nhal::interrupt_pin&amp; interrupt_g2();\nhal::interrupt_pin&amp; interrupt_g3();\nhal::interrupt_pin&amp; interrupt_g4();\nhal::interrupt_pin&amp; interrupt_g5();\nhal::interrupt_pin&amp; interrupt_g6();\nhal::interrupt_pin&amp; interrupt_g7();\nhal::interrupt_pin&amp; interrupt_g8();\nhal::interrupt_pin&amp; interrupt_g9();\nhal::interrupt_pin&amp; interrupt_g10();\n}  // namespace hal::micromod::v1\n</code></pre>"},{"location":"api/dir_24679974995b72317f1fb09ac5dd2fb9/","title":"Dir libraries/include/libhal-mock","text":"<p>FileList &gt; include &gt; libhal-mock</p>"},{"location":"api/dir_24679974995b72317f1fb09ac5dd2fb9/#files","title":"Files","text":"Type Name file adc.hpp file can.hpp file dac.hpp file input_pin.hpp file interrupt_pin.hpp file motor.hpp file output_pin.hpp file pwm.hpp file spi.hpp file steady_clock.hpp file testing.hpp file timer.hpp <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/</code></p>"},{"location":"api/libhal-mock_2adc_8hpp/","title":"File adc.hpp","text":"<p>FileList &gt; include &gt; libhal-mock &gt; adc.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/adc.hpp&gt;</code></li> <li><code>#include &lt;queue&gt;</code></li> </ul>"},{"location":"api/libhal-mock_2adc_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace mock"},{"location":"api/libhal-mock_2adc_8hpp/#classes","title":"Classes","text":"Type Name struct adc Mock adc implementation for use in unit tests and simulations. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/adc.hpp</code></p>"},{"location":"api/libhal-mock_2adc_8hpp_source/","title":"File adc.hpp","text":"<p>File List &gt; include &gt; libhal-mock &gt; adc.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/adc.hpp&gt;\n#include &lt;queue&gt;\n\nnamespace hal::mock {\nstruct adc : public hal::adc\n{\n  void set(std::queue&lt;read_t&gt;&amp; p_adc_values)\n  {\n    m_adc_values = p_adc_values;\n  }\n\nprivate:\n  result&lt;read_t&gt; driver_read() override\n  {\n    if (m_adc_values.size() == 0) {\n      return hal::new_error(std::out_of_range(\"floats queue is empty!\"));\n    }\n    auto m_current_value = m_adc_values.front();\n    m_adc_values.pop();\n    return m_current_value;\n  }\n\n  std::queue&lt;read_t&gt; m_adc_values{};\n};\n}  // namespace hal::mock\n</code></pre>"},{"location":"api/libhal-mock_2can_8hpp/","title":"File can.hpp","text":"<p>FileList &gt; include &gt; libhal-mock &gt; can.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"testing.hpp\"</code></li> <li><code>#include &lt;libhal/can.hpp&gt;</code></li> <li><code>#include &lt;libhal/functional.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-mock_2can_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace mock"},{"location":"api/libhal-mock_2can_8hpp/#classes","title":"Classes","text":"Type Name struct can Mock can implementation for use in unit tests and simulations."},{"location":"api/libhal-mock_2can_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::basic_ostream&lt; CharT, Traits &gt; &amp; operator&lt;&lt; (std::basic_ostream&lt; CharT, Traits &gt; &amp; p_ostream, const hal::can::message_t &amp; p_message) print can::message_t type using ostreams"},{"location":"api/libhal-mock_2can_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/libhal-mock_2can_8hpp/#function-operator","title":"function operator&lt;&lt;","text":"<p>print can::message_t type using ostreams <pre><code>template&lt;class CharT class CharT, class Traits class Traits&gt;\nstd::basic_ostream&lt; CharT, Traits &gt; &amp; operator&lt;&lt; (\n    std::basic_ostream&lt; CharT, Traits &gt; &amp; p_ostream,\n    const hal::can::message_t &amp; p_message\n) \n</code></pre></p> <p>Meant for unit testing, testing and simulation purposes C++ streams, in general, should not be used for any embedded project that will ever have to be used on an MCU due to its memory cost.</p> <p>Template parameters:</p> <ul> <li><code>CharT</code> - character type </li> <li><code>Traits</code> - ostream traits type </li> </ul> <p>Parameters:</p> <ul> <li><code>p_ostream</code> - the ostream </li> <li><code>p_message</code> - object to convert to a string </li> </ul> <p>Returns:</p> <p>std::basic_ostream&lt;CharT, Traits&gt;&amp; - reference to the ostream </p> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/can.hpp</code></p>"},{"location":"api/libhal-mock_2can_8hpp_source/","title":"File can.hpp","text":"<p>File List &gt; include &gt; libhal-mock &gt; can.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"testing.hpp\"\n#include &lt;libhal/can.hpp&gt;\n#include &lt;libhal/functional.hpp&gt;\n\nnamespace hal::mock {\nstruct can : public hal::can\n{\n  void reset()\n  {\n    spy_configure.reset();\n    spy_send.reset();\n    spy_on_receive.reset();\n    spy_bus_on.reset();\n  }\n\n  spy_handler&lt;settings&gt; spy_configure;\n  spy_handler&lt;message_t&gt; spy_send;\n  spy_handler&lt;bool&gt; spy_bus_on;\n  spy_handler&lt;hal::callback&lt;handler&gt;&gt; spy_on_receive;\n\nprivate:\n  status driver_configure(const settings&amp; p_settings) override\n  {\n    return spy_configure.record(p_settings);\n  }\n\n  status driver_bus_on() override\n  {\n    return spy_bus_on.record(true);\n  }\n\n  result&lt;send_t&gt; driver_send(const message_t&amp; p_message) override\n  {\n    HAL_CHECK(spy_send.record(p_message));\n    return send_t{};\n  }\n\n  void driver_on_receive(hal::callback&lt;handler&gt; p_handler) override\n  {\n    (void)spy_on_receive.record(p_handler);\n  }\n};\n}  // namespace hal::mock\n\ntemplate&lt;class CharT, class Traits&gt;\nstd::basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(\n  std::basic_ostream&lt;CharT, Traits&gt;&amp; p_ostream,\n  const hal::can::message_t&amp; p_message)\n{\n  p_ostream &lt;&lt; \"{ id: \" &lt;&lt; std::hex &lt;&lt; \"0x\" &lt;&lt; p_message.id;\n  p_ostream &lt;&lt; \", length: \" &lt;&lt; std::dec &lt;&lt; unsigned{ p_message.length };\n  p_ostream &lt;&lt; \", is_remote_request: \" &lt;&lt; p_message.is_remote_request;\n  p_ostream &lt;&lt; \", payload = [\";\n  for (const auto&amp; element : p_message.payload) {\n    p_ostream &lt;&lt; std::hex &lt;&lt; \"0x\" &lt;&lt; unsigned{ element } &lt;&lt; \", \";\n  }\n  p_ostream &lt;&lt; \"] }\";\n  return p_ostream;\n}\n</code></pre>"},{"location":"api/libhal-mock_2dac_8hpp/","title":"File dac.hpp","text":"<p>FileList &gt; include &gt; libhal-mock &gt; dac.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"testing.hpp\"</code></li> <li><code>#include &lt;libhal/dac.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-mock_2dac_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace mock"},{"location":"api/libhal-mock_2dac_8hpp/#classes","title":"Classes","text":"Type Name struct dac Mock dac implementation for use in unit tests and simulations with a spy function for write() __ <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/dac.hpp</code></p>"},{"location":"api/libhal-mock_2dac_8hpp_source/","title":"File dac.hpp","text":"<p>File List &gt; include &gt; libhal-mock &gt; dac.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"testing.hpp\"\n#include &lt;libhal/dac.hpp&gt;\n\nnamespace hal::mock {\nstruct dac : public hal::dac\n{\n  void reset()\n  {\n    spy_write.reset();\n  }\n\n  spy_handler&lt;float&gt; spy_write;\n\nprivate:\n  result&lt;write_t&gt; driver_write(float p_value) override\n  {\n    HAL_CHECK(spy_write.record(p_value));\n    return write_t{};\n  };\n};\n}  // namespace hal::mock\n</code></pre>"},{"location":"api/libhal-mock_2input__pin_8hpp/","title":"File input_pin.hpp","text":"<p>FileList &gt; include &gt; libhal-mock &gt; input_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;queue&gt;</code></li> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include \"testing.hpp\"</code></li> <li><code>#include &lt;libhal/input_pin.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-mock_2input__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace mock"},{"location":"api/libhal-mock_2input__pin_8hpp/#classes","title":"Classes","text":"Type Name struct input_pin mock input_pin implementation for use in unit tests and simulations. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/input_pin.hpp</code></p>"},{"location":"api/libhal-mock_2input__pin_8hpp_source/","title":"File input_pin.hpp","text":"<p>File List &gt; include &gt; libhal-mock &gt; input_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;queue&gt;\n#include &lt;stdexcept&gt;\n\n#include \"testing.hpp\"\n#include &lt;libhal/input_pin.hpp&gt;\n\nnamespace hal::mock {\nstruct input_pin : public hal::input_pin\n{\n  void reset()\n  {\n    spy_configure.reset();\n  }\n\n  spy_handler&lt;settings&gt; spy_configure;\n\n  void set(std::queue&lt;level_t&gt;&amp; p_levels)\n  {\n    m_levels = p_levels;\n  }\n\nprivate:\n  status driver_configure(const settings&amp; p_settings) override\n  {\n    return spy_configure.record(p_settings);\n  }\n  result&lt;level_t&gt; driver_level() override\n  {\n    // This comparison performs bounds checking because front() and pop() do\n    // not bounds check and results in undefined behavior if the queue is empty.\n    if (m_levels.size() == 0) {\n      return hal::new_error(\n        std::out_of_range(\"input_pin level queue is empty!\"));\n    }\n    auto m_current_value = m_levels.front();\n    m_levels.pop();\n    return m_current_value;\n  }\n\n  std::queue&lt;level_t&gt; m_levels{};\n};\n}  // namespace hal::mock\n</code></pre>"},{"location":"api/libhal-mock_2interrupt__pin_8hpp/","title":"File interrupt_pin.hpp","text":"<p>FileList &gt; include &gt; libhal-mock &gt; interrupt_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"testing.hpp\"</code></li> <li><code>#include &lt;libhal/interrupt_pin.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-mock_2interrupt__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace mock"},{"location":"api/libhal-mock_2interrupt__pin_8hpp/#classes","title":"Classes","text":"Type Name struct interrupt_pin mock interrupt_pin implementation for use in unit tests and simulations. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/interrupt_pin.hpp</code></p>"},{"location":"api/libhal-mock_2interrupt__pin_8hpp_source/","title":"File interrupt_pin.hpp","text":"<p>File List &gt; include &gt; libhal-mock &gt; interrupt_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"testing.hpp\"\n#include &lt;libhal/interrupt_pin.hpp&gt;\n\nnamespace hal::mock {\nstruct interrupt_pin : public hal::interrupt_pin\n{\n  void reset()\n  {\n    spy_configure.reset();\n    spy_on_trigger.reset();\n  }\n\n  spy_handler&lt;settings&gt; spy_configure;\n  spy_handler&lt;std::function&lt;handler&gt;&gt; spy_on_trigger;\n\nprivate:\n  status driver_configure(const settings&amp; p_settings) override\n  {\n    return spy_configure.record(p_settings);\n  }\n  void driver_on_trigger(hal::callback&lt;handler&gt; p_callback) override\n  {\n    [[maybe_unused]] auto result = spy_on_trigger.record(p_callback);\n  }\n};\n}  // namespace hal::mock\n</code></pre>"},{"location":"api/libhal-mock_2motor_8hpp/","title":"File motor.hpp","text":"<p>FileList &gt; include &gt; libhal-mock &gt; motor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"testing.hpp\"</code></li> <li><code>#include &lt;libhal/motor.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-mock_2motor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace mock"},{"location":"api/libhal-mock_2motor_8hpp/#classes","title":"Classes","text":"Type Name struct motor Mock motor implementation for use in unit tests and simulations with a spy function for power() __ <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/motor.hpp</code></p>"},{"location":"api/libhal-mock_2motor_8hpp_source/","title":"File motor.hpp","text":"<p>File List &gt; include &gt; libhal-mock &gt; motor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"testing.hpp\"\n#include &lt;libhal/motor.hpp&gt;\n\nnamespace hal::mock {\nstruct motor : public hal::motor\n{\n  void reset()\n  {\n    spy_power.reset();\n  }\n\n  spy_handler&lt;float&gt; spy_power;\n\nprivate:\n  result&lt;power_t&gt; driver_power(float p_power) override\n  {\n    HAL_CHECK(spy_power.record(p_power));\n    return power_t{};\n  };\n};\n}  // namespace hal::mock\n</code></pre>"},{"location":"api/libhal-mock_2output__pin_8hpp/","title":"File output_pin.hpp","text":"<p>FileList &gt; include &gt; libhal-mock &gt; output_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"testing.hpp\"</code></li> <li><code>#include &lt;libhal/output_pin.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-mock_2output__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace mock"},{"location":"api/libhal-mock_2output__pin_8hpp/#classes","title":"Classes","text":"Type Name struct output_pin mock output pin for use in unit tests and simulations <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/output_pin.hpp</code></p>"},{"location":"api/libhal-mock_2output__pin_8hpp_source/","title":"File output_pin.hpp","text":"<p>File List &gt; include &gt; libhal-mock &gt; output_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"testing.hpp\"\n#include &lt;libhal/output_pin.hpp&gt;\n\nnamespace hal::mock {\nstruct output_pin : public hal::output_pin\n{\n  void reset()\n  {\n    spy_configure.reset();\n    spy_level.reset();\n  }\n\n  spy_handler&lt;settings&gt; spy_configure;\n  spy_handler&lt;level_t&gt; spy_level;\n\nprivate:\n  status driver_configure(const settings&amp; p_settings) override\n  {\n    return spy_configure.record(p_settings);\n  }\n  result&lt;set_level_t&gt; driver_level(bool p_high) override\n  {\n    m_current_level.state = p_high;\n    HAL_CHECK(spy_level.record(m_current_level));\n    return set_level_t{};\n  }\n  result&lt;level_t&gt; driver_level() override\n  {\n    return m_current_level;\n  }\n  level_t m_current_level{ .state = false };\n};\n}  // namespace hal::mock\n</code></pre>"},{"location":"api/libhal-mock_2pwm_8hpp/","title":"File pwm.hpp","text":"<p>FileList &gt; include &gt; libhal-mock &gt; pwm.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"testing.hpp\"</code></li> <li><code>#include &lt;libhal/pwm.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-mock_2pwm_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace mock"},{"location":"api/libhal-mock_2pwm_8hpp/#classes","title":"Classes","text":"Type Name struct pwm Mock pwm implementation for use in unit tests and simulations with spy functions for frequency() andduty_cycle() . <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/pwm.hpp</code></p>"},{"location":"api/libhal-mock_2pwm_8hpp_source/","title":"File pwm.hpp","text":"<p>File List &gt; include &gt; libhal-mock &gt; pwm.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"testing.hpp\"\n#include &lt;libhal/pwm.hpp&gt;\n\nnamespace hal::mock {\nstruct pwm : public hal::pwm\n{\n  void reset()\n  {\n    spy_frequency.reset();\n    spy_duty_cycle.reset();\n  }\n\n  spy_handler&lt;hertz&gt; spy_frequency;\n  spy_handler&lt;float&gt; spy_duty_cycle;\n\nprivate:\n  result&lt;frequency_t&gt; driver_frequency(hertz p_settings) override\n  {\n    HAL_CHECK(spy_frequency.record(p_settings));\n    return frequency_t{};\n  }\n\n  result&lt;duty_cycle_t&gt; driver_duty_cycle(float p_duty_cycle) override\n  {\n    HAL_CHECK(spy_duty_cycle.record(p_duty_cycle));\n\n    return duty_cycle_t{};\n  }\n};\n}  // namespace hal::mock\n</code></pre>"},{"location":"api/libhal-mock_2spi_8hpp/","title":"File spi.hpp","text":"<p>FileList &gt; include &gt; libhal-mock &gt; spi.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"testing.hpp\"</code></li> <li><code>#include &lt;libhal/spi.hpp&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-mock_2spi_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace mock"},{"location":"api/libhal-mock_2spi_8hpp/#classes","title":"Classes","text":"Type Name struct write_only_spi Mock spi implementation for use in unit tests and simulations with a spy functions for configure() and a record for thetransfer() out data. The record ignores the in buffer and just stores the data being sent so it can be inspected later. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/spi.hpp</code></p>"},{"location":"api/libhal-mock_2spi_8hpp_source/","title":"File spi.hpp","text":"<p>File List &gt; include &gt; libhal-mock &gt; spi.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"testing.hpp\"\n#include &lt;libhal/spi.hpp&gt;\n#include &lt;libhal/units.hpp&gt;\n\nnamespace hal::mock {\nstruct write_only_spi : public hal::spi\n{\n  void reset()\n  {\n    spy_configure.reset();\n    write_record.clear();\n  }\n\n  spy_handler&lt;settings&gt; spy_configure;\n  std::vector&lt;std::vector&lt;hal::byte&gt;&gt; write_record;\n\nprivate:\n  status driver_configure(const settings&amp; p_settings) override\n  {\n    return spy_configure.record(p_settings);\n  };\n\n  result&lt;transfer_t&gt; driver_transfer(\n    std::span&lt;const hal::byte&gt; p_data_out,\n    [[maybe_unused]] std::span&lt;hal::byte&gt; p_data_in,\n    [[maybe_unused]] hal::byte p_filler) override\n  {\n    write_record.push_back({ p_data_out.begin(), p_data_out.end() });\n    return transfer_t{};\n  };\n};\n}  // namespace hal::mock\n</code></pre>"},{"location":"api/libhal-mock_2steady__clock_8hpp/","title":"File steady_clock.hpp","text":"<p>FileList &gt; include &gt; libhal-mock &gt; steady_clock.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;queue&gt;</code></li> <li><code>#include &lt;libhal/steady_clock.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-mock_2steady__clock_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace mock"},{"location":"api/libhal-mock_2steady__clock_8hpp/#classes","title":"Classes","text":"Type Name struct steady_clock mock steady_clock implementation for use in unit tests and simulations. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/steady_clock.hpp</code></p>"},{"location":"api/libhal-mock_2steady__clock_8hpp_source/","title":"File steady_clock.hpp","text":"<p>File List &gt; include &gt; libhal-mock &gt; steady_clock.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;queue&gt;\n\n#include &lt;libhal/steady_clock.hpp&gt;\n\nnamespace hal::mock {\nstruct steady_clock : public hal::steady_clock\n{\n  void set_frequency(frequency_t p_frequency)\n  {\n    m_frequency = p_frequency;\n  }\n\n  void set_uptimes(std::queue&lt;uptime_t&gt;&amp; p_uptime_values)\n  {\n    m_uptime_values = p_uptime_values;\n  }\n\nprivate:\n  frequency_t driver_frequency()\n  {\n    return m_frequency;\n  }\n\n  uptime_t driver_uptime()\n  {\n    if (m_uptime_values.size() == 0) {\n      return m_last_uptime;\n    }\n\n    m_last_uptime = m_uptime_values.front();\n    m_uptime_values.pop();\n    return m_last_uptime;\n  }\n\n  frequency_t m_frequency{ .operating_frequency = 1.0_Hz };\n  std::queue&lt;uptime_t&gt; m_uptime_values{};\n  uptime_t m_last_uptime{};\n};\n}  // namespace hal::mock\n</code></pre>"},{"location":"api/testing_8hpp/","title":"File testing.hpp","text":"<p>FileList &gt; include &gt; libhal-mock &gt; testing.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;ios&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include &lt;libhal/error.hpp&gt;</code></li> </ul>"},{"location":"api/testing_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/testing_8hpp/#classes","title":"Classes","text":"Type Name class spy_handler &lt;args_t&gt;Helper utility for making mocks for class functions that return status."},{"location":"api/testing_8hpp/#public-functions","title":"Public Functions","text":"Type Name std::ostream &amp; operator&lt;&lt; (std::ostream &amp; p_os, const std::chrono::duration&lt; Rep, Period &gt; &amp; p_duration)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; p_os, const std::array&lt; T, size &gt; &amp; p_array)  std::ostream &amp; operator&lt;&lt; (std::ostream &amp; p_os, const std::span&lt; T &gt; &amp; p_array)"},{"location":"api/testing_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/testing_8hpp/#function-operator","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename Rep typename Rep, typename Period typename Period&gt;\ninline std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; p_os,\n    const std::chrono::duration&lt; Rep, Period &gt; &amp; p_duration\n) \n</code></pre>"},{"location":"api/testing_8hpp/#function-operator_1","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T typename T, size_t size&gt;\ninline std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; p_os,\n    const std::array&lt; T, size &gt; &amp; p_array\n) \n</code></pre>"},{"location":"api/testing_8hpp/#function-operator_2","title":"function operator&lt;&lt;","text":"<pre><code>template&lt;typename T typename T&gt;\ninline std::ostream &amp; operator&lt;&lt; (\n    std::ostream &amp; p_os,\n    const std::span&lt; T &gt; &amp; p_array\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/testing.hpp</code></p>"},{"location":"api/testing_8hpp_source/","title":"File testing.hpp","text":"<p>File List &gt; include &gt; libhal-mock &gt; testing.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;chrono&gt;\n#include &lt;ios&gt;\n#include &lt;span&gt;\n#include &lt;tuple&gt;\n#include &lt;vector&gt;\n\n#include &lt;libhal/error.hpp&gt;\n\nnamespace hal {\ntemplate&lt;typename... args_t&gt;\nclass spy_handler\n{\npublic:\n  void trigger_error_on_call(int p_call_count_before_trigger)\n  {\n    if (p_call_count_before_trigger &lt; 0) {\n      throw std::range_error(\"trigger_error_on_call() must be 0 or above\");\n    }\n    m_error_trigger = p_call_count_before_trigger;\n  }\n\n  [[nodiscard]] status record(args_t... p_args)\n  {\n    m_call_history.push_back(std::make_tuple(p_args...));\n\n    if (m_error_trigger &gt; 1) {\n      m_error_trigger--;\n    } else if (m_error_trigger == 1) {\n      m_error_trigger--;\n      return hal::new_error();\n    }\n\n    return hal::success();\n  }\n\n  const auto&amp; call_history() const\n  {\n    return m_call_history;\n  }\n\n  template&lt;size_t ArgumentIndex&gt;\n  const auto&amp; history(size_t p_call) const\n  {\n    return std::get&lt;ArgumentIndex&gt;(m_call_history.at(p_call));\n  }\n\n  void reset()\n  {\n    m_call_history.clear();\n    m_error_trigger = 0;\n  }\n\nprivate:\n  std::vector&lt;std::tuple&lt;args_t...&gt;&gt; m_call_history{};\n  int m_error_trigger = 0;\n};\n}  // namespace hal\n\ntemplate&lt;typename Rep, typename Period&gt;\ninline std::ostream&amp; operator&lt;&lt;(\n  std::ostream&amp; p_os,\n  const std::chrono::duration&lt;Rep, Period&gt;&amp; p_duration)\n{\n  return p_os &lt;&lt; p_duration.count() &lt;&lt; \" * (\" &lt;&lt; Period::num &lt;&lt; \"/\"\n              &lt;&lt; Period::den &lt;&lt; \")s\";\n}\n\ntemplate&lt;typename T, size_t size&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; p_os,\n                                const std::array&lt;T, size&gt;&amp; p_array)\n{\n  p_os &lt;&lt; \"{\";\n  for (const auto&amp; element : p_array) {\n    p_os &lt;&lt; element &lt;&lt; \", \";\n  }\n  return p_os &lt;&lt; \"}\\n\";\n}\n\ntemplate&lt;typename T&gt;\ninline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; p_os, const std::span&lt;T&gt;&amp; p_array)\n{\n  p_os &lt;&lt; \"{\";\n  for (const auto&amp; element : p_array) {\n    p_os &lt;&lt; element &lt;&lt; \", \";\n  }\n  return p_os &lt;&lt; \"}\\n\";\n}\n</code></pre>"},{"location":"api/libhal-mock_2timer_8hpp/","title":"File timer.hpp","text":"<p>FileList &gt; include &gt; libhal-mock &gt; timer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"testing.hpp\"</code></li> <li><code>#include &lt;libhal/functional.hpp&gt;</code></li> <li><code>#include &lt;libhal/timer.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-mock_2timer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace mock"},{"location":"api/libhal-mock_2timer_8hpp/#classes","title":"Classes","text":"Type Name struct timer Mock timer implementation for use in unit tests and simulations with spy functions for schedule() , clear(), andis_running() __ <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mock/timer.hpp</code></p>"},{"location":"api/libhal-mock_2timer_8hpp_source/","title":"File timer.hpp","text":"<p>File List &gt; include &gt; libhal-mock &gt; timer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"testing.hpp\"\n#include &lt;libhal/functional.hpp&gt;\n#include &lt;libhal/timer.hpp&gt;\n\nnamespace hal::mock {\nstruct timer : public hal::timer\n{\n  void reset()\n  {\n    spy_schedule.reset();\n    spy_cancel.reset();\n    spy_is_running.reset();\n  }\n\n  spy_handler&lt;std::function&lt;void(void)&gt;, std::chrono::nanoseconds&gt; spy_schedule;\n  spy_handler&lt;bool&gt; spy_is_running;\n  spy_handler&lt;bool&gt; spy_cancel;\n\nprivate:\n  result&lt;schedule_t&gt; driver_schedule(hal::callback&lt;void(void)&gt; p_callback,\n                                     std::chrono::nanoseconds p_delay) override\n  {\n    m_is_running = true;\n    HAL_CHECK(spy_schedule.record(p_callback, p_delay));\n    return schedule_t{};\n  }\n\n  result&lt;is_running_t&gt; driver_is_running() override\n  {\n    auto result = spy_is_running.record(true);\n    if (!result) {\n      return result.error();\n    }\n    return is_running_t{ .is_running = m_is_running };\n  }\n\n  result&lt;cancel_t&gt; driver_cancel() override\n  {\n    m_is_running = false;\n\n    HAL_CHECK(spy_cancel.record(true));\n\n    return cancel_t{};\n  }\n\n  bool m_is_running = false;\n};\n}  // namespace hal::mock\n</code></pre>"},{"location":"api/dir_938956f748520abcfe48f1edd19c1957/","title":"Dir libraries/include/libhal-mpl","text":"<p>FileList &gt; include &gt; libhal-mpl</p>"},{"location":"api/dir_938956f748520abcfe48f1edd19c1957/#files","title":"Files","text":"Type Name file mpl3115a2.hpp <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mpl/</code></p>"},{"location":"api/mpl3115a2_8hpp/","title":"File mpl3115a2.hpp","text":"<p>FileList &gt; include &gt; libhal-mpl &gt; mpl3115a2.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/i2c.hpp&gt;</code></li> <li><code>#include &lt;libhal/timeout.hpp&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> </ul>"},{"location":"api/mpl3115a2_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace mpl"},{"location":"api/mpl3115a2_8hpp/#classes","title":"Classes","text":"Type Name class mpl3115a2 struct altitude_read_t struct pressure_read_t struct temperature_read_t <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-mpl/mpl3115a2.hpp</code></p>"},{"location":"api/mpl3115a2_8hpp_source/","title":"File mpl3115a2.hpp","text":"<p>File List &gt; include &gt; libhal-mpl &gt; mpl3115a2.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/i2c.hpp&gt;\n#include &lt;libhal/timeout.hpp&gt;\n#include &lt;libhal/units.hpp&gt;\n\nnamespace hal::mpl {\n\nclass mpl3115a2\n{\npublic:\n  /* Keep track of the current set mode bit in ctrl_reg1 */\n  enum class mode\n  {\n    barometer = 0,\n    altimeter = 1,\n  };\n\n  struct temperature_read_t\n  {\n    celsius temperature;\n  };\n\n  struct pressure_read_t\n  {\n    float pressure;  // Pascals (Pa)\n  };\n\n  struct altitude_read_t\n  {\n    meters altitude;\n  };\n\n  [[nodiscard]] static result&lt;mpl3115a2&gt; create(hal::i2c&amp; p_i2c);\n\n  [[nodiscard]] hal::result&lt;temperature_read_t&gt; read_temperature();\n\n  [[nodiscard]] hal::result&lt;pressure_read_t&gt; read_pressure();\n\n  [[nodiscard]] hal::result&lt;altitude_read_t&gt; read_altitude();\n\n  hal::status set_sea_pressure(float p_sea_level_pressure);\n\n  hal::status set_altitude_offset(int8_t p_offset);\n\n  /* Maximum number of retries for polling operations. */\n  static constexpr uint16_t default_max_polling_retries = 10000;\n\nprivate:\n  explicit mpl3115a2(hal::i2c&amp; p_i2c);\n\n  /* The I2C peripheral used for communication with the device. */\n  hal::i2c* m_i2c;\n\n  /* Variable to track current sensor mode to determine if CTRL_REG1 ALT flag\n   * needs to be set. */\n  mode m_sensor_mode;\n};\n\n}  // namespace hal::mpl\n</code></pre>"},{"location":"api/dir_3a391231662e3c35ce1f8bf907d80c4f/","title":"Dir libraries/include/libhal-rmd","text":"<p>FileList &gt; include &gt; libhal-rmd</p>"},{"location":"api/dir_3a391231662e3c35ce1f8bf907d80c4f/#files","title":"Files","text":"Type Name file drc.hpp file mc_x.hpp <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/</code></p>"},{"location":"api/drc_8hpp/","title":"File drc.hpp","text":"<p>FileList &gt; include &gt; libhal-rmd &gt; drc.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;libhal-canrouter/can_router.hpp&gt;</code></li> <li><code>#include &lt;libhal/can.hpp&gt;</code></li> <li><code>#include &lt;libhal/motor.hpp&gt;</code></li> <li><code>#include &lt;libhal/rotation_sensor.hpp&gt;</code></li> <li><code>#include &lt;libhal/servo.hpp&gt;</code></li> <li><code>#include &lt;libhal/steady_clock.hpp&gt;</code></li> <li><code>#include &lt;libhal/temperature_sensor.hpp&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> </ul>"},{"location":"api/drc_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace rmd"},{"location":"api/drc_8hpp/#classes","title":"Classes","text":"Type Name class drc Driver for RMD motors equip with the DRC motor drivers. struct feedback_t class drc_motor Motor interface adaptor for DRC. class drc_rotation_sensor Rotation sensor adaptor for DRC motors. class drc_servo Servo interface adaptor for DRC. class drc_temperature_sensor Temperature sensor adaptor for DRC motors. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/drc.hpp</code></p>"},{"location":"api/drc_8hpp_source/","title":"File drc.hpp","text":"<p>File List &gt; include &gt; libhal-rmd &gt; drc.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include &lt;libhal-canrouter/can_router.hpp&gt;\n#include &lt;libhal/can.hpp&gt;\n#include &lt;libhal/motor.hpp&gt;\n#include &lt;libhal/rotation_sensor.hpp&gt;\n#include &lt;libhal/servo.hpp&gt;\n#include &lt;libhal/steady_clock.hpp&gt;\n#include &lt;libhal/temperature_sensor.hpp&gt;\n#include &lt;libhal/units.hpp&gt;\n\nnamespace hal::rmd {\nclass drc\n{\npublic:\n  enum class read : hal::byte\n  {\n    multi_turns_angle = 0x92,\n    status_1_and_error_flags = 0x9A,\n    status_2 = 0x9C,\n  };\n\n  enum class actuate : hal::byte\n  {\n    speed = 0xA2,\n    position_2 = 0xA4,\n  };\n\n  enum class write : hal::byte\n  {\n    pid_to_ram = 0x31,\n    pid_to_rom = 0x32,\n    acceleration_data_to_ram = 0x34,\n    encoder_offset = 0x91,\n    current_position_to_rom_as_motor_zero = 0x19,\n  };\n\n  enum class system : hal::byte\n  {\n    clear_error_flag = 0x9B,\n    off = 0x80,\n    stop = 0x81,\n    running = 0x88,\n  };\n\n  struct feedback_t\n  {\n    std::uint32_t message_number = 0;\n    std::int64_t raw_multi_turn_angle{ 0 };\n    std::int16_t raw_current{ 0 };\n    std::int16_t raw_speed{ 0 };\n    std::int16_t raw_volts{ 0 };\n    std::int16_t encoder{ 0 };\n    std::int8_t raw_motor_temperature{ 0 };\n    std::uint8_t raw_error_state{ 0 };\n\n    hal::ampere current() const noexcept;\n    hal::rpm speed() const noexcept;\n    hal::volts volts() const noexcept;\n    hal::celsius temperature() const noexcept;\n    hal::degrees angle() const noexcept;\n\n    bool over_voltage_protection_tripped() const noexcept;\n\n    bool over_temperature_protection_tripped() const noexcept;\n  };\n\n  [[nodiscard]] static result&lt;drc&gt; create(\n    hal::can_router&amp; p_router,\n    hal::steady_clock&amp; p_clock,\n    float p_gear_ratio,\n    can::id_t device_id,\n    hal::time_duration p_max_response_time = std::chrono::milliseconds(10));\n\n  drc(drc&amp; p_other) = delete;\n  drc&amp; operator=(drc&amp; p_other) = delete;\n  drc(drc&amp;&amp; p_other) noexcept;\n  drc&amp; operator=(drc&amp;&amp; p_other) noexcept;\n\n  [[nodiscard]] status feedback_request(read p_command);\n\n  [[nodiscard]] status velocity_control(rpm p_speed);\n\n  [[nodiscard]] status position_control(degrees p_angle, rpm speed);\n\n  [[nodiscard]] status system_control(system p_system_command);\n\n  const feedback_t&amp; feedback() const;\n\n  void operator()(const can::message_t&amp; p_message);\n\nprivate:\n  drc(hal::can_router&amp; p_router,\n      hal::steady_clock&amp; p_clock,\n      float p_gear_ratio,\n      can::id_t p_device_id,\n      hal::time_duration p_max_response_time);\n\n  friend struct response_waiter;\n\n  feedback_t m_feedback{};\n  hal::steady_clock* m_clock;\n  hal::can_router* m_router;\n  hal::can_router::route_item m_route_item;\n  float m_gear_ratio;\n  can::id_t m_device_id;\n  hal::time_duration m_max_response_time;\n};\n\nclass drc_rotation_sensor : public hal::rotation_sensor\n{\nprivate:\n  drc_rotation_sensor(drc&amp; p_drc);\n  result&lt;hal::rotation_sensor::read_t&gt; driver_read() override;\n  friend result&lt;drc_rotation_sensor&gt; make_rotation_sensor(drc&amp; p_drc);\n  drc* m_drc = nullptr;\n};\n\nresult&lt;drc_rotation_sensor&gt; make_rotation_sensor(drc&amp; p_drc);\n\nclass drc_temperature_sensor : public hal::temperature_sensor\n{\nprivate:\n  drc_temperature_sensor(drc&amp; p_drc);\n  result&lt;read_t&gt; driver_read() override;\n  friend result&lt;drc_temperature_sensor&gt; make_temperature_sensor(drc&amp; p_drc);\n  drc* m_drc = nullptr;\n};\nresult&lt;drc_temperature_sensor&gt; make_temperature_sensor(drc&amp; p_drc);\n\nclass drc_motor : public hal::motor\n{\npublic:\n  friend result&lt;drc_motor&gt; make_motor(drc&amp; p_drc, hal::rpm p_max_speed);\n\nprivate:\n  drc_motor(drc&amp; p_drc, hal::rpm p_max_speed);\n  result&lt;power_t&gt; driver_power(float p_power) override;\n\n  drc* m_drc = nullptr;\n  hal::rpm m_max_speed;\n};\n\nresult&lt;drc_motor&gt; make_motor(drc&amp; p_drc, hal::rpm p_max_speed);\n\nclass drc_servo : public hal::servo\n{\nprivate:\n  drc_servo(drc&amp; p_drc, hal::rpm p_max_speed);\n  result&lt;position_t&gt; driver_position(hal::degrees p_position) override;\n  friend result&lt;drc_servo&gt; make_servo(drc&amp; p_drc, hal::rpm p_max_speed);\n  drc* m_drc = nullptr;\n  hal::rpm m_max_speed;\n};\n\nresult&lt;drc_servo&gt; make_servo(drc&amp; p_drc, hal::rpm p_max_speed);\n}  // namespace hal::rmd\n\nnamespace hal {\nusing rmd::make_motor;\nusing rmd::make_rotation_sensor;\nusing rmd::make_servo;\nusing rmd::make_temperature_sensor;\n}  // namespace hal\n</code></pre>"},{"location":"api/mc__x_8hpp/","title":"File mc_x.hpp","text":"<p>FileList &gt; include &gt; libhal-rmd &gt; mc_x.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;libhal-canrouter/can_router.hpp&gt;</code></li> <li><code>#include &lt;libhal/can.hpp&gt;</code></li> <li><code>#include &lt;libhal/motor.hpp&gt;</code></li> <li><code>#include &lt;libhal/rotation_sensor.hpp&gt;</code></li> <li><code>#include &lt;libhal/servo.hpp&gt;</code></li> <li><code>#include &lt;libhal/steady_clock.hpp&gt;</code></li> <li><code>#include &lt;libhal/temperature_sensor.hpp&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> </ul>"},{"location":"api/mc__x_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace rmd"},{"location":"api/mc__x_8hpp/#classes","title":"Classes","text":"Type Name class mc_x Driver for RMD series motors equip with the MC-X motor driver. struct feedback_t class mc_x_motor Control a mc_x motor driver like ahal::motor . class mc_x_rotation Reports the rotation of the DRC motor. class mc_x_servo Control a mc_x motor driver like ahal::servo . class mc_x_temperature Reports the temperature of the DRC motor. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-rmd/mc_x.hpp</code></p>"},{"location":"api/mc__x_8hpp_source/","title":"File mc_x.hpp","text":"<p>File List &gt; include &gt; libhal-rmd &gt; mc_x.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include &lt;libhal-canrouter/can_router.hpp&gt;\n#include &lt;libhal/can.hpp&gt;\n#include &lt;libhal/motor.hpp&gt;\n#include &lt;libhal/rotation_sensor.hpp&gt;\n#include &lt;libhal/servo.hpp&gt;\n#include &lt;libhal/steady_clock.hpp&gt;\n#include &lt;libhal/temperature_sensor.hpp&gt;\n#include &lt;libhal/units.hpp&gt;\n\nnamespace hal::rmd {\nclass mc_x\n{\npublic:\n  enum class read : hal::byte\n  {\n    multi_turns_angle = 0x92,\n    status_1_and_error_flags = 0x9A,\n    status_2 = 0x9C,\n  };\n\n  enum class actuate : hal::byte\n  {\n    torque = 0xA1,\n    speed = 0xA2,\n    position = 0xA5,\n  };\n\n  enum class write : hal::byte\n  {\n    // None supported currently\n  };\n\n  enum class system : hal::byte\n  {\n    off = 0x80,\n    stop = 0x81,\n  };\n\n  struct feedback_t\n  {\n    std::uint32_t message_number = 0;\n    std::int64_t raw_multi_turn_angle{ 0 };\n    std::uint16_t raw_error_state{ 0 };\n    std::int16_t raw_current{ 0 };\n    std::int16_t raw_speed{ 0 };\n    std::int16_t raw_volts{ 0 };\n    std::int16_t encoder{ 0 };\n    std::int8_t raw_motor_temperature{ 0 };\n\n    hal::ampere current() const noexcept;\n    hal::rpm speed() const noexcept;\n    hal::volts volts() const noexcept;\n    hal::celsius temperature() const noexcept;\n    hal::degrees angle() const noexcept;\n    bool motor_stall() const noexcept;\n    bool low_pressure() const noexcept;\n    bool over_voltage() const noexcept;\n    bool over_current() const noexcept;\n    bool power_overrun() const noexcept;\n    bool speeding() const noexcept;\n    bool over_temperature() const noexcept;\n    bool encoder_calibration_error() const noexcept;\n  };\n\n  [[nodiscard]] static result&lt;mc_x&gt; create(\n    hal::can_router&amp; p_router,\n    hal::steady_clock&amp; p_clock,\n    float p_gear_ratio,\n    can::id_t device_id,\n    hal::time_duration p_max_response_time = std::chrono::milliseconds(10));\n\n  mc_x(mc_x&amp; p_other) = delete;\n  mc_x&amp; operator=(mc_x&amp; p_other) = delete;\n  mc_x(mc_x&amp;&amp; p_other) noexcept;\n  mc_x&amp; operator=(mc_x&amp;&amp; p_other) noexcept;\n\n  const feedback_t&amp; feedback() const;\n\n  [[nodiscard]] status feedback_request(read p_command);\n\n  [[nodiscard]] status velocity_control(rpm p_speed);\n\n  [[nodiscard]] status position_control(degrees p_angle, rpm speed);\n\n  [[nodiscard]] status system_control(system p_system_command);\n\n  void operator()(const can::message_t&amp; p_message);\n\nprivate:\n  mc_x(hal::can_router&amp; p_router,\n       hal::steady_clock&amp; p_clock,\n       float p_gear_ratio,\n       can::id_t p_device_id,\n       hal::time_duration p_max_response_time);\n\n  friend struct response_waiter;\n\n  feedback_t m_feedback{};\n  hal::steady_clock* m_clock;\n  hal::can_router* m_router;\n  hal::can_router::route_item m_route_item;\n  float m_gear_ratio;\n  can::id_t m_device_id;\n  hal::time_duration m_max_response_time;\n};\n\nclass mc_x_motor : public hal::motor\n{\nprivate:\n  mc_x_motor(mc_x&amp; p_mc_x, hal::rpm p_max_speed);\n  result&lt;hal::motor::power_t&gt; driver_power(float p_power) override;\n  friend result&lt;mc_x_motor&gt; make_motor(mc_x&amp; p_mc_x, hal::rpm p_max_speed);\n  mc_x* m_mc_x = nullptr;\n  hal::rpm m_max_speed;\n};\n\nresult&lt;mc_x_motor&gt; make_motor(mc_x&amp; p_mc_x, hal::rpm p_max_speed);\n\nclass mc_x_rotation : public hal::rotation_sensor\n{\nprivate:\n  mc_x_rotation(mc_x&amp; p_mc_x);\n  result&lt;hal::rotation_sensor::read_t&gt; driver_read() override;\n  friend result&lt;mc_x_rotation&gt; make_rotation_sensor(mc_x&amp; p_mc_x);\n  mc_x* m_mc_x = nullptr;\n};\n\nresult&lt;mc_x_rotation&gt; make_rotation_sensor(mc_x&amp; p_mc_x);\n\nclass mc_x_servo : public hal::servo\n{\nprivate:\n  mc_x_servo(mc_x&amp; p_mc_x, hal::rpm p_max_speed);\n  result&lt;hal::servo::position_t&gt; driver_position(\n    hal::degrees p_position) override;\n  friend result&lt;mc_x_servo&gt; make_servo(mc_x&amp; p_mc_x, hal::rpm p_max_speed);\n  mc_x* m_mc_x = nullptr;\n  hal::rpm m_max_speed;\n};\n\nresult&lt;mc_x_servo&gt; make_servo(mc_x&amp; p_mc_x, hal::rpm p_max_speed);\n\nclass mc_x_temperature : public hal::temperature_sensor\n{\nprivate:\n  mc_x_temperature(mc_x&amp; p_mc_x);\n  result&lt;hal::temperature_sensor::read_t&gt; driver_read() override;\n  friend result&lt;mc_x_temperature&gt; make_temperature_sensor(mc_x&amp; p_mc_x);\n  mc_x* m_mc_x = nullptr;\n};\n\nresult&lt;mc_x_temperature&gt; make_temperature_sensor(mc_x&amp; p_mc_x);\n}  // namespace hal::rmd\n\nnamespace hal {\nusing rmd::make_motor;\nusing rmd::make_rotation_sensor;\nusing rmd::make_servo;\nusing rmd::make_temperature_sensor;\n}  // namespace hal\n</code></pre>"},{"location":"api/dir_d4bad6877cf31bc2d39b696d7a305013/","title":"Dir libraries/include/libhal-soft","text":"<p>FileList &gt; include &gt; libhal-soft</p>"},{"location":"api/dir_d4bad6877cf31bc2d39b696d7a305013/#files","title":"Files","text":"Type Name file adc_mux.hpp file i2c_minimum_speed.hpp file inverter.hpp file rc_servo.hpp"},{"location":"api/dir_d4bad6877cf31bc2d39b696d7a305013/#directories","title":"Directories","text":"Type Name dir inert_drivers <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/</code></p>"},{"location":"api/adc__mux_8hpp/","title":"File adc_mux.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; adc_mux.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;libhal/adc.hpp&gt;</code></li> <li><code>#include &lt;libhal/output_pin.hpp&gt;</code></li> <li><code>#include &lt;libhal/steady_clock.hpp&gt;</code></li> </ul>"},{"location":"api/adc__mux_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/adc__mux_8hpp/#classes","title":"Classes","text":"Type Name class adc_multiplexer A driver for an ADC multiplexer that manages and reads ADC mux pins. This driver is intended to be used with multiplexers that use digital signals. An ADC multiplexer can be used to expand the number of input channels of an ADC. class adc_mux_pin A class that represents a multiplexer pin for ADC. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/adc_mux.hpp</code></p>"},{"location":"api/adc__mux_8hpp_source/","title":"File adc_mux.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; adc_mux.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;array&gt;\n#include &lt;span&gt;\n\n#include &lt;libhal/adc.hpp&gt;\n#include &lt;libhal/output_pin.hpp&gt;\n#include &lt;libhal/steady_clock.hpp&gt;\n\nnamespace hal::soft {\nclass adc_multiplexer\n{\npublic:\n  static adc_multiplexer create(std::span&lt;hal::output_pin*&gt; p_signal_pins,\n                                hal::adc&amp; p_source_pin,\n                                hal::steady_clock&amp; p_clock);\n\n  hal::result&lt;hal::adc::read_t&gt; read_channel(std::uint16_t p_mux_port);\n\n  int get_max_channel();\n\nprivate:\n  adc_multiplexer(std::span&lt;output_pin*&gt; p_signal_pins,\n                  hal::adc&amp; p_source_pin,\n                  hal::steady_clock&amp; p_clock);\n\nprivate:\n  std::span&lt;output_pin*&gt; m_signal_pins;\n  hal::adc* m_source_pin;\n  hal::steady_clock* m_clock;\n};\n\nclass adc_mux_pin : public hal::adc\n{\n  friend hal::result&lt;adc_mux_pin&gt; make_adc(adc_multiplexer&amp; p_multiplexer,\n                                           std::uint8_t p_channel);\n\nprivate:\n  adc_mux_pin(adc_multiplexer&amp; p_mux, std::uint8_t p_mux_port);\n  hal::result&lt;read_t&gt; driver_read() override;\n\n  adc_multiplexer* m_mux;\n  std::uint8_t m_mux_port;\n};\n\nresult&lt;adc_mux_pin&gt; make_adc(adc_multiplexer&amp; p_multiplexer,\n                             std::uint8_t p_channel);\n}  // namespace hal::soft\n\nnamespace hal {\nusing hal::soft::make_adc;\n}  // namespace hal\n</code></pre>"},{"location":"api/i2c__minimum__speed_8hpp/","title":"File i2c_minimum_speed.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; i2c_minimum_speed.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/i2c.hpp&gt;</code></li> </ul>"},{"location":"api/i2c__minimum__speed_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/i2c__minimum__speed_8hpp/#classes","title":"Classes","text":"Type Name class minimum_speed_i2c A i2c wrapper to ensure that the lowesti2c device frequency is used. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/i2c_minimum_speed.hpp</code></p>"},{"location":"api/i2c__minimum__speed_8hpp_source/","title":"File i2c_minimum_speed.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; i2c_minimum_speed.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/i2c.hpp&gt;\n\nnamespace hal::soft {\nclass minimum_speed_i2c : public hal::i2c\n{\npublic:\n  constexpr static auto default_max_speed = 2'000'000;\n  static result&lt;minimum_speed_i2c&gt; create(\n    hal::i2c&amp; p_i2c,\n    hertz p_frequency = default_max_speed);\n\nprivate:\n  minimum_speed_i2c(hal::i2c&amp; p_i2c, hertz p_frequency);\n\n  status driver_configure(const settings&amp; p_new_setting) override;\n\n  result&lt;transaction_t&gt; driver_transaction(\n    hal::byte p_address,\n    std::span&lt;const hal::byte&gt; p_data_out,\n    std::span&lt;hal::byte&gt; p_data_in,\n    hal::function_ref&lt;hal::timeout_function&gt; p_timeout) override;\n\n  hal::i2c* m_i2c;\n  hertz m_lowest_seen_frequency;\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inverter_8hpp/","title":"File inverter.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inverter.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/input_pin.hpp&gt;</code></li> <li><code>#include &lt;libhal/output_pin.hpp&gt;</code></li> </ul>"},{"location":"api/inverter_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inverter_8hpp/#classes","title":"Classes","text":"Type Name class input_pin_inverter class output_pin_inverter <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inverter.hpp</code></p>"},{"location":"api/inverter_8hpp_source/","title":"File inverter.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inverter.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n#pragma once\n\n#include &lt;libhal/input_pin.hpp&gt;\n#include &lt;libhal/output_pin.hpp&gt;\n\nnamespace hal::soft {\nclass output_pin_inverter : public hal::output_pin\n{\npublic:\n  output_pin_inverter(hal::output_pin&amp; p_output_pin);\n\nprivate:\n  status driver_configure(const settings&amp; p_settings) override;\n  result&lt;set_level_t&gt; driver_level(bool p_high) override;\n  result&lt;level_t&gt; driver_level() override;\n\n  hal::output_pin* m_output_pin;\n};\n\nclass input_pin_inverter : public hal::input_pin\n{\npublic:\n  input_pin_inverter(hal::input_pin&amp; p_input_pin);\n\nprivate:\n  status driver_configure(const settings&amp; p_settings) override;\n  result&lt;level_t&gt; driver_level() override;\n\n  hal::input_pin* m_input_pin;\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/dir_140c0a66abe76384f84bfc7661372b14/","title":"Dir libraries/include/libhal-soft/inert_drivers","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers</p>"},{"location":"api/dir_140c0a66abe76384f84bfc7661372b14/#files","title":"Files","text":"Type Name file inert_accelerometer.hpp file inert_adc.hpp file inert_dac.hpp file inert_distance_sensor.hpp file inert_gyroscope.hpp file inert_input_pin.hpp file inert_interrupt_pin.hpp file inert_magnetometer.hpp file inert_motor.hpp file inert_output_pin.hpp file inert_pwm.hpp file inert_rotation_sensor.hpp file inert_steady_clock.hpp file inert_temperature_sensor.hpp file inert_timer.hpp <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/</code></p>"},{"location":"api/inert__accelerometer_8hpp/","title":"File inert_accelerometer.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_accelerometer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/accelerometer.hpp&gt;</code></li> </ul>"},{"location":"api/inert__accelerometer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__accelerometer_8hpp/#classes","title":"Classes","text":"Type Name class inert_accelerometer Inert implementation of acceleration sensing hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_accelerometer.hpp</code></p>"},{"location":"api/inert__accelerometer_8hpp_source/","title":"File inert_accelerometer.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_accelerometer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/accelerometer.hpp&gt;\n\nnamespace hal::soft {\nclass inert_accelerometer : public hal::accelerometer\n{\npublic:\n  static result&lt;inert_accelerometer&gt; create(read_t p_values)\n  {\n    return inert_accelerometer(p_values);\n  }\n\nprivate:\n  constexpr inert_accelerometer(read_t p_values)\n    : m_values(p_values)\n  {\n  }\n\n  result&lt;read_t&gt; driver_read()\n  {\n    return m_values;\n  };\n\n  read_t m_values;\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__adc_8hpp/","title":"File inert_adc.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_adc.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/adc.hpp&gt;</code></li> </ul>"},{"location":"api/inert__adc_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__adc_8hpp/#classes","title":"Classes","text":"Type Name class inert_adc Inert implementation of Analog to Digital Converter (ADC) hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_adc.hpp</code></p>"},{"location":"api/inert__adc_8hpp_source/","title":"File inert_adc.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_adc.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/adc.hpp&gt;\n\nnamespace hal::soft {\nclass inert_adc : public hal::adc\n{\npublic:\n  static result&lt;inert_adc&gt; create(read_t p_result)\n  {\n    return inert_adc(p_result);\n  }\n\nprivate:\n  constexpr inert_adc(read_t p_result)\n    : m_result(p_result)\n  {\n  }\n\n  result&lt;read_t&gt; driver_read()\n  {\n    return m_result;\n  };\n\n  read_t m_result;\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__dac_8hpp/","title":"File inert_dac.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_dac.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/dac.hpp&gt;</code></li> </ul>"},{"location":"api/inert__dac_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__dac_8hpp/#classes","title":"Classes","text":"Type Name class inert_dac Inert implementation of Digital to Analog Converter (DAC) hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_dac.hpp</code></p>"},{"location":"api/inert__dac_8hpp_source/","title":"File inert_dac.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_dac.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/dac.hpp&gt;\n\nnamespace hal::soft {\nclass inert_dac : public hal::dac\n{\npublic:\n  static result&lt;inert_dac&gt; create()\n  {\n    return inert_dac();\n  }\n\nprivate:\n  constexpr inert_dac()\n  {\n  }\n\n  result&lt;write_t&gt; driver_write([[maybe_unused]] float p_percentage)\n  {\n    return write_t{};\n  };\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__distance__sensor_8hpp/","title":"File inert_distance_sensor.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_distance_sensor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/distance_sensor.hpp&gt;</code></li> </ul>"},{"location":"api/inert__distance__sensor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__distance__sensor_8hpp/#classes","title":"Classes","text":"Type Name class inert_distance_sensor Inert implementation of linear distance hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_distance_sensor.hpp</code></p>"},{"location":"api/inert__distance__sensor_8hpp_source/","title":"File inert_distance_sensor.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_distance_sensor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/distance_sensor.hpp&gt;\n\nnamespace hal::soft {\nclass inert_distance_sensor : public hal::distance_sensor\n{\npublic:\n  static result&lt;inert_distance_sensor&gt; create(read_t p_result)\n  {\n    return inert_distance_sensor(p_result);\n  }\n\nprivate:\n  constexpr inert_distance_sensor(read_t p_result)\n    : m_result(p_result)\n  {\n  }\n\n  result&lt;read_t&gt; driver_read()\n  {\n    return m_result;\n  };\n\n  read_t m_result;\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__gyroscope_8hpp/","title":"File inert_gyroscope.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_gyroscope.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/gyroscope.hpp&gt;</code></li> </ul>"},{"location":"api/inert__gyroscope_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__gyroscope_8hpp/#classes","title":"Classes","text":"Type Name class inert_gyroscope Inert implementation of angular velocity sensing hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_gyroscope.hpp</code></p>"},{"location":"api/inert__gyroscope_8hpp_source/","title":"File inert_gyroscope.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_gyroscope.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/gyroscope.hpp&gt;\n\nnamespace hal::soft {\nclass inert_gyroscope : public hal::gyroscope\n{\npublic:\n  static result&lt;inert_gyroscope&gt; create(read_t p_result)\n  {\n    return inert_gyroscope(p_result);\n  }\n\nprivate:\n  constexpr inert_gyroscope(read_t p_result)\n    : m_result(p_result)\n  {\n  }\n\n  result&lt;read_t&gt; driver_read()\n  {\n    return m_result;\n  };\n\n  read_t m_result;\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__input__pin_8hpp/","title":"File inert_input_pin.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_input_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/input_pin.hpp&gt;</code></li> </ul>"},{"location":"api/inert__input__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__input__pin_8hpp/#classes","title":"Classes","text":"Type Name class inert_input_pin Inert implementation of digital input pin hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_input_pin.hpp</code></p>"},{"location":"api/inert__input__pin_8hpp_source/","title":"File inert_input_pin.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_input_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/input_pin.hpp&gt;\n\nnamespace hal::soft {\nclass inert_input_pin : public hal::input_pin\n{\npublic:\n  static result&lt;inert_input_pin&gt; create(level_t p_level)\n  {\n    return inert_input_pin(p_level);\n  }\n\nprivate:\n  constexpr inert_input_pin(level_t p_level)\n    : m_level(p_level)\n  {\n  }\n\n  status driver_configure([[maybe_unused]] const settings&amp; p_settings)\n  {\n    return hal::success();\n  };\n\n  result&lt;level_t&gt; driver_level()\n  {\n    return m_level;\n  };\n\n  level_t m_level;\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__interrupt__pin_8hpp/","title":"File inert_interrupt_pin.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_interrupt_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/interrupt_pin.hpp&gt;</code></li> </ul>"},{"location":"api/inert__interrupt__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__interrupt__pin_8hpp/#classes","title":"Classes","text":"Type Name class inert_interrupt_pin Inert implementation of digital interrupt pin hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_interrupt_pin.hpp</code></p>"},{"location":"api/inert__interrupt__pin_8hpp_source/","title":"File inert_interrupt_pin.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_interrupt_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/interrupt_pin.hpp&gt;\n\nnamespace hal::soft {\nclass inert_interrupt_pin : public hal::interrupt_pin\n{\npublic:\n  static result&lt;inert_interrupt_pin&gt; create()\n  {\n    return inert_interrupt_pin();\n  }\n\nprivate:\n  constexpr inert_interrupt_pin()\n  {\n  }\n\n  status driver_configure([[maybe_unused]] const settings&amp; p_settings)\n  {\n    return hal::success();\n  };\n\n  void driver_on_trigger([[maybe_unused]] hal::callback&lt;handler&gt; p_callback){};\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__magnetometer_8hpp/","title":"File inert_magnetometer.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_magnetometer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/magnetometer.hpp&gt;</code></li> </ul>"},{"location":"api/inert__magnetometer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__magnetometer_8hpp/#classes","title":"Classes","text":"Type Name class inert_magnetometer Inert implementation of magnetic field strength sensing hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_magnetometer.hpp</code></p>"},{"location":"api/inert__magnetometer_8hpp_source/","title":"File inert_magnetometer.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_magnetometer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/magnetometer.hpp&gt;\n\nnamespace hal::soft {\nclass inert_magnetometer : public hal::magnetometer\n{\npublic:\n  static result&lt;inert_magnetometer&gt; create(read_t p_result)\n  {\n    return inert_magnetometer(p_result);\n  }\n\nprivate:\n  constexpr inert_magnetometer(read_t p_result)\n    : m_result(p_result)\n  {\n  }\n\n  result&lt;read_t&gt; driver_read()\n  {\n    return m_result;\n  };\n\n  read_t m_result;\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__motor_8hpp/","title":"File inert_motor.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_motor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/motor.hpp&gt;</code></li> </ul>"},{"location":"api/inert__motor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__motor_8hpp/#classes","title":"Classes","text":"Type Name class inert_motor Inert implementation of open loop motorized actuator hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_motor.hpp</code></p>"},{"location":"api/inert__motor_8hpp_source/","title":"File inert_motor.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_motor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/motor.hpp&gt;\n\nnamespace hal::soft {\nclass inert_motor : public hal::motor\n{\npublic:\n  static result&lt;inert_motor&gt; create()\n  {\n    return inert_motor();\n  }\n\nprivate:\n  constexpr inert_motor()\n  {\n  }\n\n  result&lt;power_t&gt; driver_power([[maybe_unused]] float p_power)\n  {\n    return power_t{};\n  };\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__output__pin_8hpp/","title":"File inert_output_pin.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_output_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/output_pin.hpp&gt;</code></li> </ul>"},{"location":"api/inert__output__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__output__pin_8hpp/#classes","title":"Classes","text":"Type Name class inert_output_pin Inert implementation of digital output pin hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_output_pin.hpp</code></p>"},{"location":"api/inert__output__pin_8hpp_source/","title":"File inert_output_pin.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_output_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/output_pin.hpp&gt;\n\nnamespace hal::soft {\nclass inert_output_pin : public hal::output_pin\n{\npublic:\n  static result&lt;inert_output_pin&gt; create(bool p_level)\n  {\n    return inert_output_pin(p_level);\n  }\n\nprivate:\n  constexpr inert_output_pin(bool p_level)\n    : m_level(&amp;p_level)\n  {\n  }\n\n  status driver_configure(const settings&amp; p_settings)\n  {\n    return hal::success();\n  };\n\n  result&lt;set_level_t&gt; driver_level(bool p_high)\n  {\n    m_level = p_high;\n    return set_level_t{};\n  };\n\n  result&lt;level_t&gt; driver_level()\n  {\n    return level_t{ .state = m_level };\n  };\n\n  bool m_level;\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__pwm_8hpp/","title":"File inert_pwm.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_pwm.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/pwm.hpp&gt;</code></li> </ul>"},{"location":"api/inert__pwm_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__pwm_8hpp/#classes","title":"Classes","text":"Type Name class inert_pwm Inert implementation of Pulse Width Modulation (PWM) channel hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_pwm.hpp</code></p>"},{"location":"api/inert__pwm_8hpp_source/","title":"File inert_pwm.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_pwm.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/pwm.hpp&gt;\n\nnamespace hal::soft {\nclass inert_pwm : public hal::pwm\n{\npublic:\n  static result&lt;inert_pwm&gt; create()\n  {\n    return inert_pwm();\n  }\n\nprivate:\n  constexpr inert_pwm()\n  {\n  }\n\n  result&lt;frequency_t&gt; driver_frequency([[maybe_unused]] hertz p_frequency)\n  {\n    return frequency_t{};\n  };\n\n  result&lt;duty_cycle_t&gt; driver_duty_cycle([[maybe_unused]] float p_duty_cycle)\n  {\n    return duty_cycle_t{};\n  };\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__rotation__sensor_8hpp/","title":"File inert_rotation_sensor.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_rotation_sensor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/rotation_sensor.hpp&gt;</code></li> </ul>"},{"location":"api/inert__rotation__sensor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__rotation__sensor_8hpp/#classes","title":"Classes","text":"Type Name class inert_rotation_sensor Inert implementation of rotation measuring hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_rotation_sensor.hpp</code></p>"},{"location":"api/inert__rotation__sensor_8hpp_source/","title":"File inert_rotation_sensor.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_rotation_sensor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/rotation_sensor.hpp&gt;\n\nnamespace hal::soft {\nclass inert_rotation_sensor : public hal::rotation_sensor\n{\npublic:\n  static result&lt;inert_rotation_sensor&gt; create(read_t p_position)\n  {\n    return inert_rotation_sensor(p_position);\n  }\n\nprivate:\n  constexpr inert_rotation_sensor(read_t p_position)\n    : m_position(p_position)\n  {\n  }\n\n  result&lt;read_t&gt; driver_read()\n  {\n    return m_position;\n  };\n\n  read_t m_position;\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__steady__clock_8hpp/","title":"File inert_steady_clock.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_steady_clock.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/steady_clock.hpp&gt;</code></li> </ul>"},{"location":"api/inert__steady__clock_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__steady__clock_8hpp/#classes","title":"Classes","text":"Type Name class inert_steady_clock Inert implementation of steady clock mechanism. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_steady_clock.hpp</code></p>"},{"location":"api/inert__steady__clock_8hpp_source/","title":"File inert_steady_clock.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_steady_clock.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/steady_clock.hpp&gt;\n\nnamespace hal::soft {\nclass inert_steady_clock : public hal::steady_clock\n{\npublic:\n  static result&lt;inert_steady_clock&gt; create(frequency_t p_frequency,\n                                           uptime_t p_uptime)\n  {\n    return inert_steady_clock(p_frequency, p_uptime);\n  }\n\nprivate:\n  constexpr inert_steady_clock(frequency_t p_frequency, uptime_t p_uptime)\n    : m_frequency(p_frequency)\n    , m_uptime(p_uptime)\n  {\n  }\n  frequency_t driver_frequency()\n  {\n    return m_frequency;\n  };\n\n  uptime_t driver_uptime()\n  {\n    m_uptime.ticks++;\n    return m_uptime;\n  };\n\n  frequency_t m_frequency;\n  uptime_t m_uptime;\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__temperature__sensor_8hpp/","title":"File inert_temperature_sensor.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_temperature_sensor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/temperature_sensor.hpp&gt;</code></li> </ul>"},{"location":"api/inert__temperature__sensor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__temperature__sensor_8hpp/#classes","title":"Classes","text":"Type Name class inert_temperature_sensor Inert implementation of temperature sensing hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_temperature_sensor.hpp</code></p>"},{"location":"api/inert__temperature__sensor_8hpp_source/","title":"File inert_temperature_sensor.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_temperature_sensor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/temperature_sensor.hpp&gt;\n\nnamespace hal::soft {\nclass inert_temperature_sensor : public hal::temperature_sensor\n{\npublic:\n  static result&lt;inert_temperature_sensor&gt; create(read_t p_temperature)\n  {\n    return inert_temperature_sensor(p_temperature);\n  }\n\nprivate:\n  constexpr inert_temperature_sensor(read_t p_temperature)\n    : m_temperature(p_temperature)\n  {\n  }\n\n  result&lt;read_t&gt; driver_read()\n  {\n    return m_temperature;\n  };\n\n  read_t m_temperature;\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/inert__timer_8hpp/","title":"File inert_timer.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_timer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/timer.hpp&gt;</code></li> </ul>"},{"location":"api/inert__timer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/inert__timer_8hpp/#classes","title":"Classes","text":"Type Name class inert_timer Inert implementation of timer hardware. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/inert_drivers/inert_timer.hpp</code></p>"},{"location":"api/inert__timer_8hpp_source/","title":"File inert_timer.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; inert_drivers &gt; inert_timer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/timer.hpp&gt;\n\nnamespace hal::soft {\nclass inert_timer : public hal::timer\n{\npublic:\n  static result&lt;inert_timer&gt; create(is_running_t p_is_running)\n  {\n    return inert_timer(p_is_running);\n  }\n\nprivate:\n  constexpr inert_timer(is_running_t p_is_running)\n    : m_is_running(p_is_running)\n  {\n  }\n\n  result&lt;is_running_t&gt; driver_is_running()\n  {\n    return m_is_running;\n  };\n\n  result&lt;cancel_t&gt; driver_cancel()\n  {\n    return cancel_t{};\n  };\n\n  result&lt;schedule_t&gt; driver_schedule(\n    [[maybe_unused]] hal::callback&lt;void(void)&gt; p_callback,\n    [[maybe_unused]] hal::time_duration p_delay)\n  {\n    return schedule_t{};\n  };\n\n  is_running_t m_is_running;\n};\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/rc__servo_8hpp/","title":"File rc_servo.hpp","text":"<p>FileList &gt; include &gt; libhal-soft &gt; rc_servo.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/pwm.hpp&gt;</code></li> <li><code>#include &lt;libhal/servo.hpp&gt;</code></li> </ul>"},{"location":"api/rc__servo_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace soft"},{"location":"api/rc__servo_8hpp/#classes","title":"Classes","text":"Type Name class rc_servo Generic RC servo driver. struct settings Information about the RC servo needed to control it properly. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-soft/rc_servo.hpp</code></p>"},{"location":"api/rc__servo_8hpp_source/","title":"File rc_servo.hpp","text":"<p>File List &gt; include &gt; libhal-soft &gt; rc_servo.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// Use \"#pragma once\" as an include guard for headers\n// This is required because it ensures that the compiler will process this file\n// only once, no matter how many times it is included.\n#pragma once\n\n#include &lt;libhal/pwm.hpp&gt;\n#include &lt;libhal/servo.hpp&gt;\n\n// Keep drivers within the namespace hal to not pollute global namespace\nnamespace hal::soft {\nclass rc_servo : public hal::servo\n{\npublic:\n  struct settings\n  {\n    hal::hertz frequency = 50;\n    hal::degrees min_angle = 0;\n    hal::degrees max_angle = 90;\n    std::uint32_t min_microseconds = 1000;\n    std::uint32_t max_microseconds = 2000;\n  };\n\n  // NOTE: Use a factory function in place of a constructor to report any errors\n  // that could happen and let the application decide the next steps. The\n  // Factory function returns a result&lt;rc_servo&gt; object. The standard name for\n  // factory functions for device drivers is \"create()\" and the signature must\n  // be: static result&lt;type&gt; create(/* ... args ... */){ /* ... */ }\n\n  static result&lt;rc_servo&gt; create(hal::pwm&amp; p_pwm, settings p_settings);\n\nprivate:\n  struct ranges\n  {\n    std::pair&lt;float, float&gt; percent;\n    std::pair&lt;float, float&gt; angle;\n  };\n  // Constructor is private to only be accessed from the factory function.\n  // Use p_ prefix for function parameters.\n  constexpr rc_servo(hal::pwm&amp; p_pwm, ranges p_ranges);\n\n  result&lt;position_t&gt; driver_position(hal::degrees p_position) override;\n\n  // Use m_ prefix for private/protected class members.\n  // Use a pointer here rather than a reference, because member references\n  // implicitly delete move constructors\n  hal::pwm* m_pwm;\n  ranges m_ranges;\n};\n// Comment the end of the namespace and end the file with an extra line.\n}  // namespace hal::soft\n</code></pre>"},{"location":"api/dir_382b22576b48b83d585887c4aba4f004/","title":"Dir libraries/include/libhal-stm32f1","text":"<p>FileList &gt; include &gt; libhal-stm32f1</p>"},{"location":"api/dir_382b22576b48b83d585887c4aba4f004/#files","title":"Files","text":"Type Name file clock.hpp file constants.hpp file output_pin.hpp file pin.hpp <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/</code></p>"},{"location":"api/libhal-stm32f1_2clock_8hpp/","title":"File clock.hpp","text":"<p>FileList &gt; include &gt; libhal-stm32f1 &gt; clock.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"constants.hpp\"</code></li> <li><code>#include &lt;libhal/error.hpp&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-stm32f1_2clock_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace stm32f1"},{"location":"api/libhal-stm32f1_2clock_8hpp/#classes","title":"Classes","text":"Type Name struct clock_tree struct ahb_t Defines the configuration of the dividers beyond system clock mux. struct apb1_t Maximum rate of 36 MHz. struct apb2_t struct adc_t struct pll_t Defines the configuration of the PLL. struct usb_divider_t struct rtc_t Defines the configuration for the RTC. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/clock.hpp</code></p>"},{"location":"api/libhal-stm32f1_2clock_8hpp_source/","title":"File clock.hpp","text":"<p>File List &gt; include &gt; libhal-stm32f1 &gt; clock.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include \"constants.hpp\"\n\n#include &lt;libhal/error.hpp&gt;\n#include &lt;libhal/units.hpp&gt;\n\nnamespace hal::stm32f1 {\n\nusing namespace hal::literals;\n\nconstexpr auto internal_low_speed_oscillator = 20.0_kHz;\n\nconstexpr auto internal_high_speed_oscillator = 8.0_MHz;\n\nconstexpr auto flash_clock = internal_high_speed_oscillator;\n\nconstexpr auto watchdog_clock_rate = internal_low_speed_oscillator;\n\nenum class apb_divider : std::uint8_t\n{\n  divide_by_1 = 0,\n  divide_by_2 = 0b100,\n  divide_by_4 = 0b101,\n  divide_by_8 = 0b110,\n  divide_by_16 = 0b111,\n};\n\nenum class ahb_divider : std::uint8_t\n{\n  divide_by_1 = 0,\n  divide_by_2 = 0b1000,\n  divide_by_4 = 0b1001,\n  divide_by_8 = 0b1010,\n  divide_by_16 = 0b1011,\n  divide_by_64 = 0b1100,\n  divide_by_128 = 0b1101,\n  divide_by_256 = 0b1110,\n  divide_by_512 = 0b1111,\n};\n\nenum class adc_divider : std::uint8_t\n{\n  divide_by_2 = 0b00,\n  divide_by_4 = 0b01,\n  divide_by_6 = 0b10,\n  divide_by_8 = 0b11,\n};\n\nenum class system_clock_select : std::uint8_t\n{\n  high_speed_internal = 0b00,\n  high_speed_external = 0b01,\n  pll = 0b10,\n};\n\nenum class pll_multiply : std::uint8_t\n{\n  multiply_by_2 = 0b0000,\n  multiply_by_3 = 0b0001,\n  multiply_by_4 = 0b0010,\n  multiply_by_5 = 0b0011,\n  multiply_by_6 = 0b0100,\n  multiply_by_7 = 0b0101,\n  multiply_by_8 = 0b0110,\n  multiply_by_9 = 0b0111,\n  multiply_by_10 = 0b1000,\n  multiply_by_11 = 0b1001,\n  multiply_by_12 = 0b1010,\n  multiply_by_13 = 0b1011,\n  multiply_by_14 = 0b1100,\n  multiply_by_15 = 0b1101,\n  multiply_by_16 = 0b1110,\n};\n\nenum class rtc_source : std::uint8_t\n{\n  no_clock = 0b00,\n  low_speed_internal = 0b01,\n  low_speed_external = 0b10,\n  high_speed_external_divided_by_128 = 0b11,\n};\n\nenum class pll_source : std::uint8_t\n{\n  high_speed_internal = 0b0,\n  high_speed_external = 0b1,\n  high_speed_external_divided_by_2 = 0b11,\n};\n\nenum class usb_divider : std::uint8_t\n{\n  divide_by_1 = 1,\n  divide_by_1_point_5 = 0,\n};\n\nstruct clock_tree\n{\n  hal::hertz high_speed_external = 0.0_MHz;\n\n  hal::hertz low_speed_external = 0.0_MHz;\n\n  struct pll_t\n  {\n    bool enable = false;\n    pll_source source = pll_source::high_speed_internal;\n    pll_multiply multiply = pll_multiply::multiply_by_2;\n    struct usb_divider_t\n    {\n      usb_divider divider = usb_divider::divide_by_1_point_5;\n    } usb = {};\n  } pll = {};\n\n  system_clock_select system_clock = system_clock_select::high_speed_internal;\n\n  struct rtc_t\n  {\n    bool enable = false;\n    rtc_source source = rtc_source::low_speed_internal;\n  } rtc = {};\n\n  struct ahb_t\n  {\n    ahb_divider divider = ahb_divider::divide_by_1;\n    struct apb1_t\n    {\n      apb_divider divider = apb_divider::divide_by_1;\n    } apb1 = {};\n\n    struct apb2_t\n    {\n      apb_divider divider = apb_divider::divide_by_1;\n      struct adc_t\n      {\n        adc_divider divider = adc_divider::divide_by_2;\n      } adc = {};\n    } apb2 = {};\n  } ahb = {};\n};\n\nvoid configure_clocks(clock_tree p_clock_tree);\n\nhal::hertz frequency(peripheral p_id);\n}  // namespace hal::stm32f1\n</code></pre>"},{"location":"api/libhal-stm32f1_2constants_8hpp/","title":"File constants.hpp","text":"<p>FileList &gt; include &gt; libhal-stm32f1 &gt; constants.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"api/libhal-stm32f1_2constants_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace stm32f1 <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/constants.hpp</code></p>"},{"location":"api/libhal-stm32f1_2constants_8hpp_source/","title":"File constants.hpp","text":"<p>File List &gt; include &gt; libhal-stm32f1 &gt; constants.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\nnamespace hal::stm32f1 {\n\nstatic constexpr std::uint32_t bus_id_offset = 32;\nstatic constexpr std::uint32_t ahb_bus = bus_id_offset * 0;\nstatic constexpr std::uint32_t apb1_bus = bus_id_offset * 1;\nstatic constexpr std::uint32_t apb2_bus = bus_id_offset * 2;\nstatic constexpr std::uint32_t beyond_bus = bus_id_offset * 3;\n\nenum class peripheral : std::uint8_t\n{\n  dma1 = ahb_bus + 0,\n  dma2 = ahb_bus + 1,\n  sram = ahb_bus + 2,\n  flitf = ahb_bus + 4,\n  crc = ahb_bus + 6,\n  fsmc = ahb_bus + 8,\n  sdio = ahb_bus + 10,\n\n  timer2 = apb1_bus + 0,\n  timer3 = apb1_bus + 1,\n  timer4 = apb1_bus + 2,\n  timer5 = apb1_bus + 3,\n  timer6 = apb1_bus + 4,\n  timer7 = apb1_bus + 5,\n  timer12 = apb1_bus + 6,\n  timer13 = apb1_bus + 7,\n  timer14 = apb1_bus + 8,\n  window_watchdog = apb1_bus + 11,\n  spi2 = apb1_bus + 14,\n  spi3 = apb1_bus + 15,\n  usart2 = apb1_bus + 17,\n  usart3 = apb1_bus + 18,\n  uart4 = apb1_bus + 19,\n  uart5 = apb1_bus + 20,\n  i2c1 = apb1_bus + 21,\n  i2c2 = apb1_bus + 22,\n  usb = apb1_bus + 23,\n  can1 = apb1_bus + 25,\n  backup_clock = apb1_bus + 27,\n  power = apb1_bus + 28,\n  dac = apb1_bus + 29,\n\n  afio = apb2_bus + 0,\n  gpio_a = apb2_bus + 2,\n  gpio_b = apb2_bus + 3,\n  gpio_c = apb2_bus + 4,\n  gpio_d = apb2_bus + 5,\n  gpio_e = apb2_bus + 6,\n  gpio_f = apb2_bus + 7,\n  gpio_g = apb2_bus + 8,\n  adc1 = apb2_bus + 9,\n  adc2 = apb2_bus + 10,\n  timer1 = apb2_bus + 11,\n  spi1 = apb2_bus + 12,\n  timer8 = apb2_bus + 13,\n  usart1 = apb2_bus + 14,\n  adc3 = apb2_bus + 15,\n  timer9 = apb2_bus + 19,\n  timer10 = apb2_bus + 20,\n  timer11 = apb2_bus + 21,\n\n  cpu = beyond_bus + 0,\n  system_timer = beyond_bus + 1,\n  i2s = beyond_bus + 2,\n};\n\nenum class irq : std::uint16_t\n{\n  window_watchdog = 0,\n  pvd = 1,\n  tamper = 2,\n  rtc = 3,\n  flash = 4,\n  rcc = 5,\n  exti0 = 6,\n  exti1 = 7,\n  exti2 = 8,\n  exti3 = 9,\n  exti4 = 10,\n  dma1_channel1 = 11,\n  dma1_channel2 = 12,\n  dma1_channel3 = 13,\n  dma1_channel4 = 14,\n  dma1_channel5 = 15,\n  dma1_channel6 = 16,\n  dma1_channel7 = 17,\n  adc1 = 18,\n  adc1_2 = 18,\n  usb_hp_can1_tx = 19,\n  can1_tx = 19,\n  usb_lp_can1_rx0 = 20,\n  can1_rx0 = 20,\n  can1_rx1 = 21,\n  can1_sce = 22,\n  exti9_5 = 23,\n  tim1_brk = 24,\n  tim1_brk_tim15 = 24,\n  tim1_brk_tim9 = 24,\n  tim1_up = 25,\n  tim1_up_tim16 = 25,\n  tim1_up_tim10 = 25,\n  tim1_trg_com = 26,\n  tim1_trg_com_tim11 = 26,\n  tim1_cc = 27,\n  tim2 = 28,\n  tim3 = 29,\n  tim4 = 30,\n  i2c1_ev = 31,\n  i2c1_er = 32,\n  i2c2_ev = 33,\n  i2c2_er = 34,\n  spi1 = 35,\n  spi2 = 36,\n  usart1 = 37,\n  usart2 = 38,\n  usart3 = 39,\n  exti15_10 = 40,\n  rtcalarm = 41,\n  usbwakeup = 42,\n  cec = 42,\n  otg_fs_wkup = 42,\n  tim8_brk = 43,\n  tim12 = 43,\n  tim8_brk_tim12 = 43,\n  tim8_up = 44,\n  tim13 = 44,\n  tim8_up_tim13 = 44,\n  tim8_trg_com = 45,\n  tim14 = 45,\n  tim8_trg_com_tim14 = 45,\n  tim8_cc = 46,\n  adc3 = 47,\n  fsmc = 48,\n  sdio = 49,\n  tim5 = 50,\n  spi3 = 51,\n  uart4 = 52,\n  uart5 = 53,\n  tim6_dac = 54,\n  tim6 = 54,\n  tim7 = 55,\n  dma2_channel1 = 56,\n  dma2_channel2 = 57,\n  dma2_channel3 = 58,\n  dma2_channel4_5 = 59,\n  dma2_channel4 = 59,\n  dma2_channel5 = 60,\n  eth = 61,\n  eth_wkup = 62,\n  can2_tx = 63,\n  can2_rx0 = 64,\n  can2_rx1 = 65,\n  can2_sce = 66,\n  otg_fs = 67,\n  max,\n};\n\nenum class error_t : std::uint16_t\n{\n  max,\n};\n}  // namespace hal::stm32f1\n</code></pre>"},{"location":"api/libhal-stm32f1_2output__pin_8hpp/","title":"File output_pin.hpp","text":"<p>FileList &gt; include &gt; libhal-stm32f1 &gt; output_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;libhal/output_pin.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-stm32f1_2output__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace stm32f1"},{"location":"api/libhal-stm32f1_2output__pin_8hpp/#classes","title":"Classes","text":"Type Name class output_pin Output pin implementation for the stm32::f10x. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/output_pin.hpp</code></p>"},{"location":"api/libhal-stm32f1_2output__pin_8hpp_source/","title":"File output_pin.hpp","text":"<p>File List &gt; include &gt; libhal-stm32f1 &gt; output_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include &lt;libhal/output_pin.hpp&gt;\n\nnamespace hal::stm32f1 {\nclass output_pin : public hal::output_pin\n{\npublic:\n  static result&lt;output_pin&gt; get(std::uint8_t p_port,\n                                std::uint8_t p_pin,\n                                output_pin::settings p_settings = {});\n\nprivate:\n  output_pin(std::uint8_t p_port, std::uint8_t p_pin);\n\n  status driver_configure(const settings&amp; p_settings) override;\n  result&lt;set_level_t&gt; driver_level(bool p_high) override;\n  result&lt;level_t&gt; driver_level() override;\n\n  std::uint8_t m_port{};\n  std::uint8_t m_pin{};\n};\n}  // namespace hal::stm32f1\n</code></pre>"},{"location":"api/libhal-stm32f1_2pin_8hpp/","title":"File pin.hpp","text":"<p>FileList &gt; include &gt; libhal-stm32f1 &gt; pin.hpp</p> <p>Go to the source code of this file</p>"},{"location":"api/libhal-stm32f1_2pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. namespace stm32f1 <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-stm32f1/pin.hpp</code></p>"},{"location":"api/libhal-stm32f1_2pin_8hpp_source/","title":"File pin.hpp","text":"<p>File List &gt; include &gt; libhal-stm32f1 &gt; pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\nnamespace hal::stm32f1 {\nvoid release_jtag_pins();\n}  // namespace hal::stm32f1\n</code></pre>"},{"location":"api/dir_5e94bd3e75b6b11eff60149e0bc5664b/","title":"Dir libraries/include/libhal-util","text":"<p>FileList &gt; include &gt; libhal-util</p>"},{"location":"api/dir_5e94bd3e75b6b11eff60149e0bc5664b/#files","title":"Files","text":"Type Name file as_bytes.hpp file bit.hpp file bit_limits.hpp file can.hpp file comparison.hpp file enum.hpp file i2c.hpp file input_pin.hpp file interrupt_pin.hpp file map.hpp file math.hpp Compile time generic math utility functions. file move_interceptor.hpp file output_pin.hpp file overflow_counter.hpp file serial.hpp file serial_coroutines.hpp file spi.hpp file static_callable.hpp file static_list.hpp file steady_clock.hpp file streams.hpp file timeout.hpp file to_array.hpp file units.hpp <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/</code></p>"},{"location":"api/as__bytes_8hpp/","title":"File as_bytes.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; as_bytes.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> </ul>"},{"location":"api/as__bytes_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/as_bytes.hpp</code></p>"},{"location":"api/as__bytes_8hpp_source/","title":"File as_bytes.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; as_bytes.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;span&gt;\n\n#include &lt;libhal/units.hpp&gt;\n\nnamespace hal {\ntemplate&lt;typename T&gt;\nconstexpr std::span&lt;hal::byte&gt; as_writable_bytes(T* p_address,\n                                                 size_t p_number_of_elements)\n{\n  auto* start = reinterpret_cast&lt;hal::byte*&gt;(p_address);\n  size_t number_of_bytes = sizeof(T) * p_number_of_elements;\n  return std::span&lt;hal::byte&gt;(start, number_of_bytes);\n}\n\ntemplate&lt;typename T&gt;\nconstexpr std::span&lt;const hal::byte&gt; as_bytes(const T* p_address,\n                                              size_t p_number_of_elements)\n{\n  auto* start = reinterpret_cast&lt;const hal::byte*&gt;(p_address);\n  size_t number_of_bytes = sizeof(T) * p_number_of_elements;\n  return std::span&lt;const hal::byte&gt;(start, number_of_bytes);\n}\n\ntemplate&lt;typename T&gt;\nconcept convertible_to_bytes = requires(T a) {\n                                 *a.data();\n                                 a.size();\n                               };\n\nconstexpr std::span&lt;hal::byte&gt; as_writable_bytes(\n  convertible_to_bytes auto&amp; p_container)\n{\n  return as_writable_bytes(p_container.data(), p_container.size());\n}\n\nconstexpr std::span&lt;const hal::byte&gt; as_bytes(\n  const convertible_to_bytes auto&amp; p_container)\n{\n  return as_bytes(p_container.data(), p_container.size());\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/bit_8hpp/","title":"File bit.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; bit.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;concepts&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> </ul>"},{"location":"api/bit_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/bit_8hpp/#classes","title":"Classes","text":"Type Name struct bit_mask Represents a bit mask of contiguous bits. class bit_modify &lt;T&gt; class bit_value &lt;T&gt; struct byte_mask &lt;ByteIndex&gt;Helper for generating byte position masks. struct nibble_mask &lt;NibbleIndex&gt;Helper for generating nibble position masks. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/bit.hpp</code></p>"},{"location":"api/bit_8hpp_source/","title":"File bit.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; bit.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;concepts&gt;\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;limits&gt;\n\nnamespace hal {\nstruct bit_mask\n{\n  std::uint32_t position;\n  std::uint32_t width;\n\n  template&lt;std::uint32_t position1, std::uint32_t position2&gt;\n  static consteval bit_mask from()\n  {\n    constexpr std::uint32_t plus_one = 1;\n    if constexpr (position1 &lt; position2) {\n      return bit_mask{ .position = position1,\n                       .width = plus_one + (position2 - position1) };\n    } else {\n      return bit_mask{ .position = position2,\n                       .width = plus_one + (position1 - position2) };\n    }\n  }\n\n  template&lt;std::uint32_t position&gt;\n  static constexpr bit_mask from()\n  {\n    return bit_mask{ .position = position, .width = 1U };\n  }\n\n  static consteval bit_mask from(std::uint32_t position1,\n                                 std::uint32_t position2)\n  {\n    constexpr std::uint32_t plus_one = 1;\n    if (position1 &lt; position2) {\n      return bit_mask{ .position = position1,\n                       .width = plus_one + (position2 - position1) };\n    } else {\n      return bit_mask{ .position = position2,\n                       .width = plus_one + (position1 - position2) };\n    }\n  }\n\n  static constexpr bit_mask from(std::uint32_t position)\n  {\n    return bit_mask{ .position = position, .width = 1U };\n  }\n\n  template&lt;std::unsigned_integral T&gt;\n  constexpr auto origin() const\n  {\n    // At compile time, generate variable containing all 1s with the size of the\n    // target parameter.\n    constexpr T field_of_ones = std::numeric_limits&lt;T&gt;::max();\n\n    // At compile time calculate the number of bits in the target parameter.\n    constexpr size_t target_width = sizeof(T) * 8;\n\n    // Create bit_mask by shifting the set of 1s down so that the number of 1s\n    // from bit position 0 is equal to the width parameter.\n    T mask_at_origin = static_cast&lt;T&gt;(field_of_ones &gt;&gt; (target_width - width));\n\n    return mask_at_origin;\n  }\n\n  template&lt;std::unsigned_integral T&gt;\n  constexpr auto value() const\n  {\n    return static_cast&lt;T&gt;(origin&lt;T&gt;() &lt;&lt; position);\n  }\n\n  constexpr bool operator==(const bit_mask&amp; other)\n  {\n    return other.position == position &amp;&amp; other.width == width;\n  }\n};\n\ntemplate&lt;size_t ByteIndex&gt;\nstruct byte_mask\n{\n  static constexpr hal::bit_mask value{ .position = ByteIndex, .width = 8 };\n};\n\ntemplate&lt;size_t ByteIndex&gt;\nconstexpr hal::bit_mask byte_m = byte_mask&lt;ByteIndex&gt;::value;\n\ntemplate&lt;size_t NibbleIndex&gt;\nstruct nibble_mask\n{\n  static constexpr hal::bit_mask value{ .position = NibbleIndex, .width = 4 };\n};\n\ntemplate&lt;size_t NibbleIndex&gt;\nconstexpr hal::bit_mask nibble_m = nibble_mask&lt;NibbleIndex&gt;::value;\n\ntemplate&lt;bit_mask field&gt;\nconstexpr auto bit_extract(std::unsigned_integral auto p_value)\n{\n  using T = decltype(p_value);\n  // Shift desired value to the right to position 0\n  const auto shifted = p_value &gt;&gt; field.position;\n  // Mask away any bits left of the value based on the field width\n  const auto masked = shifted &amp; field.origin&lt;T&gt;();\n  // Leaving only the desired bits\n  return static_cast&lt;T&gt;(masked);\n}\n\nconstexpr auto bit_extract(bit_mask p_field,\n                           std::unsigned_integral auto p_value)\n{\n  using T = decltype(p_value);\n  // Shift desired value to the right to position 0\n  const auto shifted = p_value &gt;&gt; p_field.position;\n  // Mask away any bits left of the value based on the field width\n  const auto masked = shifted &amp; p_field.origin&lt;T&gt;();\n  // Leaving only the desired bits\n  return static_cast&lt;T&gt;(masked);\n}\n\ntemplate&lt;std::unsigned_integral T&gt;\nclass bit_value\n{\npublic:\n  static constexpr std::uint32_t width = sizeof(T) * 8;\n\n  constexpr bit_value(T p_initial_value = 0)\n    : m_value(p_initial_value)\n  {\n  }\n\n  template&lt;bit_mask field&gt;\n  constexpr auto&amp; set()\n  {\n    static_assert(field.position &lt; width,\n                  \"Bit position exceeds register width\");\n    constexpr auto mask = static_cast&lt;T&gt;(1U &lt;&lt; field.position);\n\n    m_value = m_value | mask;\n\n    return *this;\n  }\n\n  constexpr auto&amp; set(bit_mask p_field)\n  {\n    const auto mask = static_cast&lt;T&gt;(1U &lt;&lt; p_field.position);\n\n    m_value = m_value | mask;\n\n    return *this;\n  }\n\n  template&lt;bit_mask field&gt;\n  constexpr auto&amp; clear()\n  {\n    static_assert(field.position &lt; width,\n                  \"Bit position exceeds register width\");\n    constexpr auto mask = static_cast&lt;T&gt;(1U &lt;&lt; field.position);\n    constexpr auto inverted_mask = ~mask;\n\n    m_value = m_value &amp; inverted_mask;\n\n    return *this;\n  }\n\n  constexpr auto&amp; clear(bit_mask p_field)\n  {\n    const auto mask = static_cast&lt;T&gt;(1U &lt;&lt; p_field.position);\n    const auto inverted_mask = ~mask;\n\n    m_value = m_value &amp; inverted_mask;\n\n    return *this;\n  }\n\n  template&lt;bit_mask field&gt;\n  constexpr auto&amp; toggle()\n  {\n    static_assert(field.position &lt; width,\n                  \"Bit position exceeds register width\");\n\n    constexpr auto mask = static_cast&lt;T&gt;(1U &lt;&lt; field.position);\n\n    m_value = m_value ^ mask;\n\n    return *this;\n  }\n\n  constexpr auto&amp; toggle(bit_mask p_field)\n  {\n    const auto mask = static_cast&lt;T&gt;(1U &lt;&lt; p_field.position);\n\n    m_value = m_value ^ mask;\n\n    return *this;\n  }\n\n  template&lt;bit_mask field&gt;\n  constexpr auto&amp; insert(std::unsigned_integral auto p_value)\n  {\n    const auto value_to_insert = static_cast&lt;T&gt;(p_value);\n    // AND value with mask to remove any bits beyond the specified width.\n    // Shift masked value into bit position and OR with target value.\n    const auto shifted_field = value_to_insert &lt;&lt; field.position;\n    const auto new_value = shifted_field &amp; field.value&lt;T&gt;();\n\n    // Clear width's number of bits in the target value at the bit position\n    // specified.\n    m_value = m_value &amp; ~field.value&lt;T&gt;();\n    m_value = m_value | static_cast&lt;T&gt;(new_value);\n\n    return *this;\n  }\n\n  constexpr auto&amp; insert(bit_mask p_field, std::unsigned_integral auto p_value)\n  {\n    // AND value with mask to remove any bits beyond the specified width.\n    // Shift masked value into bit position and OR with target value.\n    auto shifted_field = static_cast&lt;T&gt;(p_value) &lt;&lt; p_field.position;\n    auto new_value = shifted_field &amp; p_field.value&lt;T&gt;();\n\n    // Clear width's number of bits in the target value at the bit position\n    // specified.\n    m_value = m_value &amp; ~p_field.value&lt;T&gt;();\n    m_value = m_value | static_cast&lt;T&gt;(new_value);\n\n    return *this;\n  }\n\n  template&lt;std::integral U&gt;\n  [[nodiscard]] constexpr auto to()\n  {\n    return static_cast&lt;U&gt;(m_value);\n  }\n\n  [[nodiscard]] constexpr T get()\n  {\n    return m_value;\n  }\n\nprotected:\n  T m_value;\n};\n\ntemplate&lt;std::unsigned_integral T&gt;\nclass bit_modify : public bit_value&lt;T&gt;\n{\npublic:\n  constexpr bit_modify(volatile T&amp; p_register_reference)\n    : bit_value&lt;T&gt;(p_register_reference)\n    , m_pointer(&amp;p_register_reference)\n  {\n  }\n\n  ~bit_modify()\n  {\n    *m_pointer = this-&gt;m_value;\n  }\n\nprivate:\n  volatile T* m_pointer;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/bit__limits_8hpp/","title":"File bit_limits.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; bit_limits.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;concepts&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> </ul>"},{"location":"api/bit__limits_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/bit__limits_8hpp/#classes","title":"Classes","text":"Type Name struct bit_limits &lt;BitWidth, int_t&gt;Similar to std::numeric_limits&lt;T&gt; except that this object can give properties of integral types of arbitrary bit widths. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/bit_limits.hpp</code></p>"},{"location":"api/bit__limits_8hpp_source/","title":"File bit_limits.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; bit_limits.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;concepts&gt;\n#include &lt;cstddef&gt;\n#include &lt;limits&gt;\n\nnamespace hal {\ntemplate&lt;size_t BitWidth, std::integral T&gt;\n[[nodiscard]] consteval T generate_field_of_ones()\n{\n  T result = 0;\n  for (size_t i = 0; i &lt; BitWidth; i++) {\n    result |= 1 &lt;&lt; i;\n  }\n  return result;\n}\n\ntemplate&lt;size_t BitWidth, std::integral int_t&gt;\nstruct bit_limits\n{\n  // Check that the bit width is less than or equal to the size of the int_t.\n  static_assert(BitWidth &lt;= sizeof(int_t) * 8,\n                \"The BitWidth exceed the number of bits in the integer type.\");\n\n  // Check that bit width is not zero.\n  static_assert(BitWidth != 0, \"The BitWidth cannot be 0.\");\n\n  [[nodiscard]] static constexpr int_t max()\n  {\n    if constexpr (std::is_signed_v&lt;int_t&gt;) {\n      int_t max = generate_field_of_ones&lt;BitWidth, int_t&gt;();\n      max = max &gt;&gt; 1;\n      return max;\n    } else {\n      int_t max = generate_field_of_ones&lt;BitWidth, int_t&gt;();\n      return max;\n    }\n  }\n\n  [[nodiscard]] static constexpr int_t min()\n  {\n    if constexpr (BitWidth == 64) {\n      return std::numeric_limits&lt;int_t&gt;::min();\n    } else if constexpr (std::is_signed_v&lt;int_t&gt;) {\n      int_t min = (1ULL &lt;&lt; BitWidth);\n      return min;\n    } else {\n      return 0U;\n    }\n  }\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal-util_2can_8hpp/","title":"File can.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; can.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;libhal/can.hpp&gt;</code></li> <li><code>#include \"comparison.hpp\"</code></li> <li><code>#include \"math.hpp\"</code></li> </ul>"},{"location":"api/libhal-util_2can_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/can.hpp</code></p>"},{"location":"api/libhal-util_2can_8hpp_source/","title":"File can.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; can.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cmath&gt;\n\n#include &lt;libhal/can.hpp&gt;\n\n#include \"comparison.hpp\"\n#include \"math.hpp\"\n\nnamespace hal {\n[[nodiscard]] constexpr auto operator==(const can::settings&amp; p_lhs,\n                                        const can::settings&amp; p_rhs)\n{\n  return equals(p_lhs.baud_rate, p_rhs.baud_rate) &amp;&amp;\n         p_lhs.propagation_delay == p_rhs.propagation_delay &amp;&amp;\n         p_lhs.phase_segment1 == p_rhs.phase_segment1 &amp;&amp;\n         p_lhs.phase_segment2 == p_rhs.phase_segment2 &amp;&amp;\n         p_lhs.synchronization_jump_width == p_rhs.synchronization_jump_width;\n}\n\n[[nodiscard]] constexpr std::uint16_t bit_width(const can::settings&amp; p_settings)\n{\n  // The sum of 4x 8-bit numbers can never exceed uint16_t and thus this\n  // operation is always safe.\n  return static_cast&lt;std::uint16_t&gt;(\n    p_settings.sync_segment + p_settings.propagation_delay +\n    p_settings.phase_segment1 + p_settings.phase_segment2);\n}\n\n[[nodiscard]] constexpr std::optional&lt;std::uint32_t&gt; is_valid(\n  const can::settings&amp; p_settings,\n  hertz p_operating_frequency)\n{\n  // 1. propagation_delay, phase_segment1, phase_segment2 and\n  //    synchronization_jump_width must be nonzero.\n  if (p_settings.propagation_delay == 0 || p_settings.phase_segment1 == 0 ||\n      p_settings.phase_segment2 == 0 ||\n      p_settings.synchronization_jump_width == 0) {\n    return std::nullopt;\n  }\n\n  // 2. synchronization_jump_width must be the lesser between phase_segment1\n  //    and phase_segment2.\n  if (p_settings.synchronization_jump_width &gt; 4 ||\n      p_settings.synchronization_jump_width &gt; p_settings.phase_segment1 ||\n      p_settings.synchronization_jump_width &gt; p_settings.phase_segment2) {\n    return std::nullopt;\n  }\n\n  const std::uint16_t bit_width_v = bit_width(p_settings);\n\n  // 3. The total bit width must be equal to or greater than 8 Tq/bit; the\n  //    sum of sync_segment, propagation_delay, phase_segment1 and\n  //    phase_segment2.\n  if (bit_width_v &lt; 8) {\n    return std::nullopt;\n  }\n\n  // 4. The CAN device's operating frequency must be at least 8 times the\n  //    bit rate to give the minimum.\n  // 5. The ratio between the CAN device's operating frequency and the bit\n  //    width must be close enough to an integer to produce a usable BRP.\n  const float bit_width_float = bit_width_v;\n  const float scaled_baud = p_settings.baud_rate * bit_width_float;\n  const float baud_rate_prescaler = p_operating_frequency / scaled_baud;\n  const auto final_prescaler = std::lround(baud_rate_prescaler);\n\n  if (final_prescaler == 0) {\n    return std::nullopt;\n  }\n\n  return final_prescaler;\n}\n\n[[nodiscard]] constexpr auto operator==(const can::message_t&amp; p_lhs,\n                                        const can::message_t&amp; p_rhs)\n{\n  bool payload_equal = p_lhs.payload == p_rhs.payload;\n  return payload_equal &amp;&amp; p_lhs.id == p_rhs.id &amp;&amp;\n         p_lhs.length == p_rhs.length &amp;&amp;\n         p_lhs.is_remote_request == p_rhs.is_remote_request;\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/comparison_8hpp/","title":"File comparison.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; comparison.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> </ul>"},{"location":"api/comparison_8hpp/#public-functions","title":"Public Functions","text":"Type Name constexpr bool operator!= (const std::array&lt; T, size &gt; &amp; p_array, const std::span&lt; T &gt; &amp; p_span)  constexpr bool operator!= (const std::span&lt; T &gt; &amp; p_span, const std::array&lt; T, size &gt; &amp; p_array)  constexpr bool operator== (const std::array&lt; T, size &gt; &amp; p_array, const std::span&lt; T &gt; &amp; p_span)  constexpr bool operator== (const std::span&lt; T &gt; &amp; p_span, const std::array&lt; T, size &gt; &amp; p_array)"},{"location":"api/comparison_8hpp/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"api/comparison_8hpp/#function-operator","title":"function operator!=","text":"<pre><code>template&lt;typename T typename T, size_t size&gt;\nconstexpr bool operator!= (\n    const std::array&lt; T, size &gt; &amp; p_array,\n    const std::span&lt; T &gt; &amp; p_span\n) \n</code></pre>"},{"location":"api/comparison_8hpp/#function-operator_1","title":"function operator!=","text":"<pre><code>template&lt;typename T typename T, size_t size&gt;\nconstexpr bool operator!= (\n    const std::span&lt; T &gt; &amp; p_span,\n    const std::array&lt; T, size &gt; &amp; p_array\n) \n</code></pre>"},{"location":"api/comparison_8hpp/#function-operator_2","title":"function operator==","text":"<pre><code>template&lt;typename T typename T, size_t size&gt;\nconstexpr bool operator== (\n    const std::array&lt; T, size &gt; &amp; p_array,\n    const std::span&lt; T &gt; &amp; p_span\n) \n</code></pre>"},{"location":"api/comparison_8hpp/#function-operator_3","title":"function operator==","text":"<pre><code>template&lt;typename T typename T, size_t size&gt;\nconstexpr bool operator== (\n    const std::span&lt; T &gt; &amp; p_span,\n    const std::array&lt; T, size &gt; &amp; p_array\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/comparison.hpp</code></p>"},{"location":"api/comparison_8hpp_source/","title":"File comparison.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; comparison.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;span&gt;\n\ntemplate&lt;typename T, size_t size&gt;\nconstexpr bool operator==(const std::array&lt;T, size&gt;&amp; p_array,\n                          const std::span&lt;T&gt;&amp; p_span)\n{\n  if (p_span.size() != size) {\n    return false;\n  }\n\n  return std::equal(p_array.begin(), p_array.end(), p_span.begin());\n}\n\ntemplate&lt;typename T, size_t size&gt;\nconstexpr bool operator==(const std::span&lt;T&gt;&amp; p_span,\n                          const std::array&lt;T, size&gt;&amp; p_array)\n{\n  return p_array == p_span;\n}\n\ntemplate&lt;typename T, size_t size&gt;\nconstexpr bool operator!=(const std::array&lt;T, size&gt;&amp; p_array,\n                          const std::span&lt;T&gt;&amp; p_span)\n{\n  return !(p_array == p_span);\n}\n\ntemplate&lt;typename T, size_t size&gt;\nconstexpr bool operator!=(const std::span&lt;T&gt;&amp; p_span,\n                          const std::array&lt;T, size&gt;&amp; p_array)\n{\n  return !(p_array == p_span);\n}\n</code></pre>"},{"location":"api/enum_8hpp/","title":"File enum.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; enum.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> </ul>"},{"location":"api/enum_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/enum.hpp</code></p>"},{"location":"api/enum_8hpp_source/","title":"File enum.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; enum.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;type_traits&gt;\n\n#include &lt;libhal/units.hpp&gt;\n\nnamespace hal {\ntemplate&lt;typename T&gt;\nconcept enumeration = std::is_enum_v&lt;T&gt;;\n\n[[nodiscard]] constexpr auto value(enumeration auto p_enum_value)\n{\n  return static_cast&lt;std::underlying_type_t&lt;decltype(p_enum_value)&gt;&gt;(\n    p_enum_value);\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal-util_2i2c_8hpp/","title":"File i2c.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; i2c.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;libhal/error.hpp&gt;</code></li> <li><code>#include &lt;libhal/i2c.hpp&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> <li><code>#include \"enum.hpp\"</code></li> <li><code>#include \"math.hpp\"</code></li> </ul>"},{"location":"api/libhal-util_2i2c_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/i2c.hpp</code></p>"},{"location":"api/libhal-util_2i2c_8hpp_source/","title":"File i2c.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; i2c.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;functional&gt;\n\n#include &lt;libhal/error.hpp&gt;\n#include &lt;libhal/i2c.hpp&gt;\n#include &lt;libhal/units.hpp&gt;\n\n#include \"enum.hpp\"\n#include \"math.hpp\"\n\nnamespace hal {\n[[nodiscard]] constexpr auto operator==(const i2c::settings&amp; p_lhs,\n                                        const i2c::settings&amp; p_rhs)\n{\n  return equals(p_lhs.clock_rate, p_rhs.clock_rate);\n}\n\n[[nodiscard]] inline hal::result&lt;hal::i2c::transaction_t&gt; write(\n  i2c&amp; p_i2c,\n  hal::byte p_address,\n  std::span&lt;const hal::byte&gt; p_data_out,\n  timeout auto p_timeout)\n{\n  return p_i2c.transaction(\n    p_address, p_data_out, std::span&lt;hal::byte&gt;{}, p_timeout);\n}\n\n[[nodiscard]] inline hal::result&lt;hal::i2c::transaction_t&gt;\nwrite(i2c&amp; p_i2c, hal::byte p_address, std::span&lt;const hal::byte&gt; p_data_out)\n{\n  return write(p_i2c, p_address, p_data_out, hal::never_timeout());\n}\n\n[[nodiscard]] inline hal::result&lt;hal::i2c::transaction_t&gt; read(\n  i2c&amp; p_i2c,\n  hal::byte p_address,\n  std::span&lt;hal::byte&gt; p_data_in,\n  timeout auto p_timeout)\n{\n  return p_i2c.transaction(\n    p_address, std::span&lt;hal::byte&gt;{}, p_data_in, p_timeout);\n}\n\n[[nodiscard]] inline hal::result&lt;hal::i2c::transaction_t&gt;\nread(i2c&amp; p_i2c, hal::byte p_address, std::span&lt;hal::byte&gt; p_data_in)\n{\n  return read(p_i2c, p_address, p_data_in, hal::never_timeout());\n}\n\ntemplate&lt;size_t BytesToRead&gt;\n[[nodiscard]] result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt;\nread(i2c&amp; p_i2c, hal::byte p_address, timeout auto p_timeout)\n{\n  std::array&lt;hal::byte, BytesToRead&gt; buffer;\n  HAL_CHECK(read(p_i2c, p_address, buffer, p_timeout));\n  return buffer;\n}\n\ntemplate&lt;size_t BytesToRead&gt;\n[[nodiscard]] result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; read(\n  i2c&amp; p_i2c,\n  hal::byte p_address)\n{\n  return read&lt;BytesToRead&gt;(p_i2c, p_address, hal::never_timeout());\n}\n\n[[nodiscard]] inline hal::result&lt;hal::i2c::transaction_t&gt; write_then_read(\n  i2c&amp; p_i2c,\n  hal::byte p_address,\n  std::span&lt;const hal::byte&gt; p_data_out,\n  std::span&lt;hal::byte&gt; p_data_in,\n  timeout auto p_timeout = hal::never_timeout())\n{\n  return p_i2c.transaction(p_address, p_data_out, p_data_in, p_timeout);\n}\n\n[[nodiscard]] inline hal::result&lt;hal::i2c::transaction_t&gt; write_then_read(\n  i2c&amp; p_i2c,\n  hal::byte p_address,\n  std::span&lt;const hal::byte&gt; p_data_out,\n  std::span&lt;hal::byte&gt; p_data_in)\n{\n  return write_then_read(\n    p_i2c, p_address, p_data_out, p_data_in, hal::never_timeout());\n}\n\ntemplate&lt;size_t BytesToRead&gt;\n[[nodiscard]] result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; write_then_read(\n  i2c&amp; p_i2c,\n  hal::byte p_address,\n  std::span&lt;const hal::byte&gt; p_data_out,\n  timeout auto p_timeout)\n{\n  std::array&lt;hal::byte, BytesToRead&gt; buffer;\n  HAL_CHECK(write_then_read(p_i2c, p_address, p_data_out, buffer, p_timeout));\n  return buffer;\n}\n\ntemplate&lt;size_t BytesToRead&gt;\n[[nodiscard]] result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; write_then_read(\n  i2c&amp; p_i2c,\n  hal::byte p_address,\n  std::span&lt;const hal::byte&gt; p_data_out)\n{\n  return write_then_read&lt;BytesToRead&gt;(\n    p_i2c, p_address, p_data_out, hal::never_timeout());\n}\n\n[[nodiscard]] inline hal::result&lt;hal::i2c::transaction_t&gt; probe(\n  i2c&amp; p_i2c,\n  hal::byte p_address)\n{\n  // p_data_in: empty placeholder for transcation's data_in\n  std::array&lt;hal::byte, 1&gt; data_in;\n\n  // p_timeout: no timeout placeholder for transaction's p_timeout\n  timeout auto timeout = hal::never_timeout();\n\n  return p_i2c.transaction(p_address, std::span&lt;hal::byte&gt;{}, data_in, timeout);\n}\n\nenum class i2c_operation\n{\n  write = 0,\n  read = 1,\n};\n\n[[nodiscard]] inline hal::byte to_8_bit_address(\n  hal::byte p_address,\n  i2c_operation p_operation) noexcept\n{\n  hal::byte v8bit_address = static_cast&lt;hal::byte&gt;(p_address &lt;&lt; 1);\n  v8bit_address |= hal::value(p_operation);\n  return v8bit_address;\n}\n\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal-util_2input__pin_8hpp/","title":"File input_pin.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; input_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/input_pin.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-util_2input__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/input_pin.hpp</code></p>"},{"location":"api/libhal-util_2input__pin_8hpp_source/","title":"File input_pin.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; input_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/input_pin.hpp&gt;\n\nnamespace hal {\n[[nodiscard]] constexpr auto operator==(const input_pin::settings&amp; p_lhs,\n                                        const input_pin::settings&amp; p_rhs)\n{\n  return p_lhs.resistor == p_rhs.resistor;\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal-util_2interrupt__pin_8hpp/","title":"File interrupt_pin.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; interrupt_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/interrupt_pin.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-util_2interrupt__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/interrupt_pin.hpp</code></p>"},{"location":"api/libhal-util_2interrupt__pin_8hpp_source/","title":"File interrupt_pin.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; interrupt_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/interrupt_pin.hpp&gt;\n\nnamespace hal {\n[[nodiscard]] constexpr auto operator==(const interrupt_pin::settings&amp; p_lhs,\n                                        const interrupt_pin::settings&amp; p_rhs)\n{\n  return p_lhs.resistor == p_rhs.resistor &amp;&amp; p_lhs.trigger == p_rhs.trigger;\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/map_8hpp/","title":"File map.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; map.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include \"math.hpp\"</code></li> </ul>"},{"location":"api/map_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/map.hpp</code></p>"},{"location":"api/map_8hpp_source/","title":"File map.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; map.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;algorithm&gt;\n\n#include \"math.hpp\"\n\nnamespace hal {\n\n[[nodiscard]] constexpr float map(float p_target,\n                                  std::pair&lt;float, float&gt; p_input_range,\n                                  std::pair&lt;float, float&gt; p_output_range)\n{\n  const float x = p_target;\n  const auto [a, b] = std::minmax(p_input_range.first, p_input_range.second);\n  const auto [c, d] = std::minmax(p_output_range.first, p_output_range.second);\n\n  const float shift_input = x - a;\n  const float ratio = (d - c) / (b - a);\n  const float y = (shift_input * ratio) + c;\n  const float clamped_y = std::clamp(y, c, d);\n\n  return clamped_y;\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/math_8hpp/","title":"File math.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; math.hpp</p> <p>Go to the source code of this file</p> <p>Compile time generic math utility functions. </p> <ul> <li><code>#include &lt;concepts&gt;</code></li> <li><code>#include &lt;limits&gt;</code></li> <li><code>#include &lt;libhal/error.hpp&gt;</code></li> </ul>"},{"location":"api/math_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/math.hpp</code></p>"},{"location":"api/math_8hpp_source/","title":"File math.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; math.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;concepts&gt;\n#include &lt;limits&gt;\n\n#include &lt;libhal/error.hpp&gt;\n\nnamespace hal {\ntemplate&lt;typename T&gt;\n[[nodiscard]] result&lt;T&gt; multiply(T p_lhs, T p_rhs)\n{\n  if (p_lhs == 0 || p_rhs == 0) {\n    return T{ 0 };\n  }\n\n  T result = p_lhs * p_rhs;\n\n  if (p_lhs != result / p_rhs) {\n    return hal::new_error(std::errc::result_out_of_range);\n  }\n\n  return result;\n}\n\ntemplate&lt;typename T&gt;\n[[nodiscard]] constexpr T absolute_value(T p_value)\n{\n  if constexpr (std::is_unsigned_v&lt;T&gt;) {\n    return p_value;\n  } else {\n    if (p_value &gt;= 0) {\n      return p_value;\n    }\n    if (p_value == std::numeric_limits&lt;T&gt;::min()) {\n      return std::numeric_limits&lt;T&gt;::max();\n    }\n    return -p_value;\n  }\n}\n\ntemplate&lt;typename T&gt;\n[[nodiscard]] constexpr T rounding_division(T p_numerator, T p_denominator)\n{\n  bool num_sign = p_numerator &gt;= 0;\n  bool den_sign = p_denominator &gt;= 0;\n\n  auto numerator = absolute_value(p_numerator);\n  auto denominator = absolute_value(p_denominator);\n\n  if (denominator &gt; numerator || denominator == 0) {\n    return T{ 0 };\n  }\n\n  const T remainder = numerator % denominator;\n  const T half_denominator = (denominator / 2);\n  T quotient = numerator / denominator;\n  // Round if remainder is greater than half of the denominator\n  if (half_denominator != 0 &amp;&amp; remainder &gt;= half_denominator) {\n    quotient++;\n  }\n\n  if (num_sign != den_sign) {\n    return -quotient;\n  }\n\n  return quotient;\n}\n\ntemplate&lt;typename T&gt;\n[[nodiscard]] constexpr T distance(T p_left, T p_right)\n{\n  if (p_right &gt; p_left) {\n    return p_right - p_left;\n  } else {\n    return p_left - p_right;\n  }\n}\n\ntemplate&lt;std::integral T&gt;\n[[nodiscard]] constexpr std::make_unsigned_t&lt;T&gt; distance(T p_left, T p_right)\n{\n  static_assert(sizeof(T) &lt;= sizeof(int32_t));\n\n  using unsigned_t = std::make_unsigned_t&lt;T&gt;;\n  // Put left and right values into 64-bit containers to prevent overflow\n  int64_t left{ p_left };\n  int64_t right{ p_right };\n\n  if (right &gt; left) {\n    // Subtraction operation on right to left in this order can never overflow\n    // because the maximum resultant of left and right being INT32_MAX and\n    // INT32_MIN, will equal UINT32_MAX which can be stored within an int64_t\n    // value.\n    int64_t difference = right - left;\n    // Casting this value to the unsigned variant will always fit as the\n    // distance between any 32-bit signed numbers can always fit in a 32-bit\n    // unsigned number.\n    return static_cast&lt;unsigned_t&gt;(difference);\n  } else {\n    // Same logic as the if statement block above.\n    int64_t difference = left - right;\n    return static_cast&lt;unsigned_t&gt;(difference);\n  }\n}\nconstexpr static bool equals(std::floating_point auto p_value1,\n                             std::floating_point auto p_value2,\n                             float p_epsilon = 1e-9f)\n{\n  if (p_value1 == p_value2) {\n    return true;\n  }\n  auto value1_abs = std::abs(p_value1);\n  auto value2_abs = std::abs(p_value2);\n  auto diff = std::abs(p_value1 - p_value2);\n  auto absolute_values_sum = value1_abs + value2_abs;\n\n  using float_t = decltype(absolute_values_sum);\n\n  if (p_value1 == 0 || p_value2 == 0 ||\n      (absolute_values_sum &lt; std::numeric_limits&lt;float_t&gt;::min())) {\n    return diff &lt; (p_epsilon * std::numeric_limits&lt;float_t&gt;::min());\n  } else {\n    auto relative_error =\n      diff / std::min(absolute_values_sum, std::numeric_limits&lt;float_t&gt;::max());\n    return relative_error &lt; p_epsilon;\n  }\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/move__interceptor_8hpp/","title":"File move_interceptor.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; move_interceptor.hpp</p> <p>Go to the source code of this file</p>"},{"location":"api/move__interceptor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/move__interceptor_8hpp/#classes","title":"Classes","text":"Type Name class move_interceptor &lt;class T&gt;Use this to perform changes on an object its move constructor is executed. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/move_interceptor.hpp</code></p>"},{"location":"api/move__interceptor_8hpp_source/","title":"File move_interceptor.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; move_interceptor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\nnamespace hal {\n\ntemplate&lt;class T&gt;\nclass move_interceptor\n{\npublic:\n  friend T;\n\nprivate:\n  void intercept(T* p_previous)\n  {\n    static_cast&lt;T*&gt;(this)-&gt;intercept(p_previous);\n  }\n\n  move_interceptor() = default;\n  move_interceptor(move_interceptor&amp; p_previous) = delete;\n  move_interceptor&amp; operator=(move_interceptor&amp; p_previous) = delete;\n  move_interceptor(move_interceptor&amp;&amp; p_previous)\n  {\n    intercept(static_cast&lt;T*&gt;(&amp;p_previous));\n  }\n  move_interceptor&amp; operator=(move_interceptor&amp;&amp; p_previous)\n  {\n    intercept(static_cast&lt;T*&gt;(&amp;p_previous));\n    return *this;\n  }\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal-util_2output__pin_8hpp/","title":"File output_pin.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; output_pin.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/output_pin.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-util_2output__pin_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/output_pin.hpp</code></p>"},{"location":"api/libhal-util_2output__pin_8hpp_source/","title":"File output_pin.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; output_pin.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/output_pin.hpp&gt;\n\nnamespace hal {\n[[nodiscard]] constexpr auto operator==(const output_pin::settings&amp; p_lhs,\n                                        const output_pin::settings&amp; p_rhs)\n{\n  return p_lhs.resistor == p_rhs.resistor &amp;&amp;\n         p_lhs.open_drain == p_rhs.open_drain;\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/overflow__counter_8hpp/","title":"File overflow_counter.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; overflow_counter.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include \"bit_limits.hpp\"</code></li> </ul>"},{"location":"api/overflow__counter_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/overflow__counter_8hpp/#classes","title":"Classes","text":"Type Name class overflow_counter &lt;CountBitWidth&gt;Extend a counter's count from an arbitrary bit width to 64-bits by detecting overflows in the count. Each detected overflow is added to an overflow counter which is combined with the current count in order create a count up to 64-bits in length. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/overflow_counter.hpp</code></p>"},{"location":"api/overflow__counter_8hpp_source/","title":"File overflow_counter.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; overflow_counter.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdint&gt;\n\n#include \"bit_limits.hpp\"\n\nnamespace hal {\ntemplate&lt;size_t CountBitWidth = 32&gt;\nclass overflow_counter\n{\npublic:\n  static_assert(CountBitWidth &lt;= 32, \"Bit width cannot exceed 32-bits\");\n  static_assert(CountBitWidth &gt; 1, \"Bit width must be greater than 1\");\n  constexpr uint64_t update(uint32_t p_new_count)\n  {\n    // Sanitize the new count value to make sure it does not exceed the\n    // designated bit width. Without this check when the count is combined with\n    // the overflow value the upper bits may effect the bits of the overflow\n    // count, getting an incorrect count value.\n    constexpr auto mask = generate_field_of_ones&lt;CountBitWidth, uint32_t&gt;();\n    p_new_count = p_new_count &amp; mask;\n\n    // Detect the overflow by checking if the new count is smaller than the\n    // previous count. If the count is always increasing, the only way for the\n    // new count to be smaller is if the count reached the end of its bit width\n    // and overflowed.\n    if (m_previous_count &gt; p_new_count) {\n      m_overflow_count++;\n    }\n\n    // Set previous count to the new count\n    m_previous_count = p_new_count;\n\n    // Move overflow count up to the upper bits of the 64-bit number based on\n    // CountBitWidth\n    uint64_t combined_count = m_overflow_count;\n    combined_count &lt;&lt;= CountBitWidth;\n    // Add the p_new_count into the combined count to complete it.\n    combined_count |= p_new_count;\n\n    return combined_count;\n  }\n\n  constexpr void reset()\n  {\n    m_previous_count = 0;\n    m_overflow_count = 0;\n  }\n\nprivate:\n  uint32_t m_previous_count = 0;\n  uint32_t m_overflow_count = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal-util_2serial_8hpp/","title":"File serial.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; serial.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdio&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> <li><code>#include &lt;libhal/error.hpp&gt;</code></li> <li><code>#include &lt;libhal/serial.hpp&gt;</code></li> <li><code>#include &lt;libhal/timeout.hpp&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> <li><code>#include \"as_bytes.hpp\"</code></li> <li><code>#include \"comparison.hpp\"</code></li> <li><code>#include \"math.hpp\"</code></li> </ul>"},{"location":"api/libhal-util_2serial_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/serial.hpp</code></p>"},{"location":"api/libhal-util_2serial_8hpp_source/","title":"File serial.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; serial.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstdio&gt;\n#include &lt;span&gt;\n#include &lt;string_view&gt;\n\n#include &lt;libhal/error.hpp&gt;\n#include &lt;libhal/serial.hpp&gt;\n#include &lt;libhal/timeout.hpp&gt;\n#include &lt;libhal/units.hpp&gt;\n\n#include \"as_bytes.hpp\"\n#include \"comparison.hpp\"\n#include \"math.hpp\"\n\nnamespace hal {\n\n[[nodiscard]] constexpr auto operator==(const serial::settings&amp; p_lhs,\n                                        const serial::settings&amp; p_rhs)\n{\n  return equals(p_lhs.baud_rate, p_rhs.baud_rate) &amp;&amp;\n         p_lhs.parity == p_rhs.parity &amp;&amp; p_lhs.stop == p_rhs.stop;\n}\n[[nodiscard]] inline result&lt;serial::write_t&gt; write_partial(\n  serial&amp; p_serial,\n  std::span&lt;const hal::byte&gt; p_data_out)\n{\n  return p_serial.write(p_data_out);\n}\n\n[[nodiscard]] inline status write(serial&amp; p_serial,\n                                  std::span&lt;const hal::byte&gt; p_data_out)\n{\n  auto remaining = p_data_out;\n\n  while (remaining.size() != 0) {\n    auto write_length = HAL_CHECK(p_serial.write(remaining)).data.size();\n    remaining = remaining.subspan(write_length);\n  }\n\n  return success();\n}\n\n[[nodiscard]] inline status write(serial&amp; p_serial, std::string_view p_data_out)\n{\n  return write(p_serial, as_bytes(p_data_out));\n}\n\n[[nodiscard]] inline result&lt;std::span&lt;hal::byte&gt;&gt;\nread(serial&amp; p_serial, std::span&lt;hal::byte&gt; p_data_in, timeout auto p_timeout)\n{\n  auto remaining = p_data_in;\n\n  while (remaining.size() != 0) {\n    auto read_length = HAL_CHECK(p_serial.read(remaining)).data.size();\n    remaining = remaining.subspan(read_length);\n    HAL_CHECK(p_timeout());\n  }\n\n  return p_data_in;\n}\n\ntemplate&lt;size_t BytesToRead&gt;\n[[nodiscard]] result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; read(\n  serial&amp; p_serial,\n  timeout auto p_timeout)\n{\n  std::array&lt;hal::byte, BytesToRead&gt; buffer;\n  HAL_CHECK(read(p_serial, buffer, p_timeout));\n  return buffer;\n}\n\n[[nodiscard]] inline result&lt;std::span&lt;hal::byte&gt;&gt; write_then_read(\n  serial&amp; p_serial,\n  std::span&lt;const hal::byte&gt; p_data_out,\n  std::span&lt;hal::byte&gt; p_data_in,\n  timeout auto p_timeout)\n{\n  HAL_CHECK(write_partial(p_serial, p_data_out));\n  return read(p_serial, p_data_in, p_timeout);\n}\n\ntemplate&lt;size_t BytesToRead&gt;\n[[nodiscard]] result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; write_then_read(\n  serial&amp; p_serial,\n  std::span&lt;const hal::byte&gt; p_data_out,\n  timeout auto p_timeout)\n{\n  std::array&lt;hal::byte, BytesToRead&gt; buffer;\n  HAL_CHECK(write_then_read(p_serial, p_data_out, buffer, p_timeout));\n  return buffer;\n}\n\ntemplate&lt;typename DataArray&gt;\nvoid print(serial&amp; p_serial, DataArray&amp;&amp; p_data)\n{\n  (void)hal::write(p_serial, p_data);\n}\n\ntemplate&lt;size_t BufferSize, typename... Parameters&gt;\nvoid print(serial&amp; p_serial, const char* p_format, Parameters... p_parameters)\n{\n  static_assert(BufferSize &gt; 2);\n\n  std::array&lt;char, BufferSize&gt; buffer{};\n  constexpr int unterminated_max_string_size = static_cast&lt;int&gt;(BufferSize) - 1;\n\n  int length =\n    std::snprintf(buffer.data(), buffer.size(), p_format, p_parameters...);\n\n  if (length &gt; unterminated_max_string_size) {\n    // Print out what was able to be written to the buffer\n    length = unterminated_max_string_size;\n  }\n\n  (void)hal::write(p_serial, std::string_view(buffer.data(), length));\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/serial__coroutines_8hpp/","title":"File serial_coroutines.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; serial_coroutines.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cctype&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;libhal/error.hpp&gt;</code></li> <li><code>#include &lt;libhal/serial.hpp&gt;</code></li> <li><code>#include &lt;libhal/timeout.hpp&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> <li><code>#include \"as_bytes.hpp\"</code></li> <li><code>#include \"comparison.hpp\"</code></li> <li><code>#include \"enum.hpp\"</code></li> </ul>"},{"location":"api/serial__coroutines_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/serial__coroutines_8hpp/#classes","title":"Classes","text":"Type Name class read_into Non-blocking callable for reading serial data into a buffer. class read_uint32 Read bytes from serial port and convert to integer. class read_upto Discard received bytes until the sequence is found. class skip_past Discard received bytes until the sequence is found. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/serial_coroutines.hpp</code></p>"},{"location":"api/serial__coroutines_8hpp_source/","title":"File serial_coroutines.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; serial_coroutines.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cctype&gt;\n#include &lt;cstdint&gt;\n#include &lt;optional&gt;\n#include &lt;span&gt;\n\n#include &lt;libhal/error.hpp&gt;\n#include &lt;libhal/serial.hpp&gt;\n#include &lt;libhal/timeout.hpp&gt;\n#include &lt;libhal/units.hpp&gt;\n\n#include \"as_bytes.hpp\"\n#include \"comparison.hpp\"\n#include \"enum.hpp\"\n\nnamespace hal {\nclass skip_past\n{\npublic:\n  skip_past(serial&amp; p_serial,\n            std::span&lt;const hal::byte&gt; p_sequence,\n            size_t p_read_limit = 32)\n    : m_serial(&amp;p_serial)\n    , m_sequence(p_sequence)\n    , m_read_limit(p_read_limit)\n  {\n  }\n\n  result&lt;work_state&gt; operator()()\n  {\n    if (m_search_index == m_sequence.size()) {\n      return work_state::finished;\n    }\n\n    for (size_t read_limit = 0; read_limit &lt; m_read_limit; read_limit++) {\n      std::array&lt;hal::byte, 1&gt; buffer;\n      auto read_result = HAL_CHECK(m_serial-&gt;read(buffer));\n\n      if (read_result.data.size() != buffer.size()) {\n        return work_state::in_progress;\n      }\n\n      // Check if the next byte received matches the sequence\n      if (m_sequence[m_search_index] == read_result.data[0]) {\n        m_search_index++;\n      } else {  // Otherwise set the search index back to the start.\n        m_search_index = 0;\n      }\n\n      // Check if the search index is equal to the size of the sequence size\n      if (m_search_index == m_sequence.size()) {\n        return work_state::finished;\n      }\n    }\n\n    return work_state::in_progress;\n  }\n\nprivate:\n  serial* m_serial;\n  std::span&lt;const hal::byte&gt; m_sequence;\n  size_t m_read_limit;\n  size_t m_search_index = 0;\n};\n\nclass read_into\n{\npublic:\n  read_into(serial&amp; p_serial,\n            std::span&lt;hal::byte&gt; p_buffer,\n            size_t p_read_limit = 32)\n    : m_serial(&amp;p_serial)\n    , m_buffer(p_buffer)\n    , m_read_limit(p_read_limit)\n  {\n  }\n\n  result&lt;work_state&gt; operator()()\n  {\n    for (size_t read_limit = 0; read_limit &lt; m_read_limit; read_limit++) {\n      if (m_buffer.empty()) {\n        return work_state::finished;\n      }\n\n      auto read_result = HAL_CHECK(m_serial-&gt;read(m_buffer));\n      // Set the m_buffer to the amount of bytes remaining to be read.\n      m_buffer = m_buffer.subspan(read_result.data.size());\n\n      if (read_result.data.empty()) {\n        return work_state::in_progress;\n      }\n    }\n\n    return work_state::in_progress;\n  }\n\nprivate:\n  serial* m_serial;\n  std::span&lt;hal::byte&gt; m_buffer;\n  size_t m_read_limit;\n};\n\nclass read_upto\n{\npublic:\n  read_upto(serial&amp; p_serial,\n            std::span&lt;const hal::byte&gt; p_sequence,\n            std::span&lt;hal::byte&gt; p_buffer,\n            size_t p_read_limit = 32)\n    : m_serial(&amp;p_serial)\n    , m_sequence(p_sequence)\n    , m_buffer(p_buffer)\n    , m_read_limit(p_read_limit)\n  {\n  }\n\n  result&lt;work_state&gt; operator()()\n  {\n    static constexpr size_t read_length = 1;\n    if (m_search_index == m_sequence.size()) {\n      return work_state::finished;\n    }\n    if (m_buffer.empty()) {\n      return work_state::failed;\n    }\n\n    for (size_t read_limit = 0; read_limit &lt; m_read_limit; read_limit++) {\n      auto read_result =\n        HAL_CHECK(m_serial-&gt;read(m_buffer.subspan(0, read_length)));\n\n      if (read_result.data.size() == 0) {\n        return work_state::in_progress;\n      }\n\n      // Check if the next byte received matches the sequence\n      if (m_sequence[m_search_index] == read_result.data[0]) {\n        m_search_index++;\n      } else {  // Otherwise set the search index back to the start.\n        m_search_index = 0;\n      }\n\n      // Check if the search index is equal to the size of the sequence size\n      if (m_search_index == m_sequence.size()) {\n        return work_state::finished;\n      }\n\n      m_buffer = m_buffer.subspan(read_length);\n\n      if (m_buffer.empty()) {\n        return work_state::failed;\n      }\n    }\n\n    return work_state::in_progress;\n  }\n\nprivate:\n  serial* m_serial;\n  std::span&lt;const hal::byte&gt; m_sequence;\n  std::span&lt;hal::byte&gt; m_buffer;\n  size_t m_read_limit;\n  size_t m_search_index = 0;\n};\n\nclass read_uint32\n{\npublic:\n  read_uint32(serial&amp; p_serial, size_t p_read_limit = 32)\n    : m_serial(&amp;p_serial)\n    , m_read_limit(p_read_limit)\n  {\n  }\n\n  result&lt;work_state&gt; operator()()\n  {\n    if (m_finished) {\n      return work_state::finished;\n    }\n\n    for (size_t read_limit = 0; read_limit &lt; m_read_limit; read_limit++) {\n      std::array&lt;hal::byte, 1&gt; buffer;\n      auto read_result = HAL_CHECK(m_serial-&gt;read(buffer));\n\n      if (read_result.data.size() != buffer.size()) {\n        return work_state::in_progress;\n      }\n\n      if (std::isdigit(static_cast&lt;char&gt;(read_result.data[0]))) {\n        m_integer_value *= 10;\n        m_integer_value += read_result.data[0] - hal::byte('0');\n        m_found_digit = true;\n      } else if (m_found_digit) {\n        m_finished = true;\n        return work_state::finished;\n      }\n    }\n\n    return work_state::in_progress;\n  }\n\n  std::optional&lt;uint32_t&gt; get()\n  {\n    if (!m_finished) {\n      return std::nullopt;\n    }\n    return m_integer_value;\n  }\n\nprivate:\n  serial* m_serial;\n  size_t m_read_limit;\n  std::uint32_t m_integer_value = 0;\n  bool m_found_digit = false;\n  bool m_finished = false;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal-util_2spi_8hpp/","title":"File spi.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; spi.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;libhal/error.hpp&gt;</code></li> <li><code>#include &lt;libhal/spi.hpp&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> </ul>"},{"location":"api/libhal-util_2spi_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/spi.hpp</code></p>"},{"location":"api/libhal-util_2spi_8hpp_source/","title":"File spi.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; spi.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;span&gt;\n\n#include &lt;libhal/error.hpp&gt;\n#include &lt;libhal/spi.hpp&gt;\n#include &lt;libhal/units.hpp&gt;\n\nnamespace hal {\n[[nodiscard]] constexpr auto operator==(const spi::settings&amp; p_lhs,\n                                        const spi::settings&amp; p_rhs)\n{\n  return p_lhs.clock_idles_high == p_rhs.clock_idles_high &amp;&amp;\n         p_lhs.clock_rate == p_rhs.clock_rate &amp;&amp;\n         p_lhs.data_valid_on_trailing_edge == p_rhs.data_valid_on_trailing_edge;\n}\n\n[[nodiscard]] inline result&lt;hal::spi::transfer_t&gt; write(\n  spi&amp; p_spi,\n  std::span&lt;const hal::byte&gt; p_data_out)\n{\n  return p_spi.transfer(\n    p_data_out, std::span&lt;hal::byte&gt;{}, spi::default_filler);\n}\n\n[[nodiscard]] inline result&lt;hal::spi::transfer_t&gt; read(\n  spi&amp; p_spi,\n  std::span&lt;hal::byte&gt; p_data_in,\n  hal::byte p_filler = spi::default_filler)\n{\n  return p_spi.transfer(std::span&lt;hal::byte&gt;{}, p_data_in, p_filler);\n}\ntemplate&lt;size_t BytesToRead&gt;\n[[nodiscard]] result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; read(\n  spi&amp; p_spi,\n  hal::byte p_filler = spi::default_filler)\n{\n  std::array&lt;hal::byte, BytesToRead&gt; buffer;\n  HAL_CHECK(p_spi.transfer(std::span&lt;hal::byte&gt;{}, buffer, p_filler));\n  return buffer;\n}\n\n[[nodiscard]] inline result&lt;hal::spi::transfer_t&gt; write_then_read(\n  spi&amp; p_spi,\n  std::span&lt;const hal::byte&gt; p_data_out,\n  std::span&lt;hal::byte&gt; p_data_in,\n  hal::byte p_filler = spi::default_filler)\n{\n  HAL_CHECK(write(p_spi, p_data_out));\n  HAL_CHECK(read(p_spi, p_data_in, p_filler));\n  return {};\n}\n\ntemplate&lt;size_t BytesToRead&gt;\n[[nodiscard]] result&lt;std::array&lt;hal::byte, BytesToRead&gt;&gt; write_then_read(\n  spi&amp; p_spi,\n  std::span&lt;const hal::byte&gt; p_data_out,\n  hal::byte p_filler = spi::default_filler)\n{\n  HAL_CHECK(write(p_spi, p_data_out));\n  return read&lt;BytesToRead&gt;(p_spi, p_filler);\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/static__callable_8hpp/","title":"File static_callable.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; static_callable.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/functional.hpp&gt;</code></li> </ul>"},{"location":"api/static__callable_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/static__callable_8hpp/#classes","title":"Classes","text":"Type Name class static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt; &lt;class owner_class, reference_designator, typename return_t, args_t&gt;Specialization of static_callable with the return type and arguments split up. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/static_callable.hpp</code></p>"},{"location":"api/static__callable_8hpp_source/","title":"File static_callable.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; static_callable.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/functional.hpp&gt;\n\nnamespace hal {\ntemplate&lt;class owner_class, int reference_designator, typename signature&gt;\nclass static_callable;\n\ntemplate&lt;class owner_class,\n         int reference_designator,\n         typename return_t,\n         typename... args_t&gt;\nclass static_callable&lt;owner_class,\n                      reference_designator,\n                      return_t(args_t... p_args)&gt;\n{\npublic:\n  explicit static_callable(hal::callback&lt;return_t(args_t... p_args)&gt; p_callback)\n  {\n    callback = p_callback;\n  }\n\n  [[nodiscard]] auto* get_handler()\n  {\n    return &amp;handler;\n  }\n\nprivate:\n  static return_t handler(args_t... p_args)\n  {\n    return callback(p_args...);\n  }\n\n  inline static hal::callback&lt;return_t(args_t... p_args)&gt; callback;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/static__list_8hpp/","title":"File static_list.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; static_list.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;iterator&gt;</code></li> <li><code>#include &lt;utility&gt;</code></li> </ul>"},{"location":"api/static__list_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/static__list_8hpp/#classes","title":"Classes","text":"Type Name class static_list &lt;class Object&gt;static_list is a non-owning non-allocating doubly linked list container with O(1) memory utilization. class item Item/node within the static linked list. class item_iterator Iterator for the static list. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/static_list.hpp</code></p>"},{"location":"api/static__list_8hpp_source/","title":"File static_list.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; static_list.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;iterator&gt;\n#include &lt;utility&gt;\n\nnamespace hal {\ntemplate&lt;class Object&gt;\nclass static_list\n{\npublic:\n  class item_iterator;\n\n  class item\n  {\n  public:\n    friend class item_iterator;\n    friend class static_list;\n\n    constexpr item(static_list* p_list, const Object&amp; p_object)\n      : m_list(p_list)\n      , m_object(p_object)\n    {\n      setup_self();\n    }\n\n    constexpr item(static_list* p_list, Object&amp;&amp; p_object)\n      : m_list(p_list)\n      , m_object(std::move(p_object))\n    {\n      setup_self();\n    }\n\n    constexpr item&amp; operator=(item&amp; p_other) = delete;\n    constexpr item(item&amp; p_other) = delete;\n\n    constexpr item&amp; operator=(item&amp;&amp; p_other)\n    {\n      m_object = std::move(p_other.m_object);\n      m_list = p_other.m_list;\n      m_previous = p_other.m_previous;\n      m_next = p_other.m_next;\n\n      if (!m_list) {\n        return *this;\n      }\n\n      // Reassign head\n      if (m_list-&gt;m_head == &amp;p_other) {\n        m_list-&gt;m_head = this;\n      } else {\n        // If this isn't the head then there MUST be a PREVIOUS node\n        // This still works if \"m_next\" is nullptr\n        m_previous-&gt;m_next = this;\n      }\n\n      if (m_list-&gt;m_tail == &amp;p_other) {\n        m_list-&gt;m_tail = this;\n      } else {\n        // If this isn't the tail then there MUST be a NEXT node\n        // This still works if \"m_previous\" is nullptr\n        m_next-&gt;m_previous = this;\n      }\n\n      // Mark p_other as invalid such that destructor will exit early\n      p_other.m_list = nullptr;\n\n      return *this;\n    }\n\n    constexpr item(item&amp;&amp; p_other)\n    {\n      *this = std::move(p_other);\n    }\n\n    auto&amp; get()\n    {\n      return m_object;\n    }\n\n    const auto&amp; get() const\n    {\n      return m_object;\n    }\n\n    auto&amp; operator*()\n    {\n      return m_object;\n    }\n\n    const auto&amp; operator*() const\n    {\n      return m_object;\n    }\n\n    const auto* list() const\n    {\n      return m_list;\n    }\n\n    ~item()\n    {\n      // Skip re-arranging the list\n      // Skip deducting the size of the list\n      if (!m_list) {\n        return;\n      }\n\n      // Reassign head\n      if (m_list-&gt;m_head == this) {\n        m_list-&gt;m_head = m_next;\n      } else {\n        // If this isn't the head then there MUST be a PREVIOUS node\n        // This still works if \"m_next\" is nullptr\n        m_previous-&gt;m_next = m_next;\n      }\n\n      if (m_list-&gt;m_tail == this) {\n        m_list-&gt;m_tail = m_previous;\n      } else {\n        // If this isn't the tail then there MUST be a NEXT node\n        // This still works if \"m_previous\" is nullptr\n        m_next-&gt;m_previous = m_previous;\n      }\n\n      m_list-&gt;m_size--;\n    }\n\n  private:\n    void setup_self()\n    {\n      // Make this item the head if head currently doesn't exist\n      if (!m_list-&gt;m_head) {\n        m_list-&gt;m_head = this;\n      }\n      // Make this item the tail\n      if (!m_list-&gt;m_tail) {\n        m_list-&gt;m_tail = this;\n      } else {\n        m_previous = m_list-&gt;m_tail;\n        m_list-&gt;m_tail-&gt;m_next = this;\n        m_list-&gt;m_tail = this;\n      }\n\n      m_list-&gt;m_size++;\n    }\n\n    static_list* m_list = nullptr;\n    item* m_previous = nullptr;\n    item* m_next = nullptr;\n    Object m_object;\n  };\n\n  class item_iterator\n  {\n  public:\n    friend class static_list;\n\n    using iterator_category = std::bidirectional_iterator_tag;\n    using difference_type = std::ptrdiff_t;\n    using value_type = Object;\n    using pointer = value_type*;\n    using reference = value_type&amp;;\n\n    explicit item_iterator(item* p_item, const static_list* p_list = nullptr)\n      : m_self(p_item)\n      , m_list(p_list)\n    {\n    }\n\n    item_iterator operator++()\n    {\n      if (m_self) {\n        m_self = m_self-&gt;m_next;\n      }\n      return *this;\n    }\n\n    item_iterator operator++([[maybe_unused]] int p_other)\n    {\n      auto old = *this;  // copy old value\n      operator++();      // prefix increment\n      return old;        // return old value\n    }\n\n    item_iterator operator--()\n    {\n      if (m_self) {\n        m_self = m_self-&gt;m_previous;\n      } else if (m_list) {\n        m_self = m_list-&gt;m_tail;\n      }\n      return *this;\n    }\n\n    item_iterator operator--([[maybe_unused]] int p_other)\n    {\n      auto old = *this;  // copy old value\n      operator--();      // prefix increment\n      return old;        // return old value\n    }\n\n    bool operator==(const item_iterator&amp; p_other) const\n    {\n      return m_self == p_other.m_self;\n    }\n\n    bool operator!=(const item_iterator&amp; p_other) const\n    {\n      return m_self != p_other.m_self;\n    }\n\n    reference operator*()\n    {\n      return m_self-&gt;get();\n    }\n\n    reference operator*() const\n    {\n      return m_self-&gt;get();\n    }\n\n    pointer operator-&gt;()\n    {\n      return &amp;m_self-&gt;get();\n    }\n\n    pointer operator-&gt;() const\n    {\n      return &amp;m_self-&gt;get();\n    }\n\n  private:\n    item* m_self;\n    const static_list* m_list;\n  };\n\n  using value_type = Object;\n  using reference = Object&amp;;\n  using const_reference = const Object&amp;;\n  using iterator = item_iterator;\n  using const_iterator = const item_iterator;\n  using difference_type = std::ptrdiff_t;\n  using size_type = std::size_t;\n  using pointer = value_type*;\n  using const_pointer = const value_type*;\n\n  constexpr static_list()\n  {\n  }\n\n  constexpr static_list&amp; operator=(static_list&amp; p_other) = delete;\n  constexpr static_list(static_list&amp; p_other) = delete;\n  constexpr static_list&amp; operator=(static_list&amp;&amp; p_other)\n  {\n    m_head = p_other.m_head;\n    m_tail = p_other.m_tail;\n    m_size = p_other.m_size;\n\n    // Set all fields to NULL to indicate to the destructor that this list\n    // should not go through the destructor sequence.\n    p_other.m_head = nullptr;\n    p_other.m_tail = nullptr;\n    p_other.m_size = 0;\n\n    for (auto element = begin(); element != end(); element++) {\n      element.m_self-&gt;m_list = this;\n    }\n\n    return *this;\n  }\n\n  constexpr static_list(static_list&amp;&amp; p_other)\n  {\n    *this = std::move(p_other);\n  }\n\n  [[nodiscard(\"List item must be saved, otherwise, the value will be discarded \"\n              \"from the list\")]] constexpr item\n  push_back()\n  {\n    return item(this, Object{});\n  }\n\n  [[nodiscard(\"List item must be saved, otherwise, the value will be discarded \"\n              \"from the list\")]] constexpr item\n  push_back(const Object&amp; p_value)\n  {\n    return item(this, p_value);\n  }\n\n  [[nodiscard(\"List item must be saved, otherwise, the value will be discarded \"\n              \"from the list\")]] constexpr item\n  push_back(Object&amp;&amp; p_value)\n  {\n    return item(this, p_value);\n  }\n\n  constexpr bool empty()\n  {\n    return m_size == 0;\n  }\n\n  constexpr auto begin()\n  {\n    return item_iterator(m_head);\n  }\n\n  constexpr auto begin() const\n  {\n    return item_iterator(m_head);\n  }\n\n  constexpr auto cbegin() const\n  {\n    return item_iterator(m_head);\n  }\n\n  constexpr auto end()\n  {\n    return item_iterator(nullptr, this);\n  }\n\n  constexpr auto end() const\n  {\n    return item_iterator(nullptr, this);\n  }\n\n  constexpr auto cend() const\n  {\n    return item_iterator(nullptr, this);\n  }\n\n  constexpr std::size_t size() const\n  {\n    return m_size;\n  }\n\n  ~static_list()\n  {\n    if (!m_head || !m_tail) {\n      return;\n    }\n\n    for (auto element = begin(); element != end(); element++) {\n      element.m_self-&gt;m_list = nullptr;\n    }\n  }\n\nprivate:\n  item* m_head = nullptr;\n  item* m_tail = nullptr;\n  std::size_t m_size = 0;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal-util_2steady__clock_8hpp/","title":"File steady_clock.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; steady_clock.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;libhal/error.hpp&gt;</code></li> <li><code>#include &lt;libhal/steady_clock.hpp&gt;</code></li> <li><code>#include &lt;libhal/timeout.hpp&gt;</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/libhal-util_2steady__clock_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/libhal-util_2steady__clock_8hpp/#classes","title":"Classes","text":"Type Name class steady_clock_timeout Timeout object based on hal::steady_clock . <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/steady_clock.hpp</code></p>"},{"location":"api/libhal-util_2steady__clock_8hpp_source/","title":"File steady_clock.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; steady_clock.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;libhal/error.hpp&gt;\n#include &lt;libhal/steady_clock.hpp&gt;\n#include &lt;libhal/timeout.hpp&gt;\n\n#include \"units.hpp\"\n\nnamespace hal {\ninline std::uint64_t future_deadline(hal::steady_clock&amp; p_steady_clock,\n                                     hal::time_duration p_duration);\n\nclass steady_clock_timeout\n{\npublic:\n  static steady_clock_timeout create(hal::steady_clock&amp; p_steady_clock,\n                                     hal::time_duration p_duration);\n\n  steady_clock_timeout(const steady_clock_timeout&amp; p_timeout) = default;\n  steady_clock_timeout&amp; operator=(const steady_clock_timeout&amp; p_timeout) =\n    default;\n  steady_clock_timeout(steady_clock_timeout&amp;&amp; p_timeout) = default;\n  steady_clock_timeout&amp; operator=(steady_clock_timeout&amp;&amp; p_timeout) = default;\n\n  status operator()();\n\nprivate:\n  steady_clock_timeout(hal::steady_clock&amp; p_steady_clock,\n                       std::uint64_t p_cycles_until_timeout);\n\n  hal::steady_clock* m_counter;\n  std::uint64_t m_cycles_until_timeout = 0;\n};\n\nsteady_clock_timeout create_timeout(hal::steady_clock&amp; p_steady_clock,\n                                    hal::time_duration p_duration);\n\nvoid delay(hal::steady_clock&amp; p_steady_clock, hal::time_duration p_duration);\n\ninline auto timeout_generator(hal::steady_clock&amp; p_steady_clock)\n{\n  return [&amp;p_steady_clock](hal::time_duration p_duration) -&gt; auto\n  {\n    return create_timeout(p_steady_clock, p_duration);\n  };\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/streams_8hpp/","title":"File streams.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; streams.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;span&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;libhal/error.hpp&gt;</code></li> <li><code>#include &lt;libhal/timeout.hpp&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> </ul>"},{"location":"api/streams_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers."},{"location":"api/streams_8hpp/#classes","title":"Classes","text":"Type Name class stream_fill Non-blocking callable for reading serial data into a buffer. class stream_fill_upto Discard received bytes until the sequence is found. class stream_find Discard received bytes until the sequence is found. class stream_parse &lt;T&gt;Read bytes from stream and convert to integer. class stream_skip Skip number of bytes in a byte stream. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/streams.hpp</code></p>"},{"location":"api/streams_8hpp_source/","title":"File streams.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; streams.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;span&gt;\n#include &lt;type_traits&gt;\n\n#include &lt;libhal/error.hpp&gt;\n#include &lt;libhal/timeout.hpp&gt;\n#include &lt;libhal/units.hpp&gt;\n\nnamespace hal {\nclass stream_find\n{\npublic:\n  explicit stream_find(std::span&lt;const hal::byte&gt; p_sequence);\n\n  friend std::span&lt;const hal::byte&gt; operator|(\n    const std::span&lt;const hal::byte&gt;&amp; p_input_data,\n    stream_find&amp; p_self);\n\n  work_state state();\n\nprivate:\n  std::span&lt;const hal::byte&gt; m_sequence;\n  size_t m_search_index = 0;\n};\n\nclass stream_fill\n{\npublic:\n  explicit stream_fill(std::span&lt;hal::byte&gt; p_buffer);\n\n  stream_fill(std::span&lt;hal::byte&gt; p_buffer, const size_t&amp; p_fill_amount);\n\n  friend std::span&lt;const hal::byte&gt; operator|(\n    const std::span&lt;const hal::byte&gt;&amp; p_input_data,\n    stream_fill&amp; p_self);\n\n  work_state state();\n\nprivate:\n  std::span&lt;hal::byte&gt; m_buffer;\n  const size_t* m_fill_amount = nullptr;\n};\n\nclass stream_fill_upto\n{\npublic:\n  stream_fill_upto(std::span&lt;const hal::byte&gt; p_sequence,\n                   std::span&lt;hal::byte&gt; p_buffer);\n\n  friend std::span&lt;const hal::byte&gt; operator|(\n    const std::span&lt;const hal::byte&gt;&amp; p_input_data,\n    stream_fill_upto&amp; p_self);\n\n  work_state state();\n\n  std::span&lt;hal::byte&gt; span();\n  std::span&lt;hal::byte&gt; unfilled();\n\nprivate:\n  std::span&lt;const hal::byte&gt; m_sequence;\n  std::span&lt;hal::byte&gt; m_buffer;\n  size_t m_fill_amount = 0;\n  size_t m_search_index = 0;\n};\n\ntemplate&lt;std::unsigned_integral T&gt;\nclass stream_parse\n{\npublic:\n  explicit stream_parse() = default;\n\n  friend std::span&lt;const hal::byte&gt; operator|(\n    const std::span&lt;const hal::byte&gt;&amp; p_input_data,\n    stream_parse&amp; p_self)\n  {\n    if (p_self.m_finished) {\n      return p_input_data;\n    }\n\n    for (size_t index = 0; index &lt; p_input_data.size(); index++) {\n      if (std::isdigit(static_cast&lt;char&gt;(p_input_data[index]))) {\n        p_self.m_value *= 10;\n        p_self.m_value += p_input_data[index] - hal::byte('0');\n        p_self.m_found_digit = true;\n      } else if (p_self.m_found_digit) {\n        p_self.m_finished = true;\n        return p_input_data.subspan(index);\n      }\n    }\n\n    return p_input_data.last(0);\n  }\n\n  work_state state()\n  {\n    return m_finished ? work_state::finished : work_state::in_progress;\n  }\n\n  const T&amp; value()\n  {\n    return m_value;\n  }\n\nprivate:\n  T m_value = 0;\n  bool m_found_digit = false;\n  bool m_finished = false;\n};\n\nclass stream_skip\n{\npublic:\n  explicit stream_skip(size_t p_skip);\n\n  friend std::span&lt;const hal::byte&gt; operator|(\n    const std::span&lt;const hal::byte&gt;&amp; p_input_data,\n    stream_skip&amp; p_self);\n\n  work_state state();\n\nprivate:\n  size_t m_skip;\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal-util_2timeout_8hpp/","title":"File timeout.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; timeout.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;concepts&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;ios&gt;</code></li> <li><code>#include &lt;system_error&gt;</code></li> <li><code>#include &lt;libhal/error.hpp&gt;</code></li> <li><code>#include &lt;libhal/timeout.hpp&gt;</code></li> <li><code>#include \"units.hpp\"</code></li> </ul>"},{"location":"api/libhal-util_2timeout_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/timeout.hpp</code></p>"},{"location":"api/libhal-util_2timeout_8hpp_source/","title":"File timeout.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; timeout.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;concepts&gt;\n#include &lt;functional&gt;\n#include &lt;ios&gt;\n#include &lt;system_error&gt;\n\n#include &lt;libhal/error.hpp&gt;\n#include &lt;libhal/timeout.hpp&gt;\n\n#include \"units.hpp\"\n\nnamespace hal {\nconstexpr std::string_view to_string(work_state p_state)\n{\n  switch (p_state) {\n    case work_state::in_progress:\n      return \"in progress\";\n    case work_state::failed:\n      return \"failed\";\n    case work_state::finished:\n      return \"finished\";\n    default:\n      return \"unknown work state\";\n  }\n}\n\nconstexpr bool terminated(work_state p_state)\n{\n  return p_state == work_state::finished || p_state == work_state::failed;\n}\n\nconstexpr bool finished(work_state p_state)\n{\n  return p_state == work_state::finished;\n}\n\nconstexpr bool in_progress(work_state p_state)\n{\n  return p_state == work_state::in_progress;\n}\n\nconstexpr bool failed(work_state p_state)\n{\n  return p_state == work_state::failed;\n}\n\ntemplate&lt;typename T&gt;\nconcept has_work_state = requires(T a) {\n                           {\n                             a.state()\n                             } -&gt; std::same_as&lt;work_state&gt;;\n                         };\n\nconstexpr bool terminated(has_work_state auto p_worker)\n{\n  return terminated(p_worker.state());\n}\n\nconstexpr bool finished(has_work_state auto p_worker)\n{\n  return finished(p_worker.state());\n}\n\nconstexpr bool in_progress(has_work_state auto p_worker)\n{\n  return in_progress(p_worker.state());\n}\n\nconstexpr bool failed(has_work_state auto p_worker)\n{\n  return failed(p_worker.state());\n}\n\ntemplate&lt;class CharT, class Traits&gt;\ninline std::basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(\n  std::basic_ostream&lt;CharT, Traits&gt;&amp; p_ostream,\n  const work_state&amp; p_state)\n{\n  return p_ostream &lt;&lt; to_string(p_state);\n}\n\ninline result&lt;work_state&gt; try_until(worker auto&amp; p_worker,\n                                    timeout auto p_timeout)\n{\n  while (true) {\n    auto state = HAL_CHECK(p_worker());\n    if (hal::terminated(state)) {\n      return state;\n    }\n    HAL_CHECK(p_timeout());\n  }\n  return new_error(std::errc::state_not_recoverable);\n};\n\ninline result&lt;work_state&gt; try_until(worker auto&amp;&amp; p_worker,\n                                    timeout auto p_timeout)\n{\n  worker auto&amp; worker = p_worker;\n  return try_until(worker, p_timeout);\n};\n}  // namespace hal\n</code></pre>"},{"location":"api/to__array_8hpp/","title":"File to_array.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; to_array.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;algorithm&gt;</code></li> <li><code>#include &lt;array&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;string_view&gt;</code></li> </ul>"},{"location":"api/to__array_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/to_array.hpp</code></p>"},{"location":"api/to__array_8hpp_source/","title":"File to_array.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; to_array.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;algorithm&gt;\n#include &lt;array&gt;\n#include &lt;cstddef&gt;\n#include &lt;string_view&gt;\n\nnamespace hal {\ntemplate&lt;size_t N&gt;\n[[nodiscard]] constexpr std::array&lt;char, N + 1&gt; to_array(\n  std::string_view p_view)\n{\n  const size_t min = std::min(N, p_view.size());\n  std::array&lt;char, N + 1&gt; result;\n\n  auto out_iterator = std::copy_n(p_view.begin(), min, result.begin());\n  std::fill(out_iterator, result.end(), '\\0');\n\n  return result;\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/libhal-util_2units_8hpp/","title":"File units.hpp","text":"<p>FileList &gt; include &gt; libhal-util &gt; units.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cmath&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;ios&gt;</code></li> <li><code>#include &lt;libhal/error.hpp&gt;</code></li> <li><code>#include &lt;libhal/timeout.hpp&gt;</code></li> <li><code>#include &lt;libhal/units.hpp&gt;</code></li> <li><code>#include \"math.hpp\"</code></li> </ul>"},{"location":"api/libhal-util_2units_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <p>The documentation for this class was generated from the following file <code>libraries/include/libhal-util/units.hpp</code></p>"},{"location":"api/libhal-util_2units_8hpp_source/","title":"File units.hpp","text":"<p>File List &gt; include &gt; libhal-util &gt; units.hpp</p> <p>Go to the documentation of this file</p> <pre><code>// Copyright 2023 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;cmath&gt;\n#include &lt;cstdint&gt;\n#include &lt;ios&gt;\n\n#include &lt;libhal/error.hpp&gt;\n#include &lt;libhal/timeout.hpp&gt;\n#include &lt;libhal/units.hpp&gt;\n\n#include \"math.hpp\"\n\nnamespace hal {\n[[nodiscard]] constexpr std::int64_t cycles_per(hertz p_source,\n                                                hal::time_duration p_duration)\n{\n  // Full Equation:\n  //                              / ratio_num \\_\n  //   frequency_hz * |period| * | ----------- |  = cycles\n  //                              \\ ratio_den /\n  //\n  // std::chrono::nanoseconds::period::num == 1\n  // std::chrono::nanoseconds::period::den == 1,000,000\n\n  const auto denominator = decltype(p_duration)::period::den;\n  const auto float_count = static_cast&lt;float&gt;(p_duration.count());\n  const auto cycle_count = (float_count * p_source) / denominator;\n\n  return static_cast&lt;std::int64_t&gt;(cycle_count);\n}\n\ntemplate&lt;typename Period&gt;\nconstexpr std::chrono::duration&lt;int64_t, Period&gt; wavelength(hertz p_source)\n{\n  using duration = std::chrono::duration&lt;int64_t, Period&gt;;\n\n  static_assert(Period::num == 1, \"The period ratio numerator must be 1\");\n  static_assert(Period::den &gt;= 1,\n                \"The period ratio denominator must be 1 or greater than 1.\");\n\n  constexpr auto denominator = static_cast&lt;decltype(p_source)&gt;(Period::den);\n  auto period = (1.0f / p_source) * denominator;\n\n  if (std::isinf(period)) {\n    return duration(std::numeric_limits&lt;int64_t&gt;::max());\n  }\n\n  return duration(static_cast&lt;int64_t&gt;(period));\n}\n\nconstexpr float wavelength(hertz p_source)\n{\n  if (equals(p_source, 0.0f)) {\n    return 0.0f;\n  }\n  auto duration = (1.0f / p_source);\n  return float(duration);\n}\n\n[[nodiscard]] inline result&lt;std::chrono::nanoseconds&gt; duration_from_cycles(\n  hertz p_source,\n  uint32_t p_cycles)\n{\n  // Full Equation (based on the equation in cycles_per()):\n  //\n  //\n  //                /    cycles * ratio_den    \\_\n  //   |period| =  | ---------------------------|\n  //                \\ frequency_hz * ratio_num /\n  //\n  constexpr auto ratio_den = std::chrono::nanoseconds::period::den;\n  constexpr auto ratio_num = std::chrono::nanoseconds::period::num;\n  constexpr auto int_min = std::numeric_limits&lt;std::int64_t&gt;::min();\n  constexpr auto int_max = std::numeric_limits&lt;std::int64_t&gt;::max();\n  constexpr auto float_int_min = static_cast&lt;float&gt;(int_min);\n  constexpr auto float_int_max = static_cast&lt;float&gt;(int_max);\n\n  const auto source = std::abs(p_source);\n  const auto float_cycles = static_cast&lt;float&gt;(p_cycles);\n  const auto nanoseconds = (float_cycles * ratio_den) / (source * ratio_num);\n\n  if (float_int_min &lt;= nanoseconds &amp;&amp; nanoseconds &lt;= float_int_max) {\n    return std::chrono::nanoseconds(static_cast&lt;std::int64_t&gt;(nanoseconds));\n  }\n  return new_error(std::errc::result_out_of_range);\n}\n\ntemplate&lt;class CharT, class Traits&gt;\ninline std::basic_ostream&lt;CharT, Traits&gt;&amp; operator&lt;&lt;(\n  std::basic_ostream&lt;CharT, Traits&gt;&amp; p_ostream,\n  const hal::byte&amp; p_byte)\n{\n  return p_ostream &lt;&lt; std::hex &lt;&lt; \"0x\" &lt;&lt; unsigned(p_byte);\n}\n}  // namespace hal\n</code></pre>"},{"location":"api/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace hal The foundation of libhal containing, interfaces, utilities and soft drivers. <ul> <li>namespace cortex_m libhal drivers for the ARM Cortex-M series of processors </li> <li>namespace error Error objects, templates, and constants. </li> <li>namespace esp8266 libhal compatible libraries for the esp8266 device and microcontroller </li> <li>namespace literals Namespace containing user defined literals for the hal standard units. </li> <li>namespace lpc40 libhal drivers for the lpc40 series of microcontrollers from NXP </li> <li>namespace micromod <ul> <li>namespace v1 </li> </ul> </li> <li>namespace mock </li> <li>namespace mpl </li> <li>namespace rmd </li> <li>namespace soft </li> <li>namespace stm32f1 </li> </ul> </li> <li>namespace std </li> </ul>"},{"location":"api/classes/","title":"Class Index","text":""},{"location":"api/classes/#a","title":"a","text":"<ul> <li>accelerometer (hal)</li> <li>adc (hal)</li> <li>adc (hal::lpc40)</li> <li>adc (hal::mock)</li> <li>adc_multiplexer (hal::soft)</li> <li>adc_mux_pin (hal::soft)</li> <li>adc_t (hal::stm32f1::clock_tree::ahb_t::apb2_t)</li> <li>ahb_t (hal::stm32f1::clock_tree)</li> <li>altitude_read_t (hal::mpl::mpl3115a2)</li> <li>apb1_t (hal::stm32f1::clock_tree::ahb_t)</li> <li>apb2_t (hal::stm32f1::clock_tree::ahb_t)</li> <li>at (hal::esp8266)</li> </ul>"},{"location":"api/classes/#b","title":"b","text":"<ul> <li>bit_limits (hal)</li> <li>bit_mask (hal)</li> <li>bit_modify (hal)</li> <li>bit_value (hal)</li> <li>bus_info (hal::lpc40::i2c)</li> <li>bus_info (hal::lpc40::spi)</li> <li>byte_mask (hal)</li> </ul>"},{"location":"api/classes/#c","title":"c","text":"<ul> <li>can (hal)</li> <li>can (hal::lpc40)</li> <li>can (hal::mock)</li> <li>can_router (hal)</li> <li>cancel_t (hal::timer)</li> <li>channel (hal::lpc40::adc)</li> <li>channel (hal::lpc40::pwm)</li> <li>clock (hal::lpc40)</li> <li>clock_tree (hal::stm32f1)</li> <li>configuration (hal::lpc40::clock)</li> <li>cpu_t (hal::lpc40::clock::configuration)</li> </ul>"},{"location":"api/classes/#d","title":"d","text":"<ul> <li>dac (hal)</li> <li>dac (hal::mock)</li> <li>distance_sensor (hal)</li> <li>drc (hal::rmd)</li> <li>drc_motor (hal::rmd)</li> <li>drc_rotation_sensor (hal::rmd)</li> <li>drc_servo (hal::rmd)</li> <li>drc_temperature_sensor (hal::rmd)</li> <li>duty_cycle_t (hal::pwm)</li> <li>dwt_counter (hal::cortex_m)</li> </ul>"},{"location":"api/classes/#e","title":"e","text":"<ul> <li>exception_number (hal::cortex_m::interrupt)</li> </ul>"},{"location":"api/classes/#f","title":"f","text":"<ul> <li>feedback_t (hal::rmd::drc)</li> <li>feedback_t (hal::rmd::mc_x)</li> <li>flush_t (hal::serial)</li> <li>frequency_t (hal::pwm)</li> <li>frequency_t (hal::steady_clock)</li> </ul>"},{"location":"api/classes/#g","title":"g","text":"<ul> <li>gyroscope (hal)</li> </ul>"},{"location":"api/classes/#i","title":"i","text":"<ul> <li>i2c (hal)</li> <li>i2c (hal::lpc40)</li> <li>inert_accelerometer (hal::soft)</li> <li>inert_adc (hal::soft)</li> <li>inert_dac (hal::soft)</li> <li>inert_distance_sensor (hal::soft)</li> <li>inert_gyroscope (hal::soft)</li> <li>inert_input_pin (hal::soft)</li> <li>inert_interrupt_pin (hal::soft)</li> <li>inert_magnetometer (hal::soft)</li> <li>inert_motor (hal::soft)</li> <li>inert_output_pin (hal::soft)</li> <li>inert_pwm (hal::soft)</li> <li>inert_rotation_sensor (hal::soft)</li> <li>inert_steady_clock (hal::soft)</li> <li>inert_temperature_sensor (hal::soft)</li> <li>inert_timer (hal::soft)</li> <li>input_pin (hal)</li> <li>input_pin (hal::lpc40)</li> <li>input_pin (hal::mock)</li> <li>input_pin_inverter (hal::soft)</li> <li>interrupt (hal::cortex_m)</li> <li>interrupt_pin (hal)</li> <li>interrupt_pin (hal::lpc40)</li> <li>interrupt_pin (hal::mock)</li> <li>invalid_option_t (hal::error)</li> <li>is_running_t (hal::timer)</li> <li>item (hal::static_list)</li> <li>item_iterator (hal::static_list)</li> </ul>"},{"location":"api/classes/#l","title":"l","text":"<ul> <li>level_t (hal::input_pin)</li> <li>level_t (hal::output_pin)</li> </ul>"},{"location":"api/classes/#m","title":"m","text":"<ul> <li>magnetometer (hal)</li> <li>mc_x (hal::rmd)</li> <li>mc_x_motor (hal::rmd)</li> <li>mc_x_rotation (hal::rmd)</li> <li>mc_x_servo (hal::rmd)</li> <li>mc_x_temperature (hal::rmd)</li> <li>message_t (hal::can)</li> <li>minimum_speed_i2c (hal::soft)</li> <li>motor (hal)</li> <li>motor (hal::mock)</li> <li>move_interceptor (hal)</li> <li>mpl3115a2 (hal::mpl)</li> </ul>"},{"location":"api/classes/#n","title":"n","text":"<ul> <li>nibble_mask (hal)</li> </ul>"},{"location":"api/classes/#o","title":"o","text":"<ul> <li>out_of_bounds_error (hal::timer)</li> <li>output_pin (hal::lpc40)</li> <li>output_pin (hal)</li> <li>output_pin (hal::stm32f1)</li> <li>output_pin (hal::mock)</li> <li>output_pin_inverter (hal::soft)</li> <li>overflow_counter (hal)</li> </ul>"},{"location":"api/classes/#p","title":"p","text":"<ul> <li>packet_manager</li> <li>pin (hal::lpc40)</li> <li>pll_t (hal::lpc40::clock::configuration)</li> <li>pll_t (hal::stm32f1::clock_tree)</li> <li>port (hal::lpc40::can)</li> <li>port (hal::lpc40::uart)</li> <li>position_t (hal::servo)</li> <li>power (hal::lpc40)</li> <li>power_t (hal::motor)</li> <li>pressure_read_t (hal::mpl::mpl3115a2)</li> <li>pwm (hal::lpc40)</li> <li>pwm (hal)</li> <li>pwm (hal::mock)</li> </ul>"},{"location":"api/classes/#r","title":"r","text":"<ul> <li>range_error (hal::servo)</li> <li>ranges</li> <li>rc_servo (hal::soft)</li> <li>read_into (hal)</li> <li>read_t (hal::accelerometer)</li> <li>read_t (hal::adc)</li> <li>read_t (hal::distance_sensor)</li> <li>read_t (hal::esp8266::at)</li> <li>read_t (hal::gyroscope)</li> <li>read_t (hal::magnetometer)</li> <li>read_t (hal::rotation_sensor)</li> <li>read_t (hal::serial)</li> <li>read_t (hal::temperature_sensor)</li> <li>read_uint32 (hal)</li> <li>read_upto (hal)</li> <li>rotation_sensor (hal)</li> <li>route (hal::can_router)</li> <li>rtc_t (hal::stm32f1::clock_tree)</li> </ul>"},{"location":"api/classes/#s","title":"s","text":"<ul> <li>schedule_t (hal::timer)</li> <li>send_t (hal::can)</li> <li>serial (hal)</li> <li>servo (hal)</li> <li>set_level_t (hal::output_pin)</li> <li>settings (hal::can)</li> <li>settings (hal::i2c)</li> <li>settings (hal::input_pin)</li> <li>settings (hal::interrupt_pin)</li> <li>settings (hal::output_pin)</li> <li>settings (hal::serial)</li> <li>settings (hal::soft::rc_servo)</li> <li>settings (hal::spi)</li> <li>skip_past (hal)</li> <li>socket_config (hal::esp8266::at)</li> <li>spi (hal::lpc40)</li> <li>spi (hal)</li> <li>spifi_t (hal::lpc40::clock::configuration)</li> <li>spy_handler (hal)</li> <li>static_callable (hal)</li> <li>static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt; (hal)</li> <li>static_list (hal)</li> <li>steady_clock (hal)</li> <li>steady_clock (hal::mock)</li> <li>steady_clock_timeout (hal)</li> <li>stream_fill (hal)</li> <li>stream_fill_upto (hal)</li> <li>stream_find (hal)</li> <li>stream_parse (hal)</li> <li>stream_skip (hal)</li> <li>systick_timer (hal::cortex_m)</li> </ul>"},{"location":"api/classes/#t","title":"t","text":"<ul> <li>temperature_read_t (hal::mpl::mpl3115a2)</li> <li>temperature_sensor (hal)</li> <li>timer (hal)</li> <li>timer (hal::mock)</li> <li>transaction_t (hal::i2c)</li> <li>transfer_t (hal::spi)</li> </ul>"},{"location":"api/classes/#u","title":"u","text":"<ul> <li>uart (hal::lpc40)</li> <li>uptime_t (hal::steady_clock)</li> <li>usb_divider_t (hal::stm32f1::clock_tree::pll_t)</li> <li>usb_t (hal::lpc40::clock::configuration)</li> </ul>"},{"location":"api/classes/#w","title":"w","text":"<ul> <li>write_only_spi (hal::mock)</li> <li>write_t (hal::dac)</li> <li>write_t (hal::esp8266::at)</li> <li>write_t (hal::serial)</li> </ul>"},{"location":"api/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class hal::accelerometer Acceleration sensing hardware abstraction interface. <ul> <li>class hal::soft::inert_accelerometer Inert implementation of acceleration sensing hardware. </li> </ul> </li> <li>class hal::adc Analog to Digital Converter (ADC) hardware abstraction interface. <ul> <li>class hal::lpc40::adc Analog to digital converter. </li> <li>struct hal::mock::adc Mock adc implementation for use in unit tests and simulations. </li> <li>class hal::soft::adc_mux_pin A class that represents a multiplexer pin for ADC. </li> <li>class hal::soft::inert_adc Inert implementation of Analog to Digital Converter (ADC) hardware. </li> </ul> </li> <li>class hal::bit_value <ul> <li>class hal::bit_modify </li> </ul> </li> <li>class hal::can Controller Area Network (CAN bus) hardware abstraction interface. <ul> <li>class hal::lpc40::can </li> <li>struct hal::mock::can Mock can implementation for use in unit tests and simulations. </li> </ul> </li> <li>class hal::can_router Route CAN messages received on the can bus to callbacks based on ID. </li> <li>class hal::steady_clock Hardware abstraction interface for a steady clock mechanism. <ul> <li>class hal::cortex_m::dwt_counter A counter with a frequency fixed to the CPU clock rate. </li> <li>struct hal::mock::steady_clock mock steady_clock implementation for use in unit tests and simulations.</li> <li>class hal::soft::inert_steady_clock Inert implementation of steady clock mechanism. </li> </ul> </li> <li>class hal::cortex_m::interrupt Cortex M series interrupt controller. </li> <li>class hal::cortex_m::interrupt::exception_number represents an interrupt request number along with helper functions for setting up the interrupt controller registers. </li> <li>class hal::timer Timer hardware abstraction interface. <ul> <li>class hal::cortex_m::systick_timer SysTick driver for the ARM Cortex Mx series chips. </li> <li>struct hal::mock::timer Mock timer implementation for use in unit tests and simulations with spy functions for schedule() , clear(), andis_running() __</li> <li>class hal::soft::inert_timer Inert implementation of timer hardware. </li> </ul> </li> <li>class hal::dac Digital to Analog Converter (DAC) hardware abstraction interface. <ul> <li>struct hal::mock::dac Mock dac implementation for use in unit tests and simulations with a spy function for write() __</li> <li>class hal::soft::inert_dac Inert implementation of Digital to Analog Converter (DAC) hardware. </li> </ul> </li> <li>class hal::distance_sensor Linear distance hardware abstraction interface. <ul> <li>class hal::soft::inert_distance_sensor Inert implementation of linear distance hardware. </li> </ul> </li> <li>class hal::esp8266::at AT Command network driver for the esp8266 .</li> <li>class hal::gyroscope Angular velocity sensing hardware abstraction interface. <ul> <li>class hal::soft::inert_gyroscope Inert implementation of angular velocity sensing hardware. </li> </ul> </li> <li>class hal::i2c Inter-integrated Circuit (I2C) hardware abstract interface. <ul> <li>class hal::lpc40::i2c </li> <li>class hal::soft::minimum_speed_i2c A i2c wrapper to ensure that the lowesti2c device frequency is used.</li> </ul> </li> <li>class hal::input_pin Digital input pin hardware abstraction interface. <ul> <li>class hal::lpc40::input_pin Input pin implementation for the lpc40xx. </li> <li>struct hal::mock::input_pin mock input_pin implementation for use in unit tests and simulations.</li> <li>class hal::soft::inert_input_pin Inert implementation of digital input pin hardware. </li> <li>class hal::soft::input_pin_inverter </li> </ul> </li> <li>class hal::interrupt_pin Digital interrupt pin hardware abstraction. <ul> <li>class hal::lpc40::interrupt_pin Interrupt pin implementation for the lpc40xx. </li> <li>struct hal::mock::interrupt_pin mock interrupt_pin implementation for use in unit tests and simulations.</li> <li>class hal::soft::inert_interrupt_pin Inert implementation of digital interrupt pin hardware. </li> </ul> </li> <li>class hal::lpc40::clock Allows user code to manipulate and retrieve the various system clocks speeds. </li> <li>class hal::output_pin Digital output pin hardware abstraction. <ul> <li>class hal::lpc40::output_pin Output pin implementation for the lpc40xx. </li> <li>struct hal::mock::output_pin mock output pin for use in unit tests and simulations </li> <li>class hal::soft::inert_output_pin Inert implementation of digital output pin hardware. </li> <li>class hal::soft::output_pin_inverter </li> <li>class hal::stm32f1::output_pin Output pin implementation for the stm32::f10x. </li> </ul> </li> <li>class hal::lpc40::pin lpc40xx pin multiplexing and control driver used drivers and apps seeking to tune the pins. </li> <li>class hal::lpc40::power Power control for lpc40xx peripherals. </li> <li>class hal::pwm Pulse Width Modulation (PWM) channel hardware abstraction. <ul> <li>class hal::lpc40::pwm pwm driver for the lpc40xx series of micro controllers </li> <li>struct hal::mock::pwm Mock pwm implementation for use in unit tests and simulations with spy functions for frequency() andduty_cycle() .</li> <li>class hal::soft::inert_pwm Inert implementation of Pulse Width Modulation (PWM) channel hardware. </li> </ul> </li> <li>class hal::spi Serial peripheral interface (SPI) communication protocol hardware abstract interface. <ul> <li>class hal::lpc40::spi </li> <li>struct hal::mock::write_only_spi Mock spi implementation for use in unit tests and simulations with a spy functions for configure() and a record for thetransfer() out data. The record ignores the in buffer and just stores the data being sent so it can be inspected later.</li> </ul> </li> <li>class hal::serial Hardware abstract interface for the serial communication protocol. <ul> <li>class hal::lpc40::uart Implementation of the UART peripheral for the LPC40xx family of microcontrollers. </li> </ul> </li> <li>class hal::magnetometer Magnetic field strength sensing hardware abstraction interface. <ul> <li>class hal::soft::inert_magnetometer Inert implementation of magnetic field strength sensing hardware. </li> </ul> </li> <li>class hal::motor Hardware abstraction for an open loop rotational actuator. <ul> <li>struct hal::mock::motor Mock motor implementation for use in unit tests and simulations with a spy function for power() __</li> <li>class hal::rmd::drc_motor Motor interface adaptor for DRC. </li> <li>class hal::rmd::mc_x_motor Control a mc_x motor driver like ahal::motor .</li> <li>class hal::soft::inert_motor Inert implementation of open loop motorized actuator hardware. </li> </ul> </li> <li>class hal::move_interceptor Use this to perform changes on an object its move constructor is executed. </li> <li>class hal::mpl::mpl3115a2 </li> <li>class hal::overflow_counter Extend a counter's count from an arbitrary bit width to 64-bits by detecting overflows in the count. Each detected overflow is added to an overflow counter which is combined with the current count in order create a count up to 64-bits in length. </li> <li>class hal::read_into Non-blocking callable for reading serial data into a buffer. </li> <li>class hal::read_uint32 Read bytes from serial port and convert to integer. </li> <li>class hal::read_upto Discard received bytes until the sequence is found. </li> <li>class hal::rmd::drc Driver for RMD motors equip with the DRC motor drivers. </li> <li>class hal::rotation_sensor Rotation measuring hardware abstraction interface. <ul> <li>class hal::rmd::drc_rotation_sensor Rotation sensor adaptor for DRC motors. </li> <li>class hal::rmd::mc_x_rotation Reports the rotation of the DRC motor. </li> <li>class hal::soft::inert_rotation_sensor Inert implementation of rotation measuring hardware. </li> </ul> </li> <li>class hal::servo Hardware abstraction for a closed loop position controlled rotational actuator. <ul> <li>class hal::rmd::drc_servo Servo interface adaptor for DRC. </li> <li>class hal::rmd::mc_x_servo Control a mc_x motor driver like ahal::servo .</li> <li>class hal::soft::rc_servo Generic RC servo driver. </li> </ul> </li> <li>class hal::temperature_sensor Temperature sensing hardware abstraction interface. <ul> <li>class hal::rmd::drc_temperature_sensor Temperature sensor adaptor for DRC motors. </li> <li>class hal::rmd::mc_x_temperature Reports the temperature of the DRC motor. </li> <li>class hal::soft::inert_temperature_sensor Inert implementation of temperature sensing hardware. </li> </ul> </li> <li>class hal::rmd::mc_x Driver for RMD series motors equip with the MC-X motor driver. </li> <li>class hal::skip_past Discard received bytes until the sequence is found. </li> <li>class hal::soft::adc_multiplexer A driver for an ADC multiplexer that manages and reads ADC mux pins. This driver is intended to be used with multiplexers that use digital signals. An ADC multiplexer can be used to expand the number of input channels of an ADC. </li> <li>class hal::spy_handler Helper utility for making mocks for class functions that return status. </li> <li>class hal::static_callable General class which will be used to allow for signature to be used and then split by the below class. </li> <li>class hal::static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt; Specialization of static_callable with the return type and arguments split up.</li> <li>class hal::static_list static_list is a non-owning non-allocating doubly linked list container with O(1) memory utilization.</li> <li>class hal::static_list::item Item/node within the static linked list. </li> <li>class hal::static_list::item_iterator Iterator for the static list. </li> <li>class hal::steady_clock_timeout Timeout object based on hal::steady_clock .</li> <li>class hal::stream_fill Non-blocking callable for reading serial data into a buffer. </li> <li>class hal::stream_fill_upto Discard received bytes until the sequence is found. </li> <li>class hal::stream_find Discard received bytes until the sequence is found. </li> <li>class hal::stream_parse Read bytes from stream and convert to integer. </li> <li>class hal::stream_skip Skip number of bytes in a byte stream. </li> <li>class hal::esp8266::at::packet_manager </li> <li>struct hal::accelerometer::read_t Result from reading the accelerometer. </li> <li>struct hal::adc::read_t Result from reading the adc. </li> <li>struct hal::bit_limits Similar to std::numeric_limits&lt;T&gt; except that this object can give properties of integral types of arbitrary bit widths. </li> <li>struct hal::bit_mask Represents a bit mask of contiguous bits. </li> <li>struct hal::byte_mask Helper for generating byte position masks. </li> <li>struct hal::can::message_t A CAN message. </li> <li>struct hal::can::send_t Feedback from sending data over the CAN BUS. </li> <li>struct hal::can::settings Generic settings for a can peripheral. </li> <li>struct hal::can_router::route </li> <li>struct hal::dac::write_t Feedback from writing a voltage to the dac. </li> <li>struct hal::distance_sensor::read_t Result from sampling the distance sensor. </li> <li>struct hal::esp8266::at::read_t </li> <li>struct hal::esp8266::at::socket_config </li> <li>struct hal::esp8266::at::write_t </li> <li>struct hal::gyroscope::read_t Result from reading the gyroscope. </li> <li>struct hal::i2c::settings Generic settings for a standard I2C device. </li> <li>struct hal::i2c::transaction_t Feedback from performing a transaction on the i2c bus.</li> <li>struct hal::input_pin::level_t Input pin level reading structure. </li> <li>struct hal::input_pin::settings Generic settings for input pins. </li> <li>struct hal::interrupt_pin::settings Generic settings for interrupt pins. </li> <li>struct hal::lpc40::adc::channel Channel specific information. </li> <li>struct hal::lpc40::can::port </li> <li>struct hal::lpc40::clock::configuration Clock configuration object. </li> <li>struct hal::lpc40::clock::configuration::cpu_t cpu clock control config struct </li> <li>struct hal::lpc40::clock::configuration::pll_t phase locked loops config struct </li> <li>struct hal::lpc40::clock::configuration::spifi_t spifi clock control config struct </li> <li>struct hal::lpc40::clock::configuration::usb_t usb clock control config struct </li> <li>struct hal::lpc40::i2c::bus_info </li> <li>struct hal::lpc40::pwm::channel Channel specific information. </li> <li>struct hal::lpc40::spi::bus_info Information used to configure the spi bus. </li> <li>struct hal::lpc40::uart::port </li> <li>struct hal::magnetometer::read_t Result from reading the accelerometer. </li> <li>struct hal::motor::power_t Feedback from setting the motor power. </li> <li>struct hal::mpl::mpl3115a2::altitude_read_t </li> <li>struct hal::mpl::mpl3115a2::pressure_read_t </li> <li>struct hal::mpl::mpl3115a2::temperature_read_t </li> <li>struct hal::nibble_mask Helper for generating nibble position masks. </li> <li>struct hal::output_pin::level_t Pin level reading structure. </li> <li>struct hal::output_pin::set_level_t Feedback from setting the pin state. </li> <li>struct hal::output_pin::settings Generic settings for output pins. </li> <li>struct hal::pwm::duty_cycle_t Feedback setting the pwm duty cycle. </li> <li>struct hal::pwm::frequency_t Feedback setting the pwm frequency. </li> <li>struct hal::rmd::drc::feedback_t </li> <li>struct hal::rmd::mc_x::feedback_t </li> <li>struct hal::rotation_sensor::read_t Result from reading the rotation sensor. </li> <li>struct hal::serial::flush_t Feedback from performing a flush operation. </li> <li>struct hal::serial::read_t Return type for serial read operations. </li> <li>struct hal::serial::settings Generic settings for a standard serial device. </li> <li>struct hal::serial::write_t Return type for serial write operations. </li> <li>struct hal::servo::position_t Feedback from setting the servo position. </li> <li>struct hal::servo::range_error Error information indicating the range of the servo. </li> <li>struct hal::soft::rc_servo::settings Information about the RC servo needed to control it properly. </li> <li>struct hal::spi::settings Generic settings for a standard SPI device. </li> <li>struct hal::spi::transfer_t Feedback from performing a transfer on the spi bus. </li> <li>struct hal::steady_clock::frequency_t Result from requesting the operating frequency of the steady clock. </li> <li>struct hal::steady_clock::uptime_t Result from calling uptime. </li> <li>struct hal::stm32f1::clock_tree </li> <li>struct hal::stm32f1::clock_tree::ahb_t Defines the configuration of the dividers beyond system clock mux. </li> <li>struct hal::stm32f1::clock_tree::ahb_t::apb1_t Maximum rate of 36 MHz. </li> <li>struct hal::stm32f1::clock_tree::ahb_t::apb2_t </li> <li>struct hal::stm32f1::clock_tree::ahb_t::apb2_t::adc_t </li> <li>struct hal::stm32f1::clock_tree::pll_t Defines the configuration of the PLL. </li> <li>struct hal::stm32f1::clock_tree::pll_t::usb_divider_t </li> <li>struct hal::stm32f1::clock_tree::rtc_t Defines the configuration for the RTC. </li> <li>struct hal::temperature_sensor::read_t Result from reading the temperature sensor. </li> <li>struct hal::timer::cancel_t Feedback from cancelling a timer. </li> <li>struct hal::timer::is_running_t Feedback after checking if the timer is running. </li> <li>struct hal::timer::out_of_bounds_error Error type indicating that the desired time delay is not achievable with this timer. </li> <li>struct hal::timer::schedule_t Feedback from scheduling a timer. </li> <li>struct hal::soft::rc_servo::ranges </li> <li>class std::false_type <ul> <li>struct hal::error::invalid_option_t Used for defining static_asserts that should always fail, but only if the static_assert line is hit via <code>if constexpr</code> control block. Prefer to NOT use this directly but to use<code>invalid_option</code> instead.</li> </ul> </li> </ul>"},{"location":"api/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"api/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"api/class_members/","title":"Class Members","text":""},{"location":"api/class_members/#a","title":"a","text":"<ul> <li>add_message_callback (hal::can_router)</li> <li>at (hal::esp8266::at)</li> <li>adc (hal::lpc40::adc, hal::stm32f1::clock_tree::ahb_t::apb2_t)</li> <li>adc_pin (hal::lpc40::adc::channel)</li> <li>analog (hal::lpc40::pin)</li> <li>altitude (hal::mpl::mpl3115a2::altitude_read_t)</li> <li>actuate (hal::rmd::drc, hal::rmd::mc_x)</li> <li>angle (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t, hal::rotation_sensor::read_t, hal::soft::rc_servo::ranges)</li> <li>available (hal::serial::read_t)</li> <li>adc_multiplexer (hal::soft::adc_multiplexer)</li> <li>adc_mux_pin (hal::soft::adc_mux_pin)</li> <li>ahb (hal::stm32f1::clock_tree)</li> <li>apb1 (hal::stm32f1::clock_tree::ahb_t)</li> <li>apb2 (hal::stm32f1::clock_tree::ahb_t)</li> </ul>"},{"location":"api/class_members/#b","title":"b","text":"<ul> <li>bit_modify (hal::bit_modify)</li> <li>bit_value (hal::bit_value)</li> <li>bus_on (hal::can)</li> <li>baud_rate (hal::can::settings, hal::serial::settings)</li> <li>bus (hal::can_router)</li> <li>begin (hal::static_list)</li> </ul>"},{"location":"api/class_members/#c","title":"c","text":"<ul> <li>clear (hal::bit_value)</li> <li>configure (hal::can, hal::i2c, hal::input_pin, hal::interrupt_pin, hal::output_pin, hal::serial, hal::spi)</li> <li>can_router (hal::can_router)</li> <li>create (hal::can_router, hal::esp8266::at, hal::mpl::mpl3115a2, hal::rmd::drc, hal::rmd::mc_x, hal::soft::adc_multiplexer, hal::soft::inert_accelerometer, hal::soft::inert_adc, hal::soft::inert_dac, hal::soft::inert_distance_sensor, hal::soft::inert_gyroscope, hal::soft::inert_input_pin, hal::soft::inert_interrupt_pin, hal::soft::inert_magnetometer, hal::soft::inert_motor, hal::soft::inert_output_pin, hal::soft::inert_pwm, hal::soft::inert_rotation_sensor, hal::soft::inert_steady_clock, hal::soft::inert_temperature_sensor, hal::soft::inert_timer, hal::soft::minimum_speed_i2c, hal::soft::rc_servo, hal::steady_clock_timeout)</li> <li>core_interrupts (hal::cortex_m::interrupt)</li> <li>clock_source (hal::cortex_m::systick_timer)</li> <li>connect_to_ap (hal::esp8266::at)</li> <li>connect_to_server (hal::esp8266::at)</li> <li>clock_rate (hal::i2c::settings, hal::lpc40::adc::channel, hal::spi::settings)</li> <li>construct_custom_channel (hal::lpc40::adc)</li> <li>can (hal::lpc40::can)</li> <li>clock (hal::lpc40::clock, hal::lpc40::clock::configuration::spifi_t, hal::lpc40::clock::configuration::usb_t, hal::lpc40::spi::bus_info)</li> <li>config (hal::lpc40::clock)</li> <li>cpu (hal::lpc40::clock::configuration)</li> <li>clock_function (hal::lpc40::spi::bus_info)</li> <li>construct_custom (hal::lpc40::uart)</li> <li>current (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>capacity (hal::serial::read_t)</li> <li>clock_idles_high (hal::spi::settings)</li> <li>call_history (hal::spy_handler)</li> <li>callback (hal::static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt;)</li> <li>cbegin (hal::static_list)</li> <li>cend (hal::static_list)</li> <li>const_iterator (hal::static_list)</li> <li>const_pointer (hal::static_list)</li> <li>const_reference (hal::static_list)</li> <li>cancel (hal::timer)</li> </ul>"},{"location":"api/class_members/#d","title":"d","text":"<ul> <li>driver_read (hal::accelerometer, hal::adc, hal::distance_sensor, hal::gyroscope, hal::lpc40::adc, hal::lpc40::uart, hal::magnetometer, hal::mock::adc, hal::rmd::drc_rotation_sensor, hal::rmd::drc_temperature_sensor, hal::rmd::mc_x_rotation, hal::rmd::mc_x_temperature, hal::rotation_sensor, hal::serial, hal::soft::adc_mux_pin, hal::soft::inert_accelerometer, hal::soft::inert_adc, hal::soft::inert_distance_sensor, hal::soft::inert_gyroscope, hal::soft::inert_magnetometer, hal::soft::inert_rotation_sensor, hal::soft::inert_temperature_sensor, hal::temperature_sensor)</li> <li>driver_bus_on (hal::can, hal::lpc40::can, hal::mock::can)</li> <li>driver_configure (hal::can, hal::i2c, hal::input_pin, hal::interrupt_pin, hal::lpc40::can, hal::lpc40::i2c, hal::lpc40::input_pin, hal::lpc40::interrupt_pin, hal::lpc40::output_pin, hal::lpc40::spi, hal::lpc40::uart, hal::mock::can, hal::mock::input_pin, hal::mock::interrupt_pin, hal::mock::output_pin, hal::mock::write_only_spi, hal::output_pin, hal::serial, hal::soft::inert_input_pin, hal::soft::inert_interrupt_pin, hal::soft::inert_output_pin, hal::soft::input_pin_inverter, hal::soft::minimum_speed_i2c, hal::soft::output_pin_inverter, hal::spi, hal::stm32f1::output_pin)</li> <li>driver_on_receive (hal::can, hal::lpc40::can, hal::mock::can)</li> <li>driver_send (hal::can, hal::lpc40::can, hal::mock::can)</li> <li>driver_frequency (hal::cortex_m::dwt_counter, hal::lpc40::pwm, hal::mock::pwm, hal::mock::steady_clock, hal::pwm, hal::soft::inert_pwm, hal::soft::inert_steady_clock, hal::steady_clock)</li> <li>driver_uptime (hal::cortex_m::dwt_counter, hal::mock::steady_clock, hal::soft::inert_steady_clock, hal::steady_clock)</li> <li>dwt_counter (hal::cortex_m::dwt_counter)</li> <li>disable (hal::cortex_m::interrupt)</li> <li>disable_interrupts (hal::cortex_m::interrupt)</li> <li>default_enabled (hal::cortex_m::interrupt::exception_number)</li> <li>driver_cancel (hal::cortex_m::systick_timer, hal::mock::timer, hal::soft::inert_timer, hal::timer)</li> <li>driver_is_running (hal::cortex_m::systick_timer, hal::mock::timer, hal::soft::inert_timer, hal::timer)</li> <li>driver_schedule (hal::cortex_m::systick_timer, hal::mock::timer, hal::soft::inert_timer, hal::timer)</li> <li>driver_write (hal::dac, hal::lpc40::uart, hal::mock::dac, hal::serial, hal::soft::inert_dac)</li> <li>distance (hal::distance_sensor::read_t)</li> <li>deadline (hal::esp8266::at)</li> <li>disconnect_from_ap (hal::esp8266::at)</li> <li>disconnect_from_server (hal::esp8266::at)</li> <li>data (hal::esp8266::at::read_t, hal::esp8266::at::write_t, hal::serial::read_t, hal::serial::write_t)</li> <li>domain (hal::esp8266::at::socket_config)</li> <li>driver_transaction (hal::i2c, hal::lpc40::i2c, hal::soft::minimum_speed_i2c)</li> <li>driver_level (hal::input_pin, hal::lpc40::input_pin, hal::lpc40::output_pin, hal::mock::input_pin, hal::mock::output_pin, hal::output_pin, hal::soft::inert_input_pin, hal::soft::inert_output_pin, hal::soft::input_pin_inverter, hal::soft::output_pin_inverter, hal::stm32f1::output_pin)</li> <li>driver_on_trigger (hal::interrupt_pin, hal::lpc40::interrupt_pin, hal::mock::interrupt_pin, hal::soft::inert_interrupt_pin)</li> <li>default_peripheral_divider (hal::lpc40::clock)</li> <li>divider (hal::lpc40::clock::configuration::cpu_t, hal::lpc40::clock::configuration::spifi_t, hal::lpc40::clock::configuration::usb_t, hal::stm32f1::clock_tree::ahb_t, hal::stm32f1::clock_tree::ahb_t::apb1_t, hal::stm32f1::clock_tree::ahb_t::apb2_t, hal::stm32f1::clock_tree::ahb_t::apb2_t::adc_t, hal::stm32f1::clock_tree::pll_t::usb_divider_t)</li> <li>duty_cycle (hal::lpc40::i2c::bus_info, hal::pwm)</li> <li>dac (hal::lpc40::pin)</li> <li>digital_filter (hal::lpc40::pin)</li> <li>driver_duty_cycle (hal::lpc40::pwm, hal::mock::pwm, hal::pwm, hal::soft::inert_pwm)</li> <li>driver_transfer (hal::lpc40::spi, hal::mock::write_only_spi, hal::spi)</li> <li>data_in (hal::lpc40::spi::bus_info)</li> <li>data_in_function (hal::lpc40::spi::bus_info)</li> <li>data_out (hal::lpc40::spi::bus_info)</li> <li>data_out_function (hal::lpc40::spi::bus_info)</li> <li>driver_flush (hal::lpc40::uart, hal::serial)</li> <li>driver_power (hal::mock::motor, hal::motor, hal::rmd::drc_motor, hal::rmd::mc_x_motor, hal::soft::inert_motor)</li> <li>default_max_polling_retries (hal::mpl::mpl3115a2)</li> <li>drc (hal::rmd::drc)</li> <li>drc_motor (hal::rmd::drc_motor)</li> <li>drc_rotation_sensor (hal::rmd::drc_rotation_sensor)</li> <li>drc_servo (hal::rmd::drc_servo)</li> <li>driver_position (hal::rmd::drc_servo, hal::rmd::mc_x_servo, hal::servo, hal::soft::rc_servo)</li> <li>drc_temperature_sensor (hal::rmd::drc_temperature_sensor)</li> <li>default_max_speed (hal::soft::minimum_speed_i2c)</li> <li>default_filler (hal::spi)</li> <li>data_valid_on_trailing_edge (hal::spi::settings)</li> <li>difference_type (hal::static_list, hal::static_list::item_iterator)</li> </ul>"},{"location":"api/class_members/#e","title":"e","text":"<ul> <li>enable (hal::cortex_m::interrupt, hal::stm32f1::clock_tree::pll_t, hal::stm32f1::clock_tree::rtc_t)</li> <li>enable_interrupts (hal::cortex_m::interrupt)</li> <li>enable_mask (hal::cortex_m::interrupt::exception_number)</li> <li>enable_mask_code (hal::cortex_m::interrupt::exception_number)</li> <li>exception_number (hal::cortex_m::interrupt::exception_number)</li> <li>emc_half_cpu_divider (hal::lpc40::clock::configuration)</li> <li>enabled (hal::lpc40::clock::configuration::pll_t)</li> <li>encoder (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>encoder_calibration_error (hal::rmd::mc_x::feedback_t)</li> <li>empty (hal::static_list)</li> <li>end (hal::static_list)</li> </ul>"},{"location":"api/class_members/#f","title":"f","text":"<ul> <li>from (hal::bit_mask)</li> <li>flash_configuration (hal::lpc40::clock)</li> <li>function (hal::lpc40::pin)</li> <li>frequency (hal::pwm, hal::soft::rc_servo::settings, hal::steady_clock)</li> <li>feedback (hal::rmd::drc, hal::rmd::mc_x)</li> <li>feedback_request (hal::rmd::drc, hal::rmd::mc_x)</li> <li>flush (hal::serial)</li> <li>find (hal::esp8266::at::packet_manager)</li> </ul>"},{"location":"api/class_members/#g","title":"g","text":"<ul> <li>get (hal::bit_value, hal::lpc40::adc, hal::lpc40::can, hal::lpc40::clock, hal::lpc40::i2c, hal::lpc40::input_pin, hal::lpc40::interrupt_pin, hal::lpc40::output_pin, hal::lpc40::pwm, hal::lpc40::spi, hal::lpc40::uart, hal::read_uint32, hal::static_list::item, hal::stm32f1::output_pin)</li> <li>get_vector_table (hal::cortex_m::interrupt)</li> <li>get_event_number (hal::cortex_m::interrupt::exception_number)</li> <li>get_frequency (hal::lpc40::clock)</li> <li>get_max_channel (hal::soft::adc_multiplexer)</li> <li>get_handler (hal::static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt;)</li> </ul>"},{"location":"api/class_members/#h","title":"h","text":"<ul> <li>handler (hal::can, hal::can_router::route, hal::interrupt_pin, hal::static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt;)</li> <li>handlers (hal::can_router)</li> <li>high_slew_rate (hal::lpc40::pin)</li> <li>highspeed_i2c (hal::lpc40::pin)</li> <li>hysteresis (hal::lpc40::pin)</li> <li>history (hal::spy_handler)</li> <li>high_speed_external (hal::stm32f1::clock_tree)</li> </ul>"},{"location":"api/class_members/#i","title":"i","text":"<ul> <li>insert (hal::bit_value)</li> <li>id (hal::can::message_t, hal::can_router::route, hal::lpc40::can::port, hal::lpc40::uart::port)</li> <li>is_remote_request (hal::can::message_t)</li> <li>id_t (hal::can)</li> <li>index_position (hal::cortex_m::interrupt::exception_number)</li> <li>is_valid (hal::cortex_m::interrupt::exception_number)</li> <li>initialize (hal::cortex_m::interrupt, hal::esp8266::at)</li> <li>interrupt (hal::cortex_m::interrupt, hal::lpc40::i2c)</li> <li>is_connected_to_ap (hal::esp8266::at)</li> <li>is_connected_to_server (hal::esp8266::at)</li> <li>index (hal::lpc40::adc::channel, hal::lpc40::pwm::channel)</li> <li>irq_number (hal::lpc40::can::port, hal::lpc40::i2c::bus_info, hal::lpc40::uart::port)</li> <li>irc_frequency (hal::lpc40::clock)</li> <li>i2c (hal::lpc40::i2c)</li> <li>input_pin (hal::lpc40::input_pin)</li> <li>interrupt_pin (hal::lpc40::interrupt_pin)</li> <li>i2c_high_current (hal::lpc40::pin)</li> <li>input_invert (hal::lpc40::pin)</li> <li>is_on (hal::lpc40::power)</li> <li>interrupt_handler (hal::lpc40::uart)</li> <li>intercept (hal::move_interceptor)</li> <li>inert_accelerometer (hal::soft::inert_accelerometer)</li> <li>inert_adc (hal::soft::inert_adc)</li> <li>inert_dac (hal::soft::inert_dac)</li> <li>inert_distance_sensor (hal::soft::inert_distance_sensor)</li> <li>inert_gyroscope (hal::soft::inert_gyroscope)</li> <li>inert_input_pin (hal::soft::inert_input_pin)</li> <li>inert_interrupt_pin (hal::soft::inert_interrupt_pin)</li> <li>inert_magnetometer (hal::soft::inert_magnetometer)</li> <li>inert_motor (hal::soft::inert_motor)</li> <li>inert_output_pin (hal::soft::inert_output_pin)</li> <li>inert_pwm (hal::soft::inert_pwm)</li> <li>inert_rotation_sensor (hal::soft::inert_rotation_sensor)</li> <li>inert_steady_clock (hal::soft::inert_steady_clock)</li> <li>inert_temperature_sensor (hal::soft::inert_temperature_sensor)</li> <li>inert_timer (hal::soft::inert_timer)</li> <li>input_pin_inverter (hal::soft::input_pin_inverter)</li> <li>item (hal::static_list::item)</li> <li>item_iterator (hal::static_list::item_iterator)</li> <li>iterator_category (hal::static_list::item_iterator)</li> <li>iterator (hal::static_list)</li> <li>is_running (hal::timer::is_running_t, hal::timer)</li> <li>is_complete_header (hal::esp8266::at::packet_manager)</li> </ul>"},{"location":"api/class_members/#l","title":"l","text":"<ul> <li>length (hal::can::message_t)</li> <li>level (hal::input_pin, hal::output_pin)</li> <li>low_pressure (hal::rmd::mc_x::feedback_t)</li> <li>list (hal::static_list::item)</li> <li>low_speed_external (hal::stm32f1::clock_tree)</li> </ul>"},{"location":"api/class_members/#m","title":"m","text":"<ul> <li>max (hal::bit_limits, hal::servo::range_error)</li> <li>min (hal::bit_limits, hal::servo::range_error)</li> <li>m_pointer (hal::bit_modify)</li> <li>m_value (hal::bit_value, hal::stream_parse)</li> <li>m_can (hal::can_router)</li> <li>m_handlers (hal::can_router)</li> <li>message_handler (hal::can_router)</li> <li>m_cpu_frequency (hal::cortex_m::dwt_counter)</li> <li>m_uptime (hal::cortex_m::dwt_counter, hal::soft::inert_steady_clock)</li> <li>m_id (hal::cortex_m::interrupt::exception_number, hal::cortex_m::interrupt)</li> <li>m_frequency (hal::cortex_m::systick_timer, hal::mock::steady_clock, hal::soft::inert_steady_clock)</li> <li>m_packet_manager (hal::esp8266::at)</li> <li>m_serial (hal::esp8266::at, hal::read_into, hal::read_uint32, hal::read_upto, hal::skip_past)</li> <li>m_sample (hal::lpc40::adc)</li> <li>m_moved (hal::lpc40::can, hal::lpc40::i2c, hal::lpc40::interrupt_pin, hal::lpc40::spi)</li> <li>m_port (hal::lpc40::can, hal::lpc40::input_pin, hal::lpc40::interrupt_pin, hal::lpc40::output_pin, hal::lpc40::pin, hal::lpc40::uart, hal::stm32f1::output_pin)</li> <li>m_receive_handler (hal::lpc40::can)</li> <li>multiply (hal::lpc40::clock::configuration::pll_t, hal::stm32f1::clock_tree::pll_t)</li> <li>m_config (hal::lpc40::clock)</li> <li>m_cpu_clock_rate (hal::lpc40::clock)</li> <li>m_emc_clock_rate (hal::lpc40::clock)</li> <li>m_peripheral_clock_rate (hal::lpc40::clock)</li> <li>m_spifi_clock_source_rate (hal::lpc40::clock)</li> <li>m_usb_clock_rate (hal::lpc40::clock)</li> <li>maximum (hal::lpc40::clock, hal::timer::out_of_bounds_error)</li> <li>m_address (hal::lpc40::i2c)</li> <li>m_bus (hal::lpc40::i2c)</li> <li>m_busy (hal::lpc40::i2c)</li> <li>m_read_end (hal::lpc40::i2c)</li> <li>m_read_iterator (hal::lpc40::i2c)</li> <li>m_status (hal::lpc40::i2c)</li> <li>m_write_end (hal::lpc40::i2c)</li> <li>m_write_iterator (hal::lpc40::i2c)</li> <li>m_pin (hal::lpc40::input_pin, hal::lpc40::interrupt_pin, hal::lpc40::output_pin, hal::lpc40::pin, hal::stm32f1::output_pin)</li> <li>m_peripheral (hal::lpc40::power)</li> <li>m_channel (hal::lpc40::pwm)</li> <li>m_info (hal::lpc40::spi)</li> <li>m_receive_buffer (hal::lpc40::uart)</li> <li>m_adc_values (hal::mock::adc)</li> <li>m_levels (hal::mock::input_pin)</li> <li>m_current_level (hal::mock::output_pin)</li> <li>m_last_uptime (hal::mock::steady_clock)</li> <li>m_uptime_values (hal::mock::steady_clock)</li> <li>m_is_running (hal::mock::timer, hal::soft::inert_timer)</li> <li>move_interceptor (hal::move_interceptor)</li> <li>m_i2c (hal::mpl::mpl3115a2, hal::soft::minimum_speed_i2c)</li> <li>m_sensor_mode (hal::mpl::mpl3115a2)</li> <li>mode (hal::mpl::mpl3115a2)</li> <li>mpl3115a2 (hal::mpl::mpl3115a2)</li> <li>m_overflow_count (hal::overflow_counter)</li> <li>m_previous_count (hal::overflow_counter)</li> <li>m_buffer (hal::read_into, hal::read_upto, hal::stream_fill, hal::stream_fill_upto)</li> <li>m_read_limit (hal::read_into, hal::read_uint32, hal::read_upto, hal::skip_past)</li> <li>m_finished (hal::read_uint32, hal::stream_parse)</li> <li>m_found_digit (hal::read_uint32, hal::stream_parse)</li> <li>m_integer_value (hal::read_uint32)</li> <li>m_search_index (hal::read_upto, hal::skip_past, hal::stream_fill_upto, hal::stream_find)</li> <li>m_sequence (hal::read_upto, hal::skip_past, hal::stream_fill_upto, hal::stream_find)</li> <li>message_number (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>m_clock (hal::rmd::drc, hal::rmd::mc_x, hal::soft::adc_multiplexer)</li> <li>m_device_id (hal::rmd::drc, hal::rmd::mc_x)</li> <li>m_feedback (hal::rmd::drc, hal::rmd::mc_x)</li> <li>m_gear_ratio (hal::rmd::drc, hal::rmd::mc_x)</li> <li>m_max_response_time (hal::rmd::drc, hal::rmd::mc_x)</li> <li>m_route_item (hal::rmd::drc, hal::rmd::mc_x)</li> <li>m_router (hal::rmd::drc, hal::rmd::mc_x)</li> <li>m_drc (hal::rmd::drc_motor, hal::rmd::drc_rotation_sensor, hal::rmd::drc_servo, hal::rmd::drc_temperature_sensor)</li> <li>m_max_speed (hal::rmd::drc_motor, hal::rmd::drc_servo, hal::rmd::mc_x_motor, hal::rmd::mc_x_servo)</li> <li>motor_stall (hal::rmd::mc_x::feedback_t)</li> <li>mc_x (hal::rmd::mc_x)</li> <li>m_mc_x (hal::rmd::mc_x_motor, hal::rmd::mc_x_rotation, hal::rmd::mc_x_servo, hal::rmd::mc_x_temperature)</li> <li>mc_x_motor (hal::rmd::mc_x_motor)</li> <li>mc_x_rotation (hal::rmd::mc_x_rotation)</li> <li>mc_x_servo (hal::rmd::mc_x_servo)</li> <li>mc_x_temperature (hal::rmd::mc_x_temperature)</li> <li>m_signal_pins (hal::soft::adc_multiplexer)</li> <li>m_source_pin (hal::soft::adc_multiplexer)</li> <li>m_mux (hal::soft::adc_mux_pin)</li> <li>m_mux_port (hal::soft::adc_mux_pin)</li> <li>m_values (hal::soft::inert_accelerometer)</li> <li>m_result (hal::soft::inert_adc, hal::soft::inert_distance_sensor, hal::soft::inert_gyroscope, hal::soft::inert_magnetometer)</li> <li>m_level (hal::soft::inert_input_pin, hal::soft::inert_output_pin)</li> <li>m_position (hal::soft::inert_rotation_sensor)</li> <li>m_temperature (hal::soft::inert_temperature_sensor)</li> <li>m_input_pin (hal::soft::input_pin_inverter)</li> <li>m_lowest_seen_frequency (hal::soft::minimum_speed_i2c)</li> <li>minimum_speed_i2c (hal::soft::minimum_speed_i2c)</li> <li>m_output_pin (hal::soft::output_pin_inverter)</li> <li>max_angle (hal::soft::rc_servo::settings)</li> <li>max_microseconds (hal::soft::rc_servo::settings)</li> <li>min_angle (hal::soft::rc_servo::settings)</li> <li>min_microseconds (hal::soft::rc_servo::settings)</li> <li>m_pwm (hal::soft::rc_servo)</li> <li>m_ranges (hal::soft::rc_servo)</li> <li>m_call_history (hal::spy_handler)</li> <li>m_error_trigger (hal::spy_handler)</li> <li>m_list (hal::static_list::item, hal::static_list::item_iterator)</li> <li>m_next (hal::static_list::item)</li> <li>m_object (hal::static_list::item)</li> <li>m_previous (hal::static_list::item)</li> <li>m_self (hal::static_list::item_iterator)</li> <li>m_head (hal::static_list)</li> <li>m_size (hal::static_list)</li> <li>m_tail (hal::static_list)</li> <li>m_counter (hal::steady_clock_timeout)</li> <li>m_cycles_until_timeout (hal::steady_clock_timeout)</li> <li>m_fill_amount (hal::stream_fill, hal::stream_fill_upto)</li> <li>m_skip (hal::stream_skip)</li> <li>m_length (hal::esp8266::at::packet_manager)</li> <li>m_state (hal::esp8266::at::packet_manager)</li> </ul>"},{"location":"api/class_members/#n","title":"n","text":"<ul> <li>noop (hal::can_router)</li> <li>nop (hal::cortex_m::interrupt)</li> </ul>"},{"location":"api/class_members/#o","title":"o","text":"<ul> <li>operator== (hal::bit_mask, hal::static_list::item_iterator)</li> <li>origin (hal::bit_mask)</li> <li>on_receive (hal::can)</li> <li>operator() (hal::can_router, hal::read_into, hal::read_uint32, hal::read_upto, hal::rmd::drc, hal::rmd::mc_x, hal::skip_past, hal::steady_clock_timeout)</li> <li>operator= (hal::can_router, hal::cortex_m::interrupt::exception_number, hal::lpc40::can, hal::lpc40::i2c, hal::lpc40::interrupt_pin, hal::lpc40::spi, hal::lpc40::uart, hal::move_interceptor, hal::rmd::drc, hal::rmd::mc_x, hal::static_list::item, hal::static_list, hal::steady_clock_timeout)</li> <li>on_trigger (hal::interrupt_pin)</li> <li>oscillator_frequency (hal::lpc40::clock::configuration)</li> <li>output_pin (hal::lpc40::output_pin, hal::stm32f1::output_pin)</li> <li>open_drain (hal::lpc40::pin, hal::output_pin::settings)</li> <li>off (hal::lpc40::power)</li> <li>on (hal::lpc40::power)</li> <li>over_temperature_protection_tripped (hal::rmd::drc::feedback_t)</li> <li>over_voltage_protection_tripped (hal::rmd::drc::feedback_t)</li> <li>over_current (hal::rmd::mc_x::feedback_t)</li> <li>over_temperature (hal::rmd::mc_x::feedback_t)</li> <li>over_voltage (hal::rmd::mc_x::feedback_t)</li> <li>output_pin_inverter (hal::soft::output_pin_inverter)</li> <li>operator* (hal::static_list::item, hal::static_list::item_iterator)</li> <li>operator!= (hal::static_list::item_iterator)</li> <li>operator++ (hal::static_list::item_iterator)</li> <li>operator-- (hal::static_list::item_iterator)</li> <li>operator-&gt; (hal::static_list::item_iterator)</li> <li>operating_frequency (hal::steady_clock::frequency_t)</li> </ul>"},{"location":"api/class_members/#p","title":"p","text":"<ul> <li>position (hal::bit_mask, hal::servo)</li> <li>payload (hal::can::message_t)</li> <li>phase_segment1 (hal::can::settings)</li> <li>phase_segment2 (hal::can::settings)</li> <li>propagation_delay (hal::can::settings)</li> <li>port (hal::esp8266::at::socket_config)</li> <li>pin_function (hal::lpc40::adc::channel, hal::lpc40::pwm::channel)</li> <li>peripheral_divider (hal::lpc40::clock::configuration)</li> <li>pll (hal::lpc40::clock::configuration, hal::stm32f1::clock_tree)</li> <li>peripheral_id (hal::lpc40::i2c::bus_info, hal::lpc40::pwm::channel, hal::lpc40::spi::bus_info)</li> <li>pin (hal::lpc40::pin)</li> <li>power (hal::lpc40::power, hal::motor)</li> <li>pwm_pin (hal::lpc40::pwm::channel)</li> <li>pwm (hal::lpc40::pwm)</li> <li>pressure (hal::mpl::mpl3115a2::pressure_read_t)</li> <li>position_control (hal::rmd::drc, hal::rmd::mc_x)</li> <li>power_overrun (hal::rmd::mc_x::feedback_t)</li> <li>parity (hal::serial::settings)</li> <li>pointer (hal::static_list::item_iterator, hal::static_list)</li> <li>push_back (hal::static_list)</li> <li>packet_length (hal::esp8266::at::packet_manager)</li> <li>packet_manager (hal::esp8266::at::packet_manager)</li> <li>percent (hal::soft::rc_servo::ranges)</li> </ul>"},{"location":"api/class_members/#r","title":"r","text":"<ul> <li>read (hal::accelerometer, hal::adc, hal::distance_sensor, hal::gyroscope, hal::magnetometer, hal::rmd::drc, hal::rmd::mc_x, hal::rotation_sensor, hal::serial, hal::temperature_sensor)</li> <li>route_item (hal::can_router)</li> <li>register_cpu_frequency (hal::cortex_m::dwt_counter, hal::cortex_m::systick_timer)</li> <li>register_index (hal::cortex_m::interrupt::exception_number)</li> <li>reinitialize (hal::cortex_m::interrupt)</li> <li>reset (hal::cortex_m::interrupt, hal::esp8266::at, hal::mock::can, hal::mock::dac, hal::mock::input_pin, hal::mock::interrupt_pin, hal::mock::motor, hal::mock::output_pin, hal::mock::pwm, hal::mock::timer, hal::mock::write_only_spi, hal::overflow_counter, hal::spy_handler, hal::esp8266::at::packet_manager)</li> <li>resistor (hal::input_pin::settings, hal::interrupt_pin::settings, hal::lpc40::pin, hal::output_pin::settings)</li> <li>rd (hal::lpc40::can::port)</li> <li>rd_function_code (hal::lpc40::can::port)</li> <li>reconfigure_clocks (hal::lpc40::clock)</li> <li>read_iterator (hal::lpc40::i2c)</li> <li>rx (hal::lpc40::uart::port)</li> <li>rx_function (hal::lpc40::uart::port)</li> <li>read_altitude (hal::mpl::mpl3115a2)</li> <li>read_pressure (hal::mpl::mpl3115a2)</li> <li>read_temperature (hal::mpl::mpl3115a2)</li> <li>read_into (hal::read_into)</li> <li>read_uint32 (hal::read_uint32)</li> <li>read_upto (hal::read_upto)</li> <li>raw_current (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>raw_error_state (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>raw_motor_temperature (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>raw_multi_turn_angle (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>raw_speed (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>raw_volts (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>read_channel (hal::soft::adc_multiplexer)</li> <li>rc_servo (hal::soft::rc_servo)</li> <li>record (hal::spy_handler)</li> <li>reference (hal::static_list::item_iterator, hal::static_list)</li> <li>rtc (hal::stm32f1::clock_tree)</li> <li>read_packet (hal::esp8266::at::packet_manager)</li> </ul>"},{"location":"api/class_members/#s","title":"s","text":"<ul> <li>sample (hal::adc::read_t)</li> <li>set (hal::bit_value, hal::mock::adc, hal::mock::input_pin)</li> <li>sync_segment (hal::can::settings)</li> <li>synchronization_jump_width (hal::can::settings)</li> <li>send (hal::can)</li> <li>setup (hal::cortex_m::interrupt)</li> <li>systick_timer (hal::cortex_m::systick_timer)</li> <li>server_read (hal::esp8266::at)</li> <li>server_write (hal::esp8266::at)</li> <li>set_ip_address (hal::esp8266::at)</li> <li>socket_type (hal::esp8266::at)</li> <li>state (hal::input_pin::level_t, hal::output_pin::level_t, hal::stream_fill, hal::stream_fill_upto, hal::stream_find, hal::stream_parse, hal::stream_skip)</li> <li>sync_jump (hal::lpc40::can::port)</li> <li>spifi (hal::lpc40::clock::configuration)</li> <li>spifi_clock_source (hal::lpc40::clock)</li> <li>scl (hal::lpc40::i2c::bus_info)</li> <li>scl_function (hal::lpc40::i2c::bus_info)</li> <li>sda (hal::lpc40::i2c::bus_info)</li> <li>sda_function (hal::lpc40::i2c::bus_info)</li> <li>setup_interrupt (hal::lpc40::i2c)</li> <li>spi (hal::lpc40::spi)</li> <li>setup_receive_interrupt (hal::lpc40::uart)</li> <li>spy_bus_on (hal::mock::can)</li> <li>spy_configure (hal::mock::can, hal::mock::input_pin, hal::mock::interrupt_pin, hal::mock::output_pin, hal::mock::write_only_spi)</li> <li>spy_on_receive (hal::mock::can)</li> <li>spy_send (hal::mock::can)</li> <li>spy_write (hal::mock::dac)</li> <li>spy_on_trigger (hal::mock::interrupt_pin)</li> <li>spy_power (hal::mock::motor)</li> <li>spy_level (hal::mock::output_pin)</li> <li>spy_duty_cycle (hal::mock::pwm)</li> <li>spy_frequency (hal::mock::pwm)</li> <li>set_frequency (hal::mock::steady_clock)</li> <li>set_uptimes (hal::mock::steady_clock)</li> <li>spy_cancel (hal::mock::timer)</li> <li>spy_is_running (hal::mock::timer)</li> <li>spy_schedule (hal::mock::timer)</li> <li>set_altitude_offset (hal::mpl::mpl3115a2)</li> <li>set_sea_pressure (hal::mpl::mpl3115a2)</li> <li>speed (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>system (hal::rmd::drc, hal::rmd::mc_x)</li> <li>system_control (hal::rmd::drc, hal::rmd::mc_x)</li> <li>speeding (hal::rmd::mc_x::feedback_t)</li> <li>stop (hal::serial::settings)</li> <li>stop_bits (hal::serial::settings)</li> <li>skip_past (hal::skip_past)</li> <li>static_callable (hal::static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt;)</li> <li>setup_self (hal::static_list::item)</li> <li>size (hal::static_list)</li> <li>size_type (hal::static_list)</li> <li>static_list (hal::static_list)</li> <li>steady_clock_timeout (hal::steady_clock_timeout)</li> <li>source (hal::stm32f1::clock_tree::pll_t, hal::stm32f1::clock_tree::rtc_t)</li> <li>system_clock (hal::stm32f1::clock_tree)</li> <li>stream_fill (hal::stream_fill)</li> <li>span (hal::stream_fill_upto)</li> <li>stream_fill_upto (hal::stream_fill_upto)</li> <li>stream_find (hal::stream_find)</li> <li>stream_parse (hal::stream_parse)</li> <li>stream_skip (hal::stream_skip)</li> <li>schedule (hal::timer)</li> <li>set_state (hal::esp8266::at::packet_manager)</li> </ul>"},{"location":"api/class_members/#t","title":"t","text":"<ul> <li>to (hal::bit_value)</li> <li>toggle (hal::bit_value)</li> <li>to_irq_number (hal::cortex_m::interrupt::exception_number)</li> <li>type (hal::esp8266::at::socket_config)</li> <li>transaction (hal::i2c)</li> <li>trigger (hal::interrupt_pin::settings)</li> <li>trigger_edge (hal::interrupt_pin)</li> <li>td (hal::lpc40::can::port)</li> <li>td_function_code (hal::lpc40::can::port)</li> <li>tseg1 (hal::lpc40::can::port)</li> <li>tseg2 (hal::lpc40::can::port)</li> <li>tx (hal::lpc40::uart::port)</li> <li>tx_function (hal::lpc40::uart::port)</li> <li>T (hal::move_interceptor)</li> <li>temperature (hal::mpl::mpl3115a2::temperature_read_t, hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t, hal::temperature_sensor::read_t)</li> <li>transfer (hal::spi)</li> <li>trigger_error_on_call (hal::spy_handler)</li> <li>ticks (hal::steady_clock::uptime_t)</li> <li>tick_period (hal::timer::out_of_bounds_error)</li> </ul>"},{"location":"api/class_members/#u","title":"u","text":"<ul> <li>use_pll0 (hal::lpc40::clock::configuration::cpu_t)</li> <li>usb (hal::lpc40::clock::configuration, hal::stm32f1::clock_tree::pll_t)</li> <li>use_external_oscillator (hal::lpc40::clock::configuration)</li> <li>usb_clock_source (hal::lpc40::clock)</li> <li>usb_divider (hal::lpc40::clock)</li> <li>uart (hal::lpc40::uart)</li> <li>update (hal::overflow_counter)</li> <li>uptime (hal::steady_clock)</li> <li>unfilled (hal::stream_fill_upto)</li> <li>update_state (hal::esp8266::at::packet_manager)</li> </ul>"},{"location":"api/class_members/#v","title":"v","text":"<ul> <li>value (hal::bit_mask, hal::byte_mask, hal::nibble_mask, hal::stream_parse)</li> <li>vector_index (hal::cortex_m::interrupt::exception_number)</li> <li>verify_vector_enabled (hal::cortex_m::interrupt)</li> <li>volts (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>velocity_control (hal::rmd::drc, hal::rmd::mc_x)</li> <li>value_type (hal::static_list::item_iterator, hal::static_list)</li> </ul>"},{"location":"api/class_members/#w","title":"w","text":"<ul> <li>width (hal::bit_mask, hal::bit_value)</li> <li>write (hal::dac, hal::rmd::drc, hal::rmd::mc_x, hal::serial)</li> <li>write_iterator (hal::lpc40::i2c)</li> <li>write_record (hal::mock::write_only_spi)</li> </ul>"},{"location":"api/class_members/#x","title":"x","text":"<ul> <li>x (hal::accelerometer::read_t, hal::gyroscope::read_t, hal::magnetometer::read_t)</li> </ul>"},{"location":"api/class_members/#y","title":"y","text":"<ul> <li>y (hal::accelerometer::read_t, hal::gyroscope::read_t, hal::magnetometer::read_t)</li> </ul>"},{"location":"api/class_members/#z","title":"z","text":"<ul> <li>z (hal::accelerometer::read_t, hal::gyroscope::read_t, hal::magnetometer::read_t)</li> </ul>"},{"location":"api/class_members/#_1","title":"~","text":"<ul> <li>~accelerometer (hal::accelerometer)</li> <li>~adc (hal::adc, hal::lpc40::adc)</li> <li>~bit_modify (hal::bit_modify)</li> <li>~can (hal::can, hal::lpc40::can)</li> <li>~can_router (hal::can_router)</li> <li>~systick_timer (hal::cortex_m::systick_timer)</li> <li>~dac (hal::dac)</li> <li>~distance_sensor (hal::distance_sensor)</li> <li>~gyroscope (hal::gyroscope)</li> <li>~i2c (hal::i2c, hal::lpc40::i2c)</li> <li>~input_pin (hal::input_pin)</li> <li>~interrupt_pin (hal::interrupt_pin, hal::lpc40::interrupt_pin)</li> <li>~spi (hal::lpc40::spi, hal::spi)</li> <li>~magnetometer (hal::magnetometer)</li> <li>~motor (hal::motor)</li> <li>~output_pin (hal::output_pin)</li> <li>~pwm (hal::pwm)</li> <li>~rotation_sensor (hal::rotation_sensor)</li> <li>~serial (hal::serial)</li> <li>~servo (hal::servo)</li> <li>~item (hal::static_list::item)</li> <li>~static_list (hal::static_list)</li> <li>~steady_clock (hal::steady_clock)</li> <li>~temperature_sensor (hal::temperature_sensor)</li> <li>~timer (hal::timer)</li> </ul>"},{"location":"api/class_member_functions/","title":"Class Member Functions","text":""},{"location":"api/class_member_functions/#a","title":"a","text":"<ul> <li>add_message_callback (hal::can_router)</li> <li>at (hal::esp8266::at)</li> <li>adc (hal::lpc40::adc)</li> <li>analog (hal::lpc40::pin)</li> <li>angle (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>adc_multiplexer (hal::soft::adc_multiplexer)</li> <li>adc_mux_pin (hal::soft::adc_mux_pin)</li> </ul>"},{"location":"api/class_member_functions/#b","title":"b","text":"<ul> <li>bit_modify (hal::bit_modify)</li> <li>bit_value (hal::bit_value)</li> <li>bus_on (hal::can)</li> <li>bus (hal::can_router)</li> <li>begin (hal::static_list)</li> </ul>"},{"location":"api/class_member_functions/#c","title":"c","text":"<ul> <li>clear (hal::bit_value)</li> <li>configure (hal::can, hal::i2c, hal::input_pin, hal::interrupt_pin, hal::output_pin, hal::serial, hal::spi)</li> <li>can_router (hal::can_router)</li> <li>create (hal::can_router, hal::esp8266::at, hal::mpl::mpl3115a2, hal::rmd::drc, hal::rmd::mc_x, hal::soft::adc_multiplexer, hal::soft::inert_accelerometer, hal::soft::inert_adc, hal::soft::inert_dac, hal::soft::inert_distance_sensor, hal::soft::inert_gyroscope, hal::soft::inert_input_pin, hal::soft::inert_interrupt_pin, hal::soft::inert_magnetometer, hal::soft::inert_motor, hal::soft::inert_output_pin, hal::soft::inert_pwm, hal::soft::inert_rotation_sensor, hal::soft::inert_steady_clock, hal::soft::inert_temperature_sensor, hal::soft::inert_timer, hal::soft::minimum_speed_i2c, hal::soft::rc_servo, hal::steady_clock_timeout)</li> <li>connect_to_ap (hal::esp8266::at)</li> <li>connect_to_server (hal::esp8266::at)</li> <li>construct_custom_channel (hal::lpc40::adc)</li> <li>can (hal::lpc40::can)</li> <li>clock (hal::lpc40::clock)</li> <li>config (hal::lpc40::clock)</li> <li>construct_custom (hal::lpc40::uart)</li> <li>current (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>call_history (hal::spy_handler)</li> <li>cbegin (hal::static_list)</li> <li>cend (hal::static_list)</li> <li>cancel (hal::timer)</li> </ul>"},{"location":"api/class_member_functions/#d","title":"d","text":"<ul> <li>driver_read (hal::accelerometer, hal::adc, hal::distance_sensor, hal::gyroscope, hal::lpc40::adc, hal::lpc40::uart, hal::magnetometer, hal::mock::adc, hal::rmd::drc_rotation_sensor, hal::rmd::drc_temperature_sensor, hal::rmd::mc_x_rotation, hal::rmd::mc_x_temperature, hal::rotation_sensor, hal::serial, hal::soft::adc_mux_pin, hal::soft::inert_accelerometer, hal::soft::inert_adc, hal::soft::inert_distance_sensor, hal::soft::inert_gyroscope, hal::soft::inert_magnetometer, hal::soft::inert_rotation_sensor, hal::soft::inert_temperature_sensor, hal::temperature_sensor)</li> <li>driver_bus_on (hal::can, hal::lpc40::can, hal::mock::can)</li> <li>driver_configure (hal::can, hal::i2c, hal::input_pin, hal::interrupt_pin, hal::lpc40::can, hal::lpc40::i2c, hal::lpc40::input_pin, hal::lpc40::interrupt_pin, hal::lpc40::output_pin, hal::lpc40::spi, hal::lpc40::uart, hal::mock::can, hal::mock::input_pin, hal::mock::interrupt_pin, hal::mock::output_pin, hal::mock::write_only_spi, hal::output_pin, hal::serial, hal::soft::inert_input_pin, hal::soft::inert_interrupt_pin, hal::soft::inert_output_pin, hal::soft::input_pin_inverter, hal::soft::minimum_speed_i2c, hal::soft::output_pin_inverter, hal::spi, hal::stm32f1::output_pin)</li> <li>driver_on_receive (hal::can, hal::lpc40::can, hal::mock::can)</li> <li>driver_send (hal::can, hal::lpc40::can, hal::mock::can)</li> <li>driver_frequency (hal::cortex_m::dwt_counter, hal::lpc40::pwm, hal::mock::pwm, hal::mock::steady_clock, hal::pwm, hal::soft::inert_pwm, hal::soft::inert_steady_clock, hal::steady_clock)</li> <li>driver_uptime (hal::cortex_m::dwt_counter, hal::mock::steady_clock, hal::soft::inert_steady_clock, hal::steady_clock)</li> <li>dwt_counter (hal::cortex_m::dwt_counter)</li> <li>disable (hal::cortex_m::interrupt)</li> <li>disable_interrupts (hal::cortex_m::interrupt)</li> <li>default_enabled (hal::cortex_m::interrupt::exception_number)</li> <li>driver_cancel (hal::cortex_m::systick_timer, hal::mock::timer, hal::soft::inert_timer, hal::timer)</li> <li>driver_is_running (hal::cortex_m::systick_timer, hal::mock::timer, hal::soft::inert_timer, hal::timer)</li> <li>driver_schedule (hal::cortex_m::systick_timer, hal::mock::timer, hal::soft::inert_timer, hal::timer)</li> <li>driver_write (hal::dac, hal::lpc40::uart, hal::mock::dac, hal::serial, hal::soft::inert_dac)</li> <li>disconnect_from_ap (hal::esp8266::at)</li> <li>disconnect_from_server (hal::esp8266::at)</li> <li>driver_transaction (hal::i2c, hal::lpc40::i2c, hal::soft::minimum_speed_i2c)</li> <li>driver_level (hal::input_pin, hal::lpc40::input_pin, hal::lpc40::output_pin, hal::mock::input_pin, hal::mock::output_pin, hal::output_pin, hal::soft::inert_input_pin, hal::soft::inert_output_pin, hal::soft::input_pin_inverter, hal::soft::output_pin_inverter, hal::stm32f1::output_pin)</li> <li>driver_on_trigger (hal::interrupt_pin, hal::lpc40::interrupt_pin, hal::mock::interrupt_pin, hal::soft::inert_interrupt_pin)</li> <li>dac (hal::lpc40::pin)</li> <li>digital_filter (hal::lpc40::pin)</li> <li>driver_duty_cycle (hal::lpc40::pwm, hal::mock::pwm, hal::pwm, hal::soft::inert_pwm)</li> <li>driver_transfer (hal::lpc40::spi, hal::mock::write_only_spi, hal::spi)</li> <li>driver_flush (hal::lpc40::uart, hal::serial)</li> <li>driver_power (hal::mock::motor, hal::motor, hal::rmd::drc_motor, hal::rmd::mc_x_motor, hal::soft::inert_motor)</li> <li>duty_cycle (hal::pwm)</li> <li>drc (hal::rmd::drc)</li> <li>drc_motor (hal::rmd::drc_motor)</li> <li>drc_rotation_sensor (hal::rmd::drc_rotation_sensor)</li> <li>drc_servo (hal::rmd::drc_servo)</li> <li>driver_position (hal::rmd::drc_servo, hal::rmd::mc_x_servo, hal::servo, hal::soft::rc_servo)</li> <li>drc_temperature_sensor (hal::rmd::drc_temperature_sensor)</li> </ul>"},{"location":"api/class_member_functions/#e","title":"e","text":"<ul> <li>enable (hal::cortex_m::interrupt)</li> <li>enable_interrupts (hal::cortex_m::interrupt)</li> <li>enable_mask (hal::cortex_m::interrupt::exception_number)</li> <li>exception_number (hal::cortex_m::interrupt::exception_number)</li> <li>encoder_calibration_error (hal::rmd::mc_x::feedback_t)</li> <li>empty (hal::static_list)</li> <li>end (hal::static_list)</li> </ul>"},{"location":"api/class_member_functions/#f","title":"f","text":"<ul> <li>from (hal::bit_mask)</li> <li>function (hal::lpc40::pin)</li> <li>frequency (hal::pwm, hal::steady_clock)</li> <li>feedback (hal::rmd::drc, hal::rmd::mc_x)</li> <li>feedback_request (hal::rmd::drc, hal::rmd::mc_x)</li> <li>flush (hal::serial)</li> <li>find (hal::esp8266::at::packet_manager)</li> </ul>"},{"location":"api/class_member_functions/#g","title":"g","text":"<ul> <li>get (hal::bit_value, hal::lpc40::adc, hal::lpc40::can, hal::lpc40::clock, hal::lpc40::i2c, hal::lpc40::input_pin, hal::lpc40::interrupt_pin, hal::lpc40::output_pin, hal::lpc40::pwm, hal::lpc40::spi, hal::lpc40::uart, hal::read_uint32, hal::static_list::item, hal::stm32f1::output_pin)</li> <li>get_vector_table (hal::cortex_m::interrupt)</li> <li>get_event_number (hal::cortex_m::interrupt::exception_number)</li> <li>get_frequency (hal::lpc40::clock)</li> <li>get_max_channel (hal::soft::adc_multiplexer)</li> <li>get_handler (hal::static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt;)</li> </ul>"},{"location":"api/class_member_functions/#h","title":"h","text":"<ul> <li>handlers (hal::can_router)</li> <li>high_slew_rate (hal::lpc40::pin)</li> <li>highspeed_i2c (hal::lpc40::pin)</li> <li>hysteresis (hal::lpc40::pin)</li> <li>history (hal::spy_handler)</li> <li>handler (hal::static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt;)</li> </ul>"},{"location":"api/class_member_functions/#i","title":"i","text":"<ul> <li>insert (hal::bit_value)</li> <li>is_valid (hal::cortex_m::interrupt::exception_number)</li> <li>initialize (hal::cortex_m::interrupt, hal::esp8266::at)</li> <li>interrupt (hal::cortex_m::interrupt, hal::lpc40::i2c)</li> <li>is_connected_to_ap (hal::esp8266::at)</li> <li>is_connected_to_server (hal::esp8266::at)</li> <li>i2c (hal::lpc40::i2c)</li> <li>input_pin (hal::lpc40::input_pin)</li> <li>interrupt_pin (hal::lpc40::interrupt_pin)</li> <li>i2c_high_current (hal::lpc40::pin)</li> <li>input_invert (hal::lpc40::pin)</li> <li>is_on (hal::lpc40::power)</li> <li>interrupt_handler (hal::lpc40::uart)</li> <li>intercept (hal::move_interceptor)</li> <li>inert_accelerometer (hal::soft::inert_accelerometer)</li> <li>inert_adc (hal::soft::inert_adc)</li> <li>inert_dac (hal::soft::inert_dac)</li> <li>inert_distance_sensor (hal::soft::inert_distance_sensor)</li> <li>inert_gyroscope (hal::soft::inert_gyroscope)</li> <li>inert_input_pin (hal::soft::inert_input_pin)</li> <li>inert_interrupt_pin (hal::soft::inert_interrupt_pin)</li> <li>inert_magnetometer (hal::soft::inert_magnetometer)</li> <li>inert_motor (hal::soft::inert_motor)</li> <li>inert_output_pin (hal::soft::inert_output_pin)</li> <li>inert_pwm (hal::soft::inert_pwm)</li> <li>inert_rotation_sensor (hal::soft::inert_rotation_sensor)</li> <li>inert_steady_clock (hal::soft::inert_steady_clock)</li> <li>inert_temperature_sensor (hal::soft::inert_temperature_sensor)</li> <li>inert_timer (hal::soft::inert_timer)</li> <li>input_pin_inverter (hal::soft::input_pin_inverter)</li> <li>item (hal::static_list::item)</li> <li>item_iterator (hal::static_list::item_iterator)</li> <li>is_running (hal::timer)</li> <li>is_complete_header (hal::esp8266::at::packet_manager)</li> </ul>"},{"location":"api/class_member_functions/#l","title":"l","text":"<ul> <li>level (hal::input_pin, hal::output_pin)</li> <li>low_pressure (hal::rmd::mc_x::feedback_t)</li> <li>list (hal::static_list::item)</li> </ul>"},{"location":"api/class_member_functions/#m","title":"m","text":"<ul> <li>max (hal::bit_limits)</li> <li>min (hal::bit_limits)</li> <li>maximum (hal::lpc40::clock)</li> <li>move_interceptor (hal::move_interceptor)</li> <li>mpl3115a2 (hal::mpl::mpl3115a2)</li> <li>motor_stall (hal::rmd::mc_x::feedback_t)</li> <li>mc_x (hal::rmd::mc_x)</li> <li>mc_x_motor (hal::rmd::mc_x_motor)</li> <li>mc_x_rotation (hal::rmd::mc_x_rotation)</li> <li>mc_x_servo (hal::rmd::mc_x_servo)</li> <li>mc_x_temperature (hal::rmd::mc_x_temperature)</li> <li>minimum_speed_i2c (hal::soft::minimum_speed_i2c)</li> </ul>"},{"location":"api/class_member_functions/#n","title":"n","text":"<ul> <li>nop (hal::cortex_m::interrupt)</li> </ul>"},{"location":"api/class_member_functions/#o","title":"o","text":"<ul> <li>operator== (hal::bit_mask, hal::static_list::item_iterator)</li> <li>origin (hal::bit_mask)</li> <li>on_receive (hal::can)</li> <li>operator() (hal::can_router, hal::read_into, hal::read_uint32, hal::read_upto, hal::rmd::drc, hal::rmd::mc_x, hal::skip_past, hal::steady_clock_timeout)</li> <li>operator= (hal::can_router, hal::cortex_m::interrupt::exception_number, hal::lpc40::can, hal::lpc40::i2c, hal::lpc40::interrupt_pin, hal::lpc40::spi, hal::lpc40::uart, hal::move_interceptor, hal::rmd::drc, hal::rmd::mc_x, hal::static_list::item, hal::static_list, hal::steady_clock_timeout)</li> <li>on_trigger (hal::interrupt_pin)</li> <li>output_pin (hal::lpc40::output_pin, hal::stm32f1::output_pin)</li> <li>open_drain (hal::lpc40::pin)</li> <li>off (hal::lpc40::power)</li> <li>on (hal::lpc40::power)</li> <li>over_temperature_protection_tripped (hal::rmd::drc::feedback_t)</li> <li>over_voltage_protection_tripped (hal::rmd::drc::feedback_t)</li> <li>over_current (hal::rmd::mc_x::feedback_t)</li> <li>over_temperature (hal::rmd::mc_x::feedback_t)</li> <li>over_voltage (hal::rmd::mc_x::feedback_t)</li> <li>output_pin_inverter (hal::soft::output_pin_inverter)</li> <li>operator* (hal::static_list::item, hal::static_list::item_iterator)</li> <li>operator!= (hal::static_list::item_iterator)</li> <li>operator++ (hal::static_list::item_iterator)</li> <li>operator-- (hal::static_list::item_iterator)</li> <li>operator-&gt; (hal::static_list::item_iterator)</li> </ul>"},{"location":"api/class_member_functions/#p","title":"p","text":"<ul> <li>pin (hal::lpc40::pin)</li> <li>power (hal::lpc40::power, hal::motor)</li> <li>pwm (hal::lpc40::pwm)</li> <li>position_control (hal::rmd::drc, hal::rmd::mc_x)</li> <li>power_overrun (hal::rmd::mc_x::feedback_t)</li> <li>position (hal::servo)</li> <li>push_back (hal::static_list)</li> <li>packet_length (hal::esp8266::at::packet_manager)</li> <li>packet_manager (hal::esp8266::at::packet_manager)</li> </ul>"},{"location":"api/class_member_functions/#r","title":"r","text":"<ul> <li>read (hal::accelerometer, hal::adc, hal::distance_sensor, hal::gyroscope, hal::magnetometer, hal::rotation_sensor, hal::serial, hal::temperature_sensor)</li> <li>register_cpu_frequency (hal::cortex_m::dwt_counter, hal::cortex_m::systick_timer)</li> <li>register_index (hal::cortex_m::interrupt::exception_number)</li> <li>reinitialize (hal::cortex_m::interrupt)</li> <li>reset (hal::cortex_m::interrupt, hal::esp8266::at, hal::mock::can, hal::mock::dac, hal::mock::input_pin, hal::mock::interrupt_pin, hal::mock::motor, hal::mock::output_pin, hal::mock::pwm, hal::mock::timer, hal::mock::write_only_spi, hal::overflow_counter, hal::spy_handler, hal::esp8266::at::packet_manager)</li> <li>reconfigure_clocks (hal::lpc40::clock)</li> <li>resistor (hal::lpc40::pin)</li> <li>read_altitude (hal::mpl::mpl3115a2)</li> <li>read_pressure (hal::mpl::mpl3115a2)</li> <li>read_temperature (hal::mpl::mpl3115a2)</li> <li>read_into (hal::read_into)</li> <li>read_uint32 (hal::read_uint32)</li> <li>read_upto (hal::read_upto)</li> <li>read_channel (hal::soft::adc_multiplexer)</li> <li>rc_servo (hal::soft::rc_servo)</li> <li>record (hal::spy_handler)</li> <li>read_packet (hal::esp8266::at::packet_manager)</li> </ul>"},{"location":"api/class_member_functions/#s","title":"s","text":"<ul> <li>set (hal::bit_value, hal::mock::adc, hal::mock::input_pin)</li> <li>send (hal::can)</li> <li>setup (hal::cortex_m::interrupt)</li> <li>systick_timer (hal::cortex_m::systick_timer)</li> <li>server_read (hal::esp8266::at)</li> <li>server_write (hal::esp8266::at)</li> <li>set_ip_address (hal::esp8266::at)</li> <li>setup_interrupt (hal::lpc40::i2c)</li> <li>spi (hal::lpc40::spi)</li> <li>setup_receive_interrupt (hal::lpc40::uart)</li> <li>set_frequency (hal::mock::steady_clock)</li> <li>set_uptimes (hal::mock::steady_clock)</li> <li>set_altitude_offset (hal::mpl::mpl3115a2)</li> <li>set_sea_pressure (hal::mpl::mpl3115a2)</li> <li>speed (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>system_control (hal::rmd::drc, hal::rmd::mc_x)</li> <li>speeding (hal::rmd::mc_x::feedback_t)</li> <li>skip_past (hal::skip_past)</li> <li>static_callable (hal::static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt;)</li> <li>setup_self (hal::static_list::item)</li> <li>size (hal::static_list)</li> <li>static_list (hal::static_list)</li> <li>steady_clock_timeout (hal::steady_clock_timeout)</li> <li>state (hal::stream_fill, hal::stream_fill_upto, hal::stream_find, hal::stream_parse, hal::stream_skip)</li> <li>stream_fill (hal::stream_fill)</li> <li>span (hal::stream_fill_upto)</li> <li>stream_fill_upto (hal::stream_fill_upto)</li> <li>stream_find (hal::stream_find)</li> <li>stream_parse (hal::stream_parse)</li> <li>stream_skip (hal::stream_skip)</li> <li>schedule (hal::timer)</li> <li>set_state (hal::esp8266::at::packet_manager)</li> </ul>"},{"location":"api/class_member_functions/#t","title":"t","text":"<ul> <li>to (hal::bit_value)</li> <li>toggle (hal::bit_value)</li> <li>to_irq_number (hal::cortex_m::interrupt::exception_number)</li> <li>transaction (hal::i2c)</li> <li>temperature (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>transfer (hal::spi)</li> <li>trigger_error_on_call (hal::spy_handler)</li> </ul>"},{"location":"api/class_member_functions/#u","title":"u","text":"<ul> <li>uart (hal::lpc40::uart)</li> <li>update (hal::overflow_counter)</li> <li>uptime (hal::steady_clock)</li> <li>unfilled (hal::stream_fill_upto)</li> <li>update_state (hal::esp8266::at::packet_manager)</li> </ul>"},{"location":"api/class_member_functions/#v","title":"v","text":"<ul> <li>value (hal::bit_mask, hal::stream_parse)</li> <li>vector_index (hal::cortex_m::interrupt::exception_number)</li> <li>verify_vector_enabled (hal::cortex_m::interrupt)</li> <li>volts (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>velocity_control (hal::rmd::drc, hal::rmd::mc_x)</li> </ul>"},{"location":"api/class_member_functions/#w","title":"w","text":"<ul> <li>write (hal::dac, hal::serial)</li> </ul>"},{"location":"api/class_member_functions/#_1","title":"~","text":"<ul> <li>~accelerometer (hal::accelerometer)</li> <li>~adc (hal::adc, hal::lpc40::adc)</li> <li>~bit_modify (hal::bit_modify)</li> <li>~can (hal::can, hal::lpc40::can)</li> <li>~can_router (hal::can_router)</li> <li>~systick_timer (hal::cortex_m::systick_timer)</li> <li>~dac (hal::dac)</li> <li>~distance_sensor (hal::distance_sensor)</li> <li>~gyroscope (hal::gyroscope)</li> <li>~i2c (hal::i2c, hal::lpc40::i2c)</li> <li>~input_pin (hal::input_pin)</li> <li>~interrupt_pin (hal::interrupt_pin, hal::lpc40::interrupt_pin)</li> <li>~spi (hal::lpc40::spi, hal::spi)</li> <li>~magnetometer (hal::magnetometer)</li> <li>~motor (hal::motor)</li> <li>~output_pin (hal::output_pin)</li> <li>~pwm (hal::pwm)</li> <li>~rotation_sensor (hal::rotation_sensor)</li> <li>~serial (hal::serial)</li> <li>~servo (hal::servo)</li> <li>~item (hal::static_list::item)</li> <li>~static_list (hal::static_list)</li> <li>~steady_clock (hal::steady_clock)</li> <li>~temperature_sensor (hal::temperature_sensor)</li> <li>~timer (hal::timer)</li> </ul>"},{"location":"api/class_member_variables/","title":"Class Member Variables","text":""},{"location":"api/class_member_variables/#a","title":"a","text":"<ul> <li>adc_pin (hal::lpc40::adc::channel)</li> <li>altitude (hal::mpl::mpl3115a2::altitude_read_t)</li> <li>angle (hal::rotation_sensor::read_t, hal::soft::rc_servo::ranges)</li> <li>available (hal::serial::read_t)</li> <li>ahb (hal::stm32f1::clock_tree)</li> <li>apb1 (hal::stm32f1::clock_tree::ahb_t)</li> <li>apb2 (hal::stm32f1::clock_tree::ahb_t)</li> <li>adc (hal::stm32f1::clock_tree::ahb_t::apb2_t)</li> </ul>"},{"location":"api/class_member_variables/#b","title":"b","text":"<ul> <li>baud_rate (hal::can::settings, hal::serial::settings)</li> </ul>"},{"location":"api/class_member_variables/#c","title":"c","text":"<ul> <li>core_interrupts (hal::cortex_m::interrupt)</li> <li>clock_rate (hal::i2c::settings, hal::lpc40::adc::channel, hal::spi::settings)</li> <li>cpu (hal::lpc40::clock::configuration)</li> <li>clock (hal::lpc40::clock::configuration::spifi_t, hal::lpc40::clock::configuration::usb_t, hal::lpc40::spi::bus_info)</li> <li>clock_function (hal::lpc40::spi::bus_info)</li> <li>capacity (hal::serial::read_t)</li> <li>clock_idles_high (hal::spi::settings)</li> <li>callback (hal::static_callable&lt; owner_class, reference_designator, return_t(args_t... p_args)&gt;)</li> </ul>"},{"location":"api/class_member_variables/#d","title":"d","text":"<ul> <li>distance (hal::distance_sensor::read_t)</li> <li>data (hal::esp8266::at::read_t, hal::esp8266::at::write_t, hal::serial::read_t, hal::serial::write_t)</li> <li>domain (hal::esp8266::at::socket_config)</li> <li>default_peripheral_divider (hal::lpc40::clock)</li> <li>divider (hal::lpc40::clock::configuration::cpu_t, hal::lpc40::clock::configuration::spifi_t, hal::lpc40::clock::configuration::usb_t, hal::stm32f1::clock_tree::ahb_t, hal::stm32f1::clock_tree::ahb_t::apb1_t, hal::stm32f1::clock_tree::ahb_t::apb2_t, hal::stm32f1::clock_tree::ahb_t::apb2_t::adc_t, hal::stm32f1::clock_tree::pll_t::usb_divider_t)</li> <li>duty_cycle (hal::lpc40::i2c::bus_info)</li> <li>data_in (hal::lpc40::spi::bus_info)</li> <li>data_in_function (hal::lpc40::spi::bus_info)</li> <li>data_out (hal::lpc40::spi::bus_info)</li> <li>data_out_function (hal::lpc40::spi::bus_info)</li> <li>default_max_polling_retries (hal::mpl::mpl3115a2)</li> <li>default_max_speed (hal::soft::minimum_speed_i2c)</li> <li>default_filler (hal::spi)</li> <li>data_valid_on_trailing_edge (hal::spi::settings)</li> </ul>"},{"location":"api/class_member_variables/#e","title":"e","text":"<ul> <li>enable_mask_code (hal::cortex_m::interrupt::exception_number)</li> <li>emc_half_cpu_divider (hal::lpc40::clock::configuration)</li> <li>enabled (hal::lpc40::clock::configuration::pll_t)</li> <li>encoder (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>enable (hal::stm32f1::clock_tree::pll_t, hal::stm32f1::clock_tree::rtc_t)</li> </ul>"},{"location":"api/class_member_variables/#f","title":"f","text":"<ul> <li>frequency (hal::soft::rc_servo::settings)</li> </ul>"},{"location":"api/class_member_variables/#h","title":"h","text":"<ul> <li>handler (hal::can_router::route)</li> <li>high_speed_external (hal::stm32f1::clock_tree)</li> </ul>"},{"location":"api/class_member_variables/#i","title":"i","text":"<ul> <li>id (hal::can::message_t, hal::can_router::route, hal::lpc40::can::port, hal::lpc40::uart::port)</li> <li>is_remote_request (hal::can::message_t)</li> <li>index_position (hal::cortex_m::interrupt::exception_number)</li> <li>index (hal::lpc40::adc::channel, hal::lpc40::pwm::channel)</li> <li>irq_number (hal::lpc40::can::port, hal::lpc40::i2c::bus_info, hal::lpc40::uart::port)</li> <li>irc_frequency (hal::lpc40::clock)</li> <li>is_running (hal::timer::is_running_t)</li> </ul>"},{"location":"api/class_member_variables/#l","title":"l","text":"<ul> <li>length (hal::can::message_t)</li> <li>low_speed_external (hal::stm32f1::clock_tree)</li> </ul>"},{"location":"api/class_member_variables/#m","title":"m","text":"<ul> <li>m_pointer (hal::bit_modify)</li> <li>m_value (hal::bit_value, hal::stream_parse)</li> <li>m_can (hal::can_router)</li> <li>m_handlers (hal::can_router)</li> <li>m_cpu_frequency (hal::cortex_m::dwt_counter)</li> <li>m_uptime (hal::cortex_m::dwt_counter, hal::soft::inert_steady_clock)</li> <li>m_id (hal::cortex_m::interrupt::exception_number, hal::cortex_m::interrupt)</li> <li>m_frequency (hal::cortex_m::systick_timer, hal::mock::steady_clock, hal::soft::inert_steady_clock)</li> <li>m_packet_manager (hal::esp8266::at)</li> <li>m_serial (hal::esp8266::at, hal::read_into, hal::read_uint32, hal::read_upto, hal::skip_past)</li> <li>m_sample (hal::lpc40::adc)</li> <li>m_moved (hal::lpc40::can, hal::lpc40::i2c, hal::lpc40::interrupt_pin, hal::lpc40::spi)</li> <li>m_port (hal::lpc40::can, hal::lpc40::input_pin, hal::lpc40::interrupt_pin, hal::lpc40::output_pin, hal::lpc40::pin, hal::lpc40::uart, hal::stm32f1::output_pin)</li> <li>m_receive_handler (hal::lpc40::can)</li> <li>multiply (hal::lpc40::clock::configuration::pll_t, hal::stm32f1::clock_tree::pll_t)</li> <li>m_config (hal::lpc40::clock)</li> <li>m_cpu_clock_rate (hal::lpc40::clock)</li> <li>m_emc_clock_rate (hal::lpc40::clock)</li> <li>m_peripheral_clock_rate (hal::lpc40::clock)</li> <li>m_spifi_clock_source_rate (hal::lpc40::clock)</li> <li>m_usb_clock_rate (hal::lpc40::clock)</li> <li>m_address (hal::lpc40::i2c)</li> <li>m_bus (hal::lpc40::i2c)</li> <li>m_busy (hal::lpc40::i2c)</li> <li>m_read_end (hal::lpc40::i2c)</li> <li>m_read_iterator (hal::lpc40::i2c)</li> <li>m_status (hal::lpc40::i2c)</li> <li>m_write_end (hal::lpc40::i2c)</li> <li>m_write_iterator (hal::lpc40::i2c)</li> <li>m_pin (hal::lpc40::input_pin, hal::lpc40::interrupt_pin, hal::lpc40::output_pin, hal::lpc40::pin, hal::stm32f1::output_pin)</li> <li>m_peripheral (hal::lpc40::power)</li> <li>m_channel (hal::lpc40::pwm)</li> <li>m_info (hal::lpc40::spi)</li> <li>m_receive_buffer (hal::lpc40::uart)</li> <li>m_adc_values (hal::mock::adc)</li> <li>m_levels (hal::mock::input_pin)</li> <li>m_current_level (hal::mock::output_pin)</li> <li>m_last_uptime (hal::mock::steady_clock)</li> <li>m_uptime_values (hal::mock::steady_clock)</li> <li>m_is_running (hal::mock::timer, hal::soft::inert_timer)</li> <li>m_i2c (hal::mpl::mpl3115a2, hal::soft::minimum_speed_i2c)</li> <li>m_sensor_mode (hal::mpl::mpl3115a2)</li> <li>m_overflow_count (hal::overflow_counter)</li> <li>m_previous_count (hal::overflow_counter)</li> <li>m_buffer (hal::read_into, hal::read_upto, hal::stream_fill, hal::stream_fill_upto)</li> <li>m_read_limit (hal::read_into, hal::read_uint32, hal::read_upto, hal::skip_past)</li> <li>m_finished (hal::read_uint32, hal::stream_parse)</li> <li>m_found_digit (hal::read_uint32, hal::stream_parse)</li> <li>m_integer_value (hal::read_uint32)</li> <li>m_search_index (hal::read_upto, hal::skip_past, hal::stream_fill_upto, hal::stream_find)</li> <li>m_sequence (hal::read_upto, hal::skip_past, hal::stream_fill_upto, hal::stream_find)</li> <li>message_number (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>m_clock (hal::rmd::drc, hal::rmd::mc_x, hal::soft::adc_multiplexer)</li> <li>m_device_id (hal::rmd::drc, hal::rmd::mc_x)</li> <li>m_feedback (hal::rmd::drc, hal::rmd::mc_x)</li> <li>m_gear_ratio (hal::rmd::drc, hal::rmd::mc_x)</li> <li>m_max_response_time (hal::rmd::drc, hal::rmd::mc_x)</li> <li>m_route_item (hal::rmd::drc, hal::rmd::mc_x)</li> <li>m_router (hal::rmd::drc, hal::rmd::mc_x)</li> <li>m_drc (hal::rmd::drc_motor, hal::rmd::drc_rotation_sensor, hal::rmd::drc_servo, hal::rmd::drc_temperature_sensor)</li> <li>m_max_speed (hal::rmd::drc_motor, hal::rmd::drc_servo, hal::rmd::mc_x_motor, hal::rmd::mc_x_servo)</li> <li>m_mc_x (hal::rmd::mc_x_motor, hal::rmd::mc_x_rotation, hal::rmd::mc_x_servo, hal::rmd::mc_x_temperature)</li> <li>max (hal::servo::range_error)</li> <li>min (hal::servo::range_error)</li> <li>m_signal_pins (hal::soft::adc_multiplexer)</li> <li>m_source_pin (hal::soft::adc_multiplexer)</li> <li>m_mux (hal::soft::adc_mux_pin)</li> <li>m_mux_port (hal::soft::adc_mux_pin)</li> <li>m_values (hal::soft::inert_accelerometer)</li> <li>m_result (hal::soft::inert_adc, hal::soft::inert_distance_sensor, hal::soft::inert_gyroscope, hal::soft::inert_magnetometer)</li> <li>m_level (hal::soft::inert_input_pin, hal::soft::inert_output_pin)</li> <li>m_position (hal::soft::inert_rotation_sensor)</li> <li>m_temperature (hal::soft::inert_temperature_sensor)</li> <li>m_input_pin (hal::soft::input_pin_inverter)</li> <li>m_lowest_seen_frequency (hal::soft::minimum_speed_i2c)</li> <li>m_output_pin (hal::soft::output_pin_inverter)</li> <li>max_angle (hal::soft::rc_servo::settings)</li> <li>max_microseconds (hal::soft::rc_servo::settings)</li> <li>min_angle (hal::soft::rc_servo::settings)</li> <li>min_microseconds (hal::soft::rc_servo::settings)</li> <li>m_pwm (hal::soft::rc_servo)</li> <li>m_ranges (hal::soft::rc_servo)</li> <li>m_call_history (hal::spy_handler)</li> <li>m_error_trigger (hal::spy_handler)</li> <li>m_list (hal::static_list::item, hal::static_list::item_iterator)</li> <li>m_next (hal::static_list::item)</li> <li>m_object (hal::static_list::item)</li> <li>m_previous (hal::static_list::item)</li> <li>m_self (hal::static_list::item_iterator)</li> <li>m_head (hal::static_list)</li> <li>m_size (hal::static_list)</li> <li>m_tail (hal::static_list)</li> <li>m_counter (hal::steady_clock_timeout)</li> <li>m_cycles_until_timeout (hal::steady_clock_timeout)</li> <li>m_fill_amount (hal::stream_fill, hal::stream_fill_upto)</li> <li>m_skip (hal::stream_skip)</li> <li>maximum (hal::timer::out_of_bounds_error)</li> <li>m_length (hal::esp8266::at::packet_manager)</li> <li>m_state (hal::esp8266::at::packet_manager)</li> </ul>"},{"location":"api/class_member_variables/#n","title":"n","text":"<ul> <li>noop (hal::can_router)</li> </ul>"},{"location":"api/class_member_variables/#o","title":"o","text":"<ul> <li>oscillator_frequency (hal::lpc40::clock::configuration)</li> <li>open_drain (hal::output_pin::settings)</li> <li>operating_frequency (hal::steady_clock::frequency_t)</li> </ul>"},{"location":"api/class_member_variables/#p","title":"p","text":"<ul> <li>position (hal::bit_mask)</li> <li>payload (hal::can::message_t)</li> <li>phase_segment1 (hal::can::settings)</li> <li>phase_segment2 (hal::can::settings)</li> <li>propagation_delay (hal::can::settings)</li> <li>port (hal::esp8266::at::socket_config)</li> <li>pin_function (hal::lpc40::adc::channel, hal::lpc40::pwm::channel)</li> <li>peripheral_divider (hal::lpc40::clock::configuration)</li> <li>pll (hal::lpc40::clock::configuration, hal::stm32f1::clock_tree)</li> <li>peripheral_id (hal::lpc40::i2c::bus_info, hal::lpc40::pwm::channel, hal::lpc40::spi::bus_info)</li> <li>pwm_pin (hal::lpc40::pwm::channel)</li> <li>pressure (hal::mpl::mpl3115a2::pressure_read_t)</li> <li>parity (hal::serial::settings)</li> <li>percent (hal::soft::rc_servo::ranges)</li> </ul>"},{"location":"api/class_member_variables/#r","title":"r","text":"<ul> <li>resistor (hal::input_pin::settings, hal::interrupt_pin::settings, hal::output_pin::settings)</li> <li>rd (hal::lpc40::can::port)</li> <li>rd_function_code (hal::lpc40::can::port)</li> <li>rx (hal::lpc40::uart::port)</li> <li>rx_function (hal::lpc40::uart::port)</li> <li>raw_current (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>raw_error_state (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>raw_motor_temperature (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>raw_multi_turn_angle (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>raw_speed (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>raw_volts (hal::rmd::drc::feedback_t, hal::rmd::mc_x::feedback_t)</li> <li>rtc (hal::stm32f1::clock_tree)</li> </ul>"},{"location":"api/class_member_variables/#s","title":"s","text":"<ul> <li>sample (hal::adc::read_t)</li> <li>sync_segment (hal::can::settings)</li> <li>synchronization_jump_width (hal::can::settings)</li> <li>state (hal::input_pin::level_t, hal::output_pin::level_t)</li> <li>sync_jump (hal::lpc40::can::port)</li> <li>spifi (hal::lpc40::clock::configuration)</li> <li>scl (hal::lpc40::i2c::bus_info)</li> <li>scl_function (hal::lpc40::i2c::bus_info)</li> <li>sda (hal::lpc40::i2c::bus_info)</li> <li>sda_function (hal::lpc40::i2c::bus_info)</li> <li>spy_bus_on (hal::mock::can)</li> <li>spy_configure (hal::mock::can, hal::mock::input_pin, hal::mock::interrupt_pin, hal::mock::output_pin, hal::mock::write_only_spi)</li> <li>spy_on_receive (hal::mock::can)</li> <li>spy_send (hal::mock::can)</li> <li>spy_write (hal::mock::dac)</li> <li>spy_on_trigger (hal::mock::interrupt_pin)</li> <li>spy_power (hal::mock::motor)</li> <li>spy_level (hal::mock::output_pin)</li> <li>spy_duty_cycle (hal::mock::pwm)</li> <li>spy_frequency (hal::mock::pwm)</li> <li>spy_cancel (hal::mock::timer)</li> <li>spy_is_running (hal::mock::timer)</li> <li>spy_schedule (hal::mock::timer)</li> <li>stop (hal::serial::settings)</li> <li>source (hal::stm32f1::clock_tree::pll_t, hal::stm32f1::clock_tree::rtc_t)</li> <li>system_clock (hal::stm32f1::clock_tree)</li> </ul>"},{"location":"api/class_member_variables/#t","title":"t","text":"<ul> <li>type (hal::esp8266::at::socket_config)</li> <li>trigger (hal::interrupt_pin::settings)</li> <li>td (hal::lpc40::can::port)</li> <li>td_function_code (hal::lpc40::can::port)</li> <li>tseg1 (hal::lpc40::can::port)</li> <li>tseg2 (hal::lpc40::can::port)</li> <li>tx (hal::lpc40::uart::port)</li> <li>tx_function (hal::lpc40::uart::port)</li> <li>T (hal::move_interceptor)</li> <li>temperature (hal::mpl::mpl3115a2::temperature_read_t, hal::temperature_sensor::read_t)</li> <li>ticks (hal::steady_clock::uptime_t)</li> <li>tick_period (hal::timer::out_of_bounds_error)</li> </ul>"},{"location":"api/class_member_variables/#u","title":"u","text":"<ul> <li>use_pll0 (hal::lpc40::clock::configuration::cpu_t)</li> <li>usb (hal::lpc40::clock::configuration, hal::stm32f1::clock_tree::pll_t)</li> <li>use_external_oscillator (hal::lpc40::clock::configuration)</li> </ul>"},{"location":"api/class_member_variables/#v","title":"v","text":"<ul> <li>value (hal::byte_mask, hal::nibble_mask)</li> </ul>"},{"location":"api/class_member_variables/#w","title":"w","text":"<ul> <li>width (hal::bit_mask, hal::bit_value)</li> <li>write_record (hal::mock::write_only_spi)</li> </ul>"},{"location":"api/class_member_variables/#x","title":"x","text":"<ul> <li>x (hal::accelerometer::read_t, hal::gyroscope::read_t, hal::magnetometer::read_t)</li> </ul>"},{"location":"api/class_member_variables/#y","title":"y","text":"<ul> <li>y (hal::accelerometer::read_t, hal::gyroscope::read_t, hal::magnetometer::read_t)</li> </ul>"},{"location":"api/class_member_variables/#z","title":"z","text":"<ul> <li>z (hal::accelerometer::read_t, hal::gyroscope::read_t, hal::magnetometer::read_t)</li> </ul>"},{"location":"api/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"api/class_member_typedefs/#c","title":"c","text":"<ul> <li>const_iterator (hal::static_list)</li> <li>const_pointer (hal::static_list)</li> <li>const_reference (hal::static_list)</li> </ul>"},{"location":"api/class_member_typedefs/#d","title":"d","text":"<ul> <li>deadline (hal::esp8266::at)</li> <li>difference_type (hal::static_list, hal::static_list::item_iterator)</li> </ul>"},{"location":"api/class_member_typedefs/#h","title":"h","text":"<ul> <li>handler (hal::can, hal::interrupt_pin)</li> </ul>"},{"location":"api/class_member_typedefs/#i","title":"i","text":"<ul> <li>id_t (hal::can)</li> <li>iterator_category (hal::static_list::item_iterator)</li> <li>iterator (hal::static_list)</li> </ul>"},{"location":"api/class_member_typedefs/#m","title":"m","text":"<ul> <li>message_handler (hal::can_router)</li> </ul>"},{"location":"api/class_member_typedefs/#p","title":"p","text":"<ul> <li>pointer (hal::static_list::item_iterator, hal::static_list)</li> </ul>"},{"location":"api/class_member_typedefs/#r","title":"r","text":"<ul> <li>route_item (hal::can_router)</li> <li>read_iterator (hal::lpc40::i2c)</li> <li>reference (hal::static_list::item_iterator, hal::static_list)</li> </ul>"},{"location":"api/class_member_typedefs/#s","title":"s","text":"<ul> <li>size_type (hal::static_list)</li> </ul>"},{"location":"api/class_member_typedefs/#v","title":"v","text":"<ul> <li>value_type (hal::static_list::item_iterator, hal::static_list)</li> </ul>"},{"location":"api/class_member_typedefs/#w","title":"w","text":"<ul> <li>write_iterator (hal::lpc40::i2c)</li> </ul>"},{"location":"api/class_member_enums/","title":"Class Member Enums","text":""},{"location":"api/class_member_enums/#a","title":"a","text":"<ul> <li>actuate (hal::rmd::drc, hal::rmd::mc_x)</li> </ul>"},{"location":"api/class_member_enums/#c","title":"c","text":"<ul> <li>clock_source (hal::cortex_m::systick_timer)</li> </ul>"},{"location":"api/class_member_enums/#f","title":"f","text":"<ul> <li>flash_configuration (hal::lpc40::clock)</li> </ul>"},{"location":"api/class_member_enums/#m","title":"m","text":"<ul> <li>mode (hal::mpl::mpl3115a2)</li> </ul>"},{"location":"api/class_member_enums/#p","title":"p","text":"<ul> <li>parity (hal::serial::settings)</li> </ul>"},{"location":"api/class_member_enums/#r","title":"r","text":"<ul> <li>read (hal::rmd::drc, hal::rmd::mc_x)</li> </ul>"},{"location":"api/class_member_enums/#s","title":"s","text":"<ul> <li>socket_type (hal::esp8266::at)</li> <li>spifi_clock_source (hal::lpc40::clock)</li> <li>system (hal::rmd::drc, hal::rmd::mc_x)</li> <li>stop_bits (hal::serial::settings)</li> </ul>"},{"location":"api/class_member_enums/#t","title":"t","text":"<ul> <li>trigger_edge (hal::interrupt_pin)</li> </ul>"},{"location":"api/class_member_enums/#u","title":"u","text":"<ul> <li>usb_clock_source (hal::lpc40::clock)</li> <li>usb_divider (hal::lpc40::clock)</li> </ul>"},{"location":"api/class_member_enums/#w","title":"w","text":"<ul> <li>write (hal::rmd::drc, hal::rmd::mc_x)</li> </ul>"},{"location":"api/namespace_members/","title":"Namespace Members","text":""},{"location":"api/namespace_members/#a","title":"a","text":"<ul> <li>absolute_value (hal)</li> <li>ampere (hal)</li> <li>as_bytes (hal)</li> <li>as_writable_bytes (hal)</li> <li>attempt (hal)</li> <li>attempt_all (hal)</li> <li>a0 (hal::micromod::v1)</li> <li>a1 (hal::micromod::v1)</li> <li>adc_divider (hal::stm32f1)</li> <li>ahb_bus (hal::stm32f1)</li> <li>ahb_divider (hal::stm32f1)</li> <li>apb1_bus (hal::stm32f1)</li> <li>apb2_bus (hal::stm32f1)</li> <li>apb_divider (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_members/#b","title":"b","text":"<ul> <li>bit_extract (hal)</li> <li>bit_width (hal)</li> <li>byte (hal)</li> <li>byte_m (hal)</li> <li>battery (hal::micromod::v1)</li> <li>beyond_bus (hal::stm32f1)</li> <li>bus_id_offset (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_members/#c","title":"c","text":"<ul> <li>callback (hal)</li> <li>celsius (hal)</li> <li>convertible_to_bytes (hal)</li> <li>create_timeout (hal)</li> <li>cycles_per (hal)</li> <li>can (hal::micromod::v1)</li> <li>console (hal::micromod::v1)</li> <li>configure_clocks (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_members/#d","title":"d","text":"<ul> <li>degrees (hal)</li> <li>delay (hal)</li> <li>distance (hal)</li> <li>duration_from_cycles (hal)</li> <li>d0 (hal::micromod::v1)</li> <li>d1 (hal::micromod::v1)</li> </ul>"},{"location":"api/namespace_members/#e","title":"e","text":"<ul> <li>enumeration (hal)</li> <li>equals (hal)</li> <li>error_handler (hal)</li> <li>error_t (hal::lpc40, hal::stm32f1)</li> <li>enter_power_saving_mode (hal::micromod::v1)</li> </ul>"},{"location":"api/namespace_members/#f","title":"f","text":"<ul> <li>failed (hal)</li> <li>finished (hal)</li> <li>function_ref (hal)</li> <li>future_deadline (hal)</li> <li>flash_clock (hal::stm32f1)</li> <li>frequency (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_members/#g","title":"g","text":"<ul> <li>g_force (hal)</li> <li>gauss (hal)</li> <li>generate_field_of_ones (hal)</li> <li>get_interrupt_vector_table_address (hal::cortex_m)</li> </ul>"},{"location":"api/namespace_members/#h","title":"h","text":"<ul> <li>halt (hal)</li> <li>has_work_state (hal)</li> <li>hertz (hal)</li> </ul>"},{"location":"api/namespace_members/#i","title":"i","text":"<ul> <li>initialize_bss_section (hal::cortex_m)</li> <li>initialize_data_section (hal::cortex_m)</li> <li>initialize_floating_point_unit (hal::cortex_m)</li> <li>interrupt_pointer (hal::cortex_m)</li> <li>irq (hal::cortex_m, hal::lpc40, hal::stm32f1)</li> <li>invalid_option (hal::error)</li> <li>i2c (hal::micromod::v1)</li> <li>i2c1 (hal::micromod::v1)</li> <li>i2c_interrupt_pin (hal::micromod::v1)</li> <li>initialize_platform (hal::micromod::v1)</li> <li>input_g0 (hal::micromod::v1)</li> <li>input_g1 (hal::micromod::v1)</li> <li>input_g10 (hal::micromod::v1)</li> <li>input_g2 (hal::micromod::v1)</li> <li>input_g3 (hal::micromod::v1)</li> <li>input_g4 (hal::micromod::v1)</li> <li>input_g5 (hal::micromod::v1)</li> <li>input_g6 (hal::micromod::v1)</li> <li>input_g7 (hal::micromod::v1)</li> <li>input_g8 (hal::micromod::v1)</li> <li>input_g9 (hal::micromod::v1)</li> <li>interrupt_g0 (hal::micromod::v1)</li> <li>interrupt_g1 (hal::micromod::v1)</li> <li>interrupt_g10 (hal::micromod::v1)</li> <li>interrupt_g2 (hal::micromod::v1)</li> <li>interrupt_g3 (hal::micromod::v1)</li> <li>interrupt_g4 (hal::micromod::v1)</li> <li>interrupt_g5 (hal::micromod::v1)</li> <li>interrupt_g6 (hal::micromod::v1)</li> <li>interrupt_g7 (hal::micromod::v1)</li> <li>interrupt_g8 (hal::micromod::v1)</li> <li>interrupt_g9 (hal::micromod::v1)</li> <li>internal_high_speed_oscillator (hal::stm32f1)</li> <li>internal_low_speed_oscillator (hal::stm32f1)</li> <li>i2c_operation (hal)</li> <li>in_progress (hal)</li> <li>inplace_function (hal)</li> <li>is_valid (hal)</li> </ul>"},{"location":"api/namespace_members/#l","title":"l","text":"<ul> <li>led (hal::micromod::v1)</li> </ul>"},{"location":"api/namespace_members/#m","title":"m","text":"<ul> <li>make_motor (hal::rmd)</li> <li>make_rotation_sensor (hal::rmd)</li> <li>make_servo (hal::rmd)</li> <li>make_temperature_sensor (hal::rmd)</li> <li>make_adc (hal::soft)</li> <li>map (hal)</li> <li>match (hal)</li> <li>meters (hal)</li> <li>multiply (hal)</li> </ul>"},{"location":"api/namespace_members/#n","title":"n","text":"<ul> <li>never_timeout (hal)</li> <li>new_error (hal)</li> <li>nibble_m (hal)</li> </ul>"},{"location":"api/namespace_members/#o","title":"o","text":"<ul> <li>operator\"\"_A (hal::literals)</li> <li>operator\"\"_C (hal::literals)</li> <li>operator\"\"_F (hal::literals)</li> <li>operator\"\"_GHz (hal::literals)</li> <li>operator\"\"_Hz (hal::literals)</li> <li>operator\"\"_K (hal::literals)</li> <li>operator\"\"_MHz (hal::literals)</li> <li>operator\"\"_V (hal::literals)</li> <li>operator\"\"_deg (hal::literals)</li> <li>operator\"\"_deg_per_sec (hal::literals)</li> <li>operator\"\"_g (hal::literals)</li> <li>operator\"\"_inch (hal::literals)</li> <li>operator\"\"_kA (hal::literals)</li> <li>operator\"\"_kHz (hal::literals)</li> <li>operator\"\"_kV (hal::literals)</li> <li>operator\"\"_km (hal::literals)</li> <li>operator\"\"_m (hal::literals)</li> <li>operator\"\"_mA (hal::literals)</li> <li>operator\"\"_mV (hal::literals)</li> <li>operator\"\"_miles (hal::literals)</li> <li>operator\"\"_mm (hal::literals)</li> <li>operator\"\"_rpm (hal::literals)</li> <li>operator\"\"_uA (hal::literals)</li> <li>operator\"\"_uV (hal::literals)</li> <li>operator\"\"_um (hal::literals)</li> <li>operator\"\"_yards (hal::literals)</li> <li>output_g0 (hal::micromod::v1)</li> <li>output_g1 (hal::micromod::v1)</li> <li>output_g10 (hal::micromod::v1)</li> <li>output_g2 (hal::micromod::v1)</li> <li>output_g3 (hal::micromod::v1)</li> <li>output_g4 (hal::micromod::v1)</li> <li>output_g5 (hal::micromod::v1)</li> <li>output_g6 (hal::micromod::v1)</li> <li>output_g7 (hal::micromod::v1)</li> <li>output_g8 (hal::micromod::v1)</li> <li>output_g9 (hal::micromod::v1)</li> <li>on_error_callback (hal)</li> <li>operator&lt;&lt; (hal)</li> <li>operator== (hal)</li> </ul>"},{"location":"api/namespace_members/#p","title":"p","text":"<ul> <li>peripheral (hal::lpc40, hal::stm32f1)</li> <li>pwm0 (hal::micromod::v1)</li> <li>pwm1 (hal::micromod::v1)</li> <li>pll_multiply (hal::stm32f1)</li> <li>pll_source (hal::stm32f1)</li> <li>pin_resistor (hal)</li> <li>print (hal)</li> <li>probe (hal)</li> </ul>"},{"location":"api/namespace_members/#r","title":"r","text":"<ul> <li>reset (hal::cortex_m, hal::micromod::v1)</li> <li>release_jtag_pins (hal::stm32f1)</li> <li>rtc_source (hal::stm32f1)</li> <li>read (hal)</li> <li>result (hal)</li> <li>rounding_division (hal)</li> <li>rpm (hal)</li> </ul>"},{"location":"api/namespace_members/#s","title":"s","text":"<ul> <li>set_interrupt_vector_table_address (hal::cortex_m)</li> <li>spi (hal::micromod::v1)</li> <li>spi1 (hal::micromod::v1)</li> <li>spi_interrupt_pin (hal::micromod::v1)</li> <li>system_timer (hal::micromod::v1)</li> <li>system_clock_select (hal::stm32f1)</li> <li>status (hal)</li> <li>success (hal)</li> </ul>"},{"location":"api/namespace_members/#t","title":"t","text":"<ul> <li>terminated (hal)</li> <li>time_duration (hal)</li> <li>timeout (hal)</li> <li>timeout_function (hal)</li> <li>timeout_generator (hal)</li> <li>to_8_bit_address (hal)</li> <li>to_array (hal)</li> <li>to_string (hal)</li> <li>try_until (hal)</li> </ul>"},{"location":"api/namespace_members/#u","title":"u","text":"<ul> <li>uart1 (hal::micromod::v1)</li> <li>uart2 (hal::micromod::v1)</li> <li>uptime_clock (hal::micromod::v1)</li> <li>usb_divider (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_members/#v","title":"v","text":"<ul> <li>value (hal)</li> <li>volts (hal)</li> </ul>"},{"location":"api/namespace_members/#w","title":"w","text":"<ul> <li>wait_for_event (hal::cortex_m)</li> <li>wait_for_interrupt (hal::cortex_m)</li> <li>watchdog_clock_rate (hal::stm32f1)</li> <li>wavelength (hal)</li> <li>work_function (hal)</li> <li>work_state (hal)</li> <li>worker (hal)</li> <li>write (hal)</li> <li>write_partial (hal)</li> <li>write_then_read (hal)</li> </ul>"},{"location":"api/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"api/namespace_member_functions/#a","title":"a","text":"<ul> <li>absolute_value (hal)</li> <li>as_bytes (hal)</li> <li>as_writable_bytes (hal)</li> <li>attempt (hal)</li> <li>attempt_all (hal)</li> <li>a0 (hal::micromod::v1)</li> <li>a1 (hal::micromod::v1)</li> </ul>"},{"location":"api/namespace_member_functions/#b","title":"b","text":"<ul> <li>bit_extract (hal)</li> <li>bit_width (hal)</li> <li>battery (hal::micromod::v1)</li> </ul>"},{"location":"api/namespace_member_functions/#c","title":"c","text":"<ul> <li>create_timeout (hal)</li> <li>cycles_per (hal)</li> <li>can (hal::micromod::v1)</li> <li>console (hal::micromod::v1)</li> <li>configure_clocks (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_member_functions/#d","title":"d","text":"<ul> <li>delay (hal)</li> <li>distance (hal)</li> <li>duration_from_cycles (hal)</li> <li>d0 (hal::micromod::v1)</li> <li>d1 (hal::micromod::v1)</li> </ul>"},{"location":"api/namespace_member_functions/#e","title":"e","text":"<ul> <li>equals (hal)</li> <li>enter_power_saving_mode (hal::micromod::v1)</li> </ul>"},{"location":"api/namespace_member_functions/#f","title":"f","text":"<ul> <li>failed (hal)</li> <li>finished (hal)</li> <li>future_deadline (hal)</li> <li>frequency (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_member_functions/#g","title":"g","text":"<ul> <li>generate_field_of_ones (hal)</li> <li>get_interrupt_vector_table_address (hal::cortex_m)</li> </ul>"},{"location":"api/namespace_member_functions/#h","title":"h","text":"<ul> <li>halt (hal)</li> </ul>"},{"location":"api/namespace_member_functions/#i","title":"i","text":"<ul> <li>initialize_bss_section (hal::cortex_m)</li> <li>initialize_data_section (hal::cortex_m)</li> <li>initialize_floating_point_unit (hal::cortex_m)</li> <li>i2c (hal::micromod::v1)</li> <li>i2c1 (hal::micromod::v1)</li> <li>i2c_interrupt_pin (hal::micromod::v1)</li> <li>initialize_platform (hal::micromod::v1)</li> <li>input_g0 (hal::micromod::v1)</li> <li>input_g1 (hal::micromod::v1)</li> <li>input_g10 (hal::micromod::v1)</li> <li>input_g2 (hal::micromod::v1)</li> <li>input_g3 (hal::micromod::v1)</li> <li>input_g4 (hal::micromod::v1)</li> <li>input_g5 (hal::micromod::v1)</li> <li>input_g6 (hal::micromod::v1)</li> <li>input_g7 (hal::micromod::v1)</li> <li>input_g8 (hal::micromod::v1)</li> <li>input_g9 (hal::micromod::v1)</li> <li>interrupt_g0 (hal::micromod::v1)</li> <li>interrupt_g1 (hal::micromod::v1)</li> <li>interrupt_g10 (hal::micromod::v1)</li> <li>interrupt_g2 (hal::micromod::v1)</li> <li>interrupt_g3 (hal::micromod::v1)</li> <li>interrupt_g4 (hal::micromod::v1)</li> <li>interrupt_g5 (hal::micromod::v1)</li> <li>interrupt_g6 (hal::micromod::v1)</li> <li>interrupt_g7 (hal::micromod::v1)</li> <li>interrupt_g8 (hal::micromod::v1)</li> <li>interrupt_g9 (hal::micromod::v1)</li> <li>in_progress (hal)</li> <li>is_valid (hal)</li> </ul>"},{"location":"api/namespace_member_functions/#l","title":"l","text":"<ul> <li>led (hal::micromod::v1)</li> </ul>"},{"location":"api/namespace_member_functions/#m","title":"m","text":"<ul> <li>make_motor (hal::rmd)</li> <li>make_rotation_sensor (hal::rmd)</li> <li>make_servo (hal::rmd)</li> <li>make_temperature_sensor (hal::rmd)</li> <li>make_adc (hal::soft)</li> <li>map (hal)</li> <li>multiply (hal)</li> </ul>"},{"location":"api/namespace_member_functions/#n","title":"n","text":"<ul> <li>never_timeout (hal)</li> <li>new_error (hal)</li> </ul>"},{"location":"api/namespace_member_functions/#o","title":"o","text":"<ul> <li>operator\"\"_A (hal::literals)</li> <li>operator\"\"_C (hal::literals)</li> <li>operator\"\"_F (hal::literals)</li> <li>operator\"\"_GHz (hal::literals)</li> <li>operator\"\"_Hz (hal::literals)</li> <li>operator\"\"_K (hal::literals)</li> <li>operator\"\"_MHz (hal::literals)</li> <li>operator\"\"_V (hal::literals)</li> <li>operator\"\"_deg (hal::literals)</li> <li>operator\"\"_deg_per_sec (hal::literals)</li> <li>operator\"\"_g (hal::literals)</li> <li>operator\"\"_inch (hal::literals)</li> <li>operator\"\"_kA (hal::literals)</li> <li>operator\"\"_kHz (hal::literals)</li> <li>operator\"\"_kV (hal::literals)</li> <li>operator\"\"_km (hal::literals)</li> <li>operator\"\"_m (hal::literals)</li> <li>operator\"\"_mA (hal::literals)</li> <li>operator\"\"_mV (hal::literals)</li> <li>operator\"\"_miles (hal::literals)</li> <li>operator\"\"_mm (hal::literals)</li> <li>operator\"\"_rpm (hal::literals)</li> <li>operator\"\"_uA (hal::literals)</li> <li>operator\"\"_uV (hal::literals)</li> <li>operator\"\"_um (hal::literals)</li> <li>operator\"\"_yards (hal::literals)</li> <li>output_g0 (hal::micromod::v1)</li> <li>output_g1 (hal::micromod::v1)</li> <li>output_g10 (hal::micromod::v1)</li> <li>output_g2 (hal::micromod::v1)</li> <li>output_g3 (hal::micromod::v1)</li> <li>output_g4 (hal::micromod::v1)</li> <li>output_g5 (hal::micromod::v1)</li> <li>output_g6 (hal::micromod::v1)</li> <li>output_g7 (hal::micromod::v1)</li> <li>output_g8 (hal::micromod::v1)</li> <li>output_g9 (hal::micromod::v1)</li> <li>operator&lt;&lt; (hal)</li> <li>operator== (hal)</li> </ul>"},{"location":"api/namespace_member_functions/#p","title":"p","text":"<ul> <li>pwm0 (hal::micromod::v1)</li> <li>pwm1 (hal::micromod::v1)</li> <li>print (hal)</li> <li>probe (hal)</li> </ul>"},{"location":"api/namespace_member_functions/#r","title":"r","text":"<ul> <li>reset (hal::cortex_m, hal::micromod::v1)</li> <li>release_jtag_pins (hal::stm32f1)</li> <li>read (hal)</li> <li>rounding_division (hal)</li> </ul>"},{"location":"api/namespace_member_functions/#s","title":"s","text":"<ul> <li>set_interrupt_vector_table_address (hal::cortex_m)</li> <li>spi (hal::micromod::v1)</li> <li>spi1 (hal::micromod::v1)</li> <li>spi_interrupt_pin (hal::micromod::v1)</li> <li>system_timer (hal::micromod::v1)</li> <li>success (hal)</li> </ul>"},{"location":"api/namespace_member_functions/#t","title":"t","text":"<ul> <li>terminated (hal)</li> <li>timeout_generator (hal)</li> <li>to_8_bit_address (hal)</li> <li>to_array (hal)</li> <li>to_string (hal)</li> <li>try_until (hal)</li> </ul>"},{"location":"api/namespace_member_functions/#u","title":"u","text":"<ul> <li>uart1 (hal::micromod::v1)</li> <li>uart2 (hal::micromod::v1)</li> <li>uptime_clock (hal::micromod::v1)</li> </ul>"},{"location":"api/namespace_member_functions/#v","title":"v","text":"<ul> <li>value (hal)</li> </ul>"},{"location":"api/namespace_member_functions/#w","title":"w","text":"<ul> <li>wait_for_event (hal::cortex_m)</li> <li>wait_for_interrupt (hal::cortex_m)</li> <li>wavelength (hal)</li> <li>write (hal)</li> <li>write_partial (hal)</li> <li>write_then_read (hal)</li> </ul>"},{"location":"api/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"api/namespace_member_variables/#a","title":"a","text":"<ul> <li>ahb_bus (hal::stm32f1)</li> <li>apb1_bus (hal::stm32f1)</li> <li>apb2_bus (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_member_variables/#b","title":"b","text":"<ul> <li>byte_m (hal)</li> <li>beyond_bus (hal::stm32f1)</li> <li>bus_id_offset (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_member_variables/#c","title":"c","text":"<ul> <li>convertible_to_bytes (hal)</li> </ul>"},{"location":"api/namespace_member_variables/#e","title":"e","text":"<ul> <li>enumeration (hal)</li> </ul>"},{"location":"api/namespace_member_variables/#f","title":"f","text":"<ul> <li>flash_clock (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_member_variables/#h","title":"h","text":"<ul> <li>has_work_state (hal)</li> </ul>"},{"location":"api/namespace_member_variables/#i","title":"i","text":"<ul> <li>invalid_option (hal::error)</li> <li>internal_high_speed_oscillator (hal::stm32f1)</li> <li>internal_low_speed_oscillator (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_member_variables/#n","title":"n","text":"<ul> <li>nibble_m (hal)</li> </ul>"},{"location":"api/namespace_member_variables/#o","title":"o","text":"<ul> <li>on_error_callback (hal)</li> </ul>"},{"location":"api/namespace_member_variables/#t","title":"t","text":"<ul> <li>timeout (hal)</li> </ul>"},{"location":"api/namespace_member_variables/#w","title":"w","text":"<ul> <li>watchdog_clock_rate (hal::stm32f1)</li> <li>worker (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"api/namespace_member_typedefs/#a","title":"a","text":"<ul> <li>ampere (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#b","title":"b","text":"<ul> <li>byte (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#c","title":"c","text":"<ul> <li>callback (hal)</li> <li>celsius (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#d","title":"d","text":"<ul> <li>degrees (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#e","title":"e","text":"<ul> <li>error_handler (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#f","title":"f","text":"<ul> <li>function_ref (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#g","title":"g","text":"<ul> <li>g_force (hal)</li> <li>gauss (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#h","title":"h","text":"<ul> <li>hertz (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#i","title":"i","text":"<ul> <li>interrupt_pointer (hal::cortex_m)</li> <li>inplace_function (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#m","title":"m","text":"<ul> <li>match (hal)</li> <li>meters (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#r","title":"r","text":"<ul> <li>result (hal)</li> <li>rpm (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>status (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#t","title":"t","text":"<ul> <li>time_duration (hal)</li> <li>timeout_function (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#v","title":"v","text":"<ul> <li>volts (hal)</li> </ul>"},{"location":"api/namespace_member_typedefs/#w","title":"w","text":"<ul> <li>work_function (hal)</li> </ul>"},{"location":"api/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"api/namespace_member_enums/#a","title":"a","text":"<ul> <li>adc_divider (hal::stm32f1)</li> <li>ahb_divider (hal::stm32f1)</li> <li>apb_divider (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_member_enums/#e","title":"e","text":"<ul> <li>error_t (hal::lpc40, hal::stm32f1)</li> </ul>"},{"location":"api/namespace_member_enums/#i","title":"i","text":"<ul> <li>irq (hal::cortex_m, hal::lpc40, hal::stm32f1)</li> <li>i2c_operation (hal)</li> </ul>"},{"location":"api/namespace_member_enums/#p","title":"p","text":"<ul> <li>peripheral (hal::lpc40, hal::stm32f1)</li> <li>pll_multiply (hal::stm32f1)</li> <li>pll_source (hal::stm32f1)</li> <li>pin_resistor (hal)</li> </ul>"},{"location":"api/namespace_member_enums/#r","title":"r","text":"<ul> <li>rtc_source (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_member_enums/#s","title":"s","text":"<ul> <li>system_clock_select (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_member_enums/#u","title":"u","text":"<ul> <li>usb_divider (hal::stm32f1)</li> </ul>"},{"location":"api/namespace_member_enums/#w","title":"w","text":"<ul> <li>work_state (hal)</li> </ul>"},{"location":"api/functions/","title":"Functions","text":""},{"location":"api/functions/#o","title":"o","text":"<ul> <li>operator&lt;&lt; (can.hpp, testing.hpp)</li> <li>operator!= (comparison.hpp)</li> <li>operator== (comparison.hpp)</li> </ul>"},{"location":"api/macros/","title":"Macros","text":""},{"location":"api/macros/#h","title":"h","text":"<ul> <li>HAL_CHECK (error.hpp)</li> </ul>"},{"location":"api/variables/","title":"Variables","text":""},{"location":"api/variables/#_","title":"_","text":"<ul> <li>__bss_size (startup.hpp)</li> <li>__bss_start (startup.hpp)</li> <li>__data_size (startup.hpp)</li> <li>__data_source (startup.hpp)</li> <li>__data_start (startup.hpp)</li> </ul>"},{"location":"api/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}