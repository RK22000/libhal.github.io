<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classhal_1_1pwm" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>hal::pwm</compoundname>
    <derivedcompoundref refid="classhal_1_1inert__pwm" prot="public" virt="non-virtual">hal::inert_pwm</derivedcompoundref>
    <derivedcompoundref refid="classhal_1_1lpc40_1_1pwm" prot="public" virt="non-virtual">hal::lpc40::pwm</derivedcompoundref>
    <derivedcompoundref refid="structhal_1_1mock_1_1pwm" prot="public" virt="non-virtual">hal::mock::pwm</derivedcompoundref>
    <includes refid="libhal_2pwm_8hpp" local="no">pwm.hpp</includes>
    <innerclass refid="structhal_1_1pwm_1_1duty__cycle__t" prot="public">hal::pwm::duty_cycle_t</innerclass>
    <innerclass refid="structhal_1_1pwm_1_1frequency__t" prot="public">hal::pwm::frequency_t</innerclass>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classhal_1_1pwm_1abf91bdc19f35d0a6f3448d972b5daead" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>result&lt; <ref refid="structhal_1_1pwm_1_1frequency__t" kindref="compound">frequency_t</ref> &gt;</type>
        <definition>result&lt;frequency_t&gt; hal::pwm::frequency</definition>
        <argsstring>(hertz p_frequency)</argsstring>
        <name>frequency</name>
        <param>
          <type><ref refid="namespacehal_1a54dc271deb8f266e52926836c0582598" kindref="member">hertz</ref></type>
          <declname>p_frequency</declname>
        </param>
        <briefdescription>
<para>Set the pwm waveform frequency. </para>
        </briefdescription>
        <detaileddescription>
<para>This function clamps the input value between 1.0_Hz and 1.0_GHz and thus values passed to driver implementations are guaranteed to be within this range. Callers of this function do not need to clamp their values before passing them into this function as it would be redundant. The rationale for doing this at the interface layer is that it allows callers and driver implementors to omit redundant clamping code, reducing code bloat.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p_frequency</parametername>
</parameternamelist>
<parameterdescription>
<para>- settings to apply to pwm driver </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>result&lt;frequency_t&gt; - success or failure </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::errc::argument_out_of_domain</parametername>
</parameternamelist>
<parameterdescription>
<para>- if the frequency is beyond what the pwm generator is capable of achieving. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/pwm.hpp" line="90" column="11" bodyfile="libraries/include/libhal/pwm.hpp" bodystart="90" bodyend="94"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1pwm_1a7a152631e72dc14a16b84d92365802b2" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>result&lt; <ref refid="structhal_1_1pwm_1_1duty__cycle__t" kindref="compound">duty_cycle_t</ref> &gt;</type>
        <definition>result&lt;duty_cycle_t&gt; hal::pwm::duty_cycle</definition>
        <argsstring>(float p_duty_cycle)</argsstring>
        <name>duty_cycle</name>
        <param>
          <type>float</type>
          <declname>p_duty_cycle</declname>
        </param>
        <briefdescription>
<para>Set the pwm waveform duty cycle. </para>
        </briefdescription>
        <detaileddescription>
<para>The input value <computeroutput>p_duty_cycle</computeroutput> is a 32-bit floating point value from 0.0f to 1.0f.</para>
<para>The floating point value is directly proportional to the duty cycle percentage, such that 0.0f is 0%, 0.25f is 25%, 0.445f is 44.5% and 1.0f is 100%.</para>
<para>This function clamps the input value between 0.0f and 1.0f and thus values passed to driver implementations are guaranteed to be within this range. Callers of this function do not need to clamp their values before passing them into this function as it would be redundant. The rationale for doing this at the interface layer is that it allows callers and driver implementors to omit redundant clamping code, reducing code bloat.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p_duty_cycle</parametername>
</parameternamelist>
<parameterdescription>
<para>- a value from 0.0f to +1.0f representing the duty cycle percentage. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>result&lt;duty_cycle_t&gt; - success or failure </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/pwm.hpp" line="117" column="11" bodyfile="libraries/include/libhal/pwm.hpp" bodystart="117" bodyend="121"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1pwm_1a1c1b39503fa5cbcc778dad9172849251" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>virtual hal::pwm::~pwm</definition>
        <argsstring>()=default</argsstring>
        <name>~pwm</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/pwm.hpp" line="123" column="11"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classhal_1_1pwm_1a6fbb20322e8267585cc063f5789fc98e" prot="private" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>result&lt; <ref refid="structhal_1_1pwm_1_1frequency__t" kindref="compound">frequency_t</ref> &gt;</type>
        <definition>virtual result&lt;frequency_t&gt; hal::pwm::driver_frequency</definition>
        <argsstring>(hertz p_frequency)=0</argsstring>
        <name>driver_frequency</name>
        <reimplementedby refid="classhal_1_1lpc40_1_1pwm_1a046a68149ebc26db4da2eb3c0228d42e">driver_frequency</reimplementedby>
        <reimplementedby refid="structhal_1_1mock_1_1pwm_1aa370b8b3a875a5ef2453053362df9f8a">driver_frequency</reimplementedby>
        <param>
          <type><ref refid="namespacehal_1a54dc271deb8f266e52926836c0582598" kindref="member">hertz</ref></type>
          <declname>p_frequency</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/pwm.hpp" line="126" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1pwm_1a455f4ab4b250f7e77ccdab2d046be4d4" prot="private" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>result&lt; <ref refid="structhal_1_1pwm_1_1duty__cycle__t" kindref="compound">duty_cycle_t</ref> &gt;</type>
        <definition>virtual result&lt;duty_cycle_t&gt; hal::pwm::driver_duty_cycle</definition>
        <argsstring>(float p_duty_cycle)=0</argsstring>
        <name>driver_duty_cycle</name>
        <reimplementedby refid="classhal_1_1lpc40_1_1pwm_1ab03e19501e33fa5c93153de1e1b1d67c">driver_duty_cycle</reimplementedby>
        <reimplementedby refid="structhal_1_1mock_1_1pwm_1a00aa4031f59b6dd4148d25c4f64a5727">driver_duty_cycle</reimplementedby>
        <param>
          <type>float</type>
          <declname>p_duty_cycle</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/pwm.hpp" line="127" column="18"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Pulse Width Modulation (PWM) channel hardware abstraction. </para>
    </briefdescription>
    <detaileddescription>
<para>This driver controls the waveform generation of a square wave and its properties such as frequency and duty cycle.</para>
<para>Frequency, meaning how often the waveform cycles from from low to high.</para>
<para>Duty cycle, what proportion of the wavelength of the pulse is the voltage HIGH.</para>
<para><programlisting><codeline><highlight class="normal"><sp/><sp/>____________________<sp/><sp/><sp/><sp/><sp/><sp/><sp/>_</highlight></codeline>
<codeline><highlight class="normal"><sp/>|<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|<sp/><sp/><sp/><sp/><sp/>|</highlight></codeline>
<codeline><highlight class="normal">_|<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>|_____|</highlight></codeline>
<codeline><highlight class="normal"><sp/>^<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>^<sp/><sp/><sp/><sp/><sp/>^</highlight></codeline>
<codeline><highlight class="normal"><sp/>|&lt;------<sp/>high<sp/>------&gt;|&lt;low&gt;|</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>HIGH<sp/>Duration<sp/>=<sp/>18<sp/>segments</highlight></codeline>
<codeline><highlight class="normal"><sp/>LOW<sp/>Duration<sp/>=<sp/><sp/>5<sp/>segments</highlight></codeline>
<codeline><highlight class="normal"><sp/>Duty<sp/>Cycle<sp/>=<sp/>20<sp/>/<sp/>(20<sp/>+<sp/>5)<sp/>=<sp/>80%</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/>If<sp/>each<sp/>segment<sp/>is<sp/>1us<sp/>then<sp/>the<sp/>wavelength<sp/>is<sp/>25us</highlight></codeline>
<codeline><highlight class="normal"><sp/>Thus<sp/>frequency<sp/>is<sp/>(1<sp/>/<sp/>25us)<sp/>=<sp/>40kHz</highlight></codeline>
</programlisting></para>
<para>PWM is used for power control like motor control, lighting, transmitting signals to servos, sending telemetry and much more. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>hal::pwm</label>
        <link refid="classhal_1_1pwm"/>
      </node>
      <node id="3">
        <label>hal::lpc40::pwm</label>
        <link refid="classhal_1_1lpc40_1_1pwm"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="4">
        <label>hal::mock::pwm</label>
        <link refid="structhal_1_1mock_1_1pwm"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>hal::inert_pwm</label>
        <link refid="classhal_1_1inert__pwm"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <location file="libraries/include/libhal/pwm.hpp" line="54" column="1" bodyfile="libraries/include/libhal/pwm.hpp" bodystart="55" bodyend="128"/>
    <listofallmembers>
      <member refid="classhal_1_1pwm_1a455f4ab4b250f7e77ccdab2d046be4d4" prot="private" virt="pure-virtual"><scope>hal::pwm</scope><name>driver_duty_cycle</name></member>
      <member refid="classhal_1_1pwm_1a6fbb20322e8267585cc063f5789fc98e" prot="private" virt="pure-virtual"><scope>hal::pwm</scope><name>driver_frequency</name></member>
      <member refid="classhal_1_1pwm_1a7a152631e72dc14a16b84d92365802b2" prot="public" virt="non-virtual"><scope>hal::pwm</scope><name>duty_cycle</name></member>
      <member refid="classhal_1_1pwm_1abf91bdc19f35d0a6f3448d972b5daead" prot="public" virt="non-virtual"><scope>hal::pwm</scope><name>frequency</name></member>
      <member refid="classhal_1_1pwm_1a1c1b39503fa5cbcc778dad9172849251" prot="public" virt="virtual"><scope>hal::pwm</scope><name>~pwm</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
