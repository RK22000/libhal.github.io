<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classhal_1_1serial" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>hal::serial</compoundname>
    <derivedcompoundref refid="classhal_1_1inert__serial" prot="public" virt="non-virtual">hal::inert_serial</derivedcompoundref>
    <derivedcompoundref refid="classhal_1_1lpc40_1_1uart" prot="public" virt="non-virtual">hal::lpc40::uart</derivedcompoundref>
    <includes refid="libhal_2serial_8hpp" local="no">serial.hpp</includes>
    <innerclass refid="structhal_1_1serial_1_1flush__t" prot="public">hal::serial::flush_t</innerclass>
    <innerclass refid="structhal_1_1serial_1_1read__t" prot="public">hal::serial::read_t</innerclass>
    <innerclass refid="structhal_1_1serial_1_1settings" prot="public">hal::serial::settings</innerclass>
    <innerclass refid="structhal_1_1serial_1_1write__t" prot="public">hal::serial::write_t</innerclass>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classhal_1_1serial_1a3110feb98b0a00cc0d085b0ad5cf686f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>status</type>
        <definition>status hal::serial::configure</definition>
        <argsstring>(const settings &amp;p_settings)</argsstring>
        <name>configure</name>
        <param>
          <type>const <ref refid="structhal_1_1serial_1_1settings" kindref="compound">settings</ref> &amp;</type>
          <declname>p_settings</declname>
        </param>
        <briefdescription>
<para>Configure serial to match the settings supplied. </para>
        </briefdescription>
        <detaileddescription>
<para>Implementing drivers must verify if the settings can be applied to hardware before modifying the hardware. This will ensure that if this operation fails, the state of the serial device has not changed.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p_settings</parametername>
</parameternamelist>
<parameterdescription>
<para>- settings to apply to serial driver </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>status - success or failure </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::errc::invalid_argument</parametername>
</parameternamelist>
<parameterdescription>
<para>if the settings could not be achieved </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/serial.hpp" line="188" column="11" bodyfile="libraries/include/libhal/serial.hpp" bodystart="188" bodyend="191"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1serial_1a9a7a63f71b908b9c3cd061c52df55df8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>result&lt; <ref refid="structhal_1_1serial_1_1write__t" kindref="compound">write_t</ref> &gt;</type>
        <definition>result&lt;write_t&gt; hal::serial::write</definition>
        <argsstring>(std::span&lt; const hal::byte &gt; p_data)</argsstring>
        <name>write</name>
        <param>
          <type>std::span&lt; const hal::byte &gt;</type>
          <declname>p_data</declname>
        </param>
        <briefdescription>
<para>Write data to the transmitter line of the serial port. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p_data</parametername>
</parameternamelist>
<parameterdescription>
<para>- data to be transmitted over the serial port </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>result&lt;write_t&gt; - serial write response </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/serial.hpp" line="199" column="11" bodyfile="libraries/include/libhal/serial.hpp" bodystart="199" bodyend="202"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1serial_1a69eaa352ef24788b38d36648a5c3f99f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>result&lt; <ref refid="structhal_1_1serial_1_1read__t" kindref="compound">read_t</ref> &gt;</type>
        <definition>result&lt;read_t&gt; hal::serial::read</definition>
        <argsstring>(std::span&lt; hal::byte &gt; p_data)</argsstring>
        <name>read</name>
        <param>
          <type>std::span&lt; hal::byte &gt;</type>
          <declname>p_data</declname>
        </param>
        <briefdescription>
<para>Copy bytes from working buffer into passed buffer. </para>
        </briefdescription>
        <detaileddescription>
<para>This operation copies the bytes from the serial driver&apos;s internal working buffer to the buffer supplied.</para>
<para>The buffer will be filled up either to the end of the buffer or until there are no more bytes left in the working buffer. The remaining portion of the input buffer is returned in <computeroutput>read_t::remaining</computeroutput>.</para>
<para>If a frame error has occurred at any point during serial reception, this function will throw a <computeroutput>std::errc::io_error</computeroutput> value. The contents of the internal working buffer will stay the same. No information from the internal working buffer will be copied into the supplied buffer and no data will be removed from the internal working buffer. The frame error status will be internally cleared after its occurrence. Subsequent calls of this function will read out the contents of the buffer although the data inside may be corrupt.</para>
<para>When an error occurs the options available are to flush the buffer and attempt reception again or read out the potentially corrupted data and parse it as needed. The choice of operation is application/driver specific.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p_data</parametername>
</parameternamelist>
<parameterdescription>
<para>- Buffer to read bytes in to </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>result&lt;read_t&gt; - serial read response data </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::errc::io_error</parametername>
</parameternamelist>
<parameterdescription>
<para>- a frame error occurred at some point during reception. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/serial.hpp" line="232" column="11" bodyfile="libraries/include/libhal/serial.hpp" bodystart="232" bodyend="235"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1serial_1a830bae7d2f8b360f8744213a5a88b166" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>result&lt; <ref refid="structhal_1_1serial_1_1flush__t" kindref="compound">flush_t</ref> &gt;</type>
        <definition>result&lt;flush_t&gt; hal::serial::flush</definition>
        <argsstring>()</argsstring>
        <name>flush</name>
        <briefdescription>
<para>Flush working buffer. </para>
        </briefdescription>
        <detaileddescription>
<para>The behavior of flushing the internal working buffer is this:</para>
<para><itemizedlist>
<listitem><para>Sets the serial port&apos;s internal working buffer to an &quot;empty&quot; state.</para>
</listitem><listitem><para>Clear any received data stored in hardware registers.</para>
</listitem><listitem><para>Use the fastest available option to perform these operations, meaning that the contents of the internal working buffer will not be zeroed out.</para>
</listitem></itemizedlist>
</para>
<para><simplesect kind="return"><para>result&lt;flush_t&gt; - success or failure </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/serial.hpp" line="248" column="11" bodyfile="libraries/include/libhal/serial.hpp" bodystart="248" bodyend="251"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1serial_1ada7d8f7769ca8616f01a0d314bd09a52" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>virtual hal::serial::~serial</definition>
        <argsstring>()=default</argsstring>
        <name>~serial</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/serial.hpp" line="253" column="11"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classhal_1_1serial_1adcd3a309f5609e1cccd0fe1584abfc8a" prot="private" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>status</type>
        <definition>virtual status hal::serial::driver_configure</definition>
        <argsstring>(const settings &amp;p_settings)=0</argsstring>
        <name>driver_configure</name>
        <reimplementedby refid="classhal_1_1lpc40_1_1uart_1a19118fd8c1cd17c435d7567687d207b0">driver_configure</reimplementedby>
        <param>
          <type>const <ref refid="structhal_1_1serial_1_1settings" kindref="compound">settings</ref> &amp;</type>
          <declname>p_settings</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/serial.hpp" line="256" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1serial_1ae71b9dcc27466c0e721aa5f3cd57181c" prot="private" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>result&lt; <ref refid="structhal_1_1serial_1_1write__t" kindref="compound">write_t</ref> &gt;</type>
        <definition>virtual result&lt;write_t&gt; hal::serial::driver_write</definition>
        <argsstring>(std::span&lt; const hal::byte &gt; p_data)=0</argsstring>
        <name>driver_write</name>
        <reimplementedby refid="classhal_1_1lpc40_1_1uart_1acc1da0163d969a9df2146d2b1068932d">driver_write</reimplementedby>
        <param>
          <type>std::span&lt; const hal::byte &gt;</type>
          <declname>p_data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/serial.hpp" line="257" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1serial_1ade66ea1d022c404f42fef07c9eb288b5" prot="private" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>result&lt; <ref refid="structhal_1_1serial_1_1read__t" kindref="compound">read_t</ref> &gt;</type>
        <definition>virtual result&lt;read_t&gt; hal::serial::driver_read</definition>
        <argsstring>(std::span&lt; hal::byte &gt; p_data)=0</argsstring>
        <name>driver_read</name>
        <reimplementedby refid="classhal_1_1lpc40_1_1uart_1a5849d5f838fbe95342a0ca07a4512a3d">driver_read</reimplementedby>
        <param>
          <type>std::span&lt; hal::byte &gt;</type>
          <declname>p_data</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/serial.hpp" line="258" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1serial_1a7f45c777d8f42c05246ad33e9b00251a" prot="private" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>result&lt; <ref refid="structhal_1_1serial_1_1flush__t" kindref="compound">flush_t</ref> &gt;</type>
        <definition>virtual result&lt;flush_t&gt; hal::serial::driver_flush</definition>
        <argsstring>()=0</argsstring>
        <name>driver_flush</name>
        <reimplementedby refid="classhal_1_1inert__serial_1a4781347c1b5e4a2da0b64b56732fabc7">driver_flush</reimplementedby>
        <reimplementedby refid="classhal_1_1lpc40_1_1uart_1a17e27550f052b958818534ba2816829c">driver_flush</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/serial.hpp" line="259" column="18"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Hardware abstract interface for the serial communication protocol. </para>
    </briefdescription>
    <detaileddescription>
<para>Use this interface for hardware that implements a serial protocol like UART, RS232, RS485 and others that use a similar communication protocol but may use different voltage schemes.</para>
<para>This interface only works 8-bit serial data frames.</para>
<para>Due to the asynchronous and unformatted nature of serial communication protocols, all implementations of serial devices must be buffered. Buffered, in this case, is defined as automatic storage of received bytes without direct application intervention.</para>
<para>All implementations MUST allow the user to supply their own buffer of arbitrary size up to the limits of what hardware can support. This allows a developer the ability to tailored the buffer size to the needs of the application.</para>
<para>Examples of buffering schemes are:</para>
<para><itemizedlist>
<listitem><para>Using DMA to copy data from a serial peripheral to a region of memory</para>
</listitem><listitem><para>Using interrupts when a serial peripheral&apos;s queue has filled to a point </para>
</listitem></itemizedlist>
</para>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>hal::inert_serial</label>
        <link refid="classhal_1_1inert__serial"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>hal::lpc40::uart</label>
        <link refid="classhal_1_1lpc40_1_1uart"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>hal::serial</label>
        <link refid="classhal_1_1serial"/>
      </node>
    </inheritancegraph>
    <location file="libraries/include/libhal/serial.hpp" line="51" column="1" bodyfile="libraries/include/libhal/serial.hpp" bodystart="52" bodyend="260"/>
    <listofallmembers>
      <member refid="classhal_1_1serial_1a3110feb98b0a00cc0d085b0ad5cf686f" prot="public" virt="non-virtual"><scope>hal::serial</scope><name>configure</name></member>
      <member refid="classhal_1_1serial_1adcd3a309f5609e1cccd0fe1584abfc8a" prot="private" virt="pure-virtual"><scope>hal::serial</scope><name>driver_configure</name></member>
      <member refid="classhal_1_1serial_1a7f45c777d8f42c05246ad33e9b00251a" prot="private" virt="pure-virtual"><scope>hal::serial</scope><name>driver_flush</name></member>
      <member refid="classhal_1_1serial_1ade66ea1d022c404f42fef07c9eb288b5" prot="private" virt="pure-virtual"><scope>hal::serial</scope><name>driver_read</name></member>
      <member refid="classhal_1_1serial_1ae71b9dcc27466c0e721aa5f3cd57181c" prot="private" virt="pure-virtual"><scope>hal::serial</scope><name>driver_write</name></member>
      <member refid="classhal_1_1serial_1a830bae7d2f8b360f8744213a5a88b166" prot="public" virt="non-virtual"><scope>hal::serial</scope><name>flush</name></member>
      <member refid="classhal_1_1serial_1a69eaa352ef24788b38d36648a5c3f99f" prot="public" virt="non-virtual"><scope>hal::serial</scope><name>read</name></member>
      <member refid="classhal_1_1serial_1a9a7a63f71b908b9c3cd061c52df55df8" prot="public" virt="non-virtual"><scope>hal::serial</scope><name>write</name></member>
      <member refid="classhal_1_1serial_1ada7d8f7769ca8616f01a0d314bd09a52" prot="public" virt="virtual"><scope>hal::serial</scope><name>~serial</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
