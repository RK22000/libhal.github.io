<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classhal_1_1can" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>hal::can</compoundname>
    <derivedcompoundref refid="classhal_1_1lpc40_1_1can" prot="public" virt="non-virtual">hal::lpc40::can</derivedcompoundref>
    <derivedcompoundref refid="structhal_1_1mock_1_1can" prot="public" virt="non-virtual">hal::mock::can</derivedcompoundref>
    <includes refid="libhal_2can_8hpp" local="no">can.hpp</includes>
    <innerclass refid="structhal_1_1can_1_1message__t" prot="public">hal::can::message_t</innerclass>
    <innerclass refid="structhal_1_1can_1_1send__t" prot="public">hal::can::send_t</innerclass>
    <innerclass refid="structhal_1_1can_1_1settings" prot="public">hal::can::settings</innerclass>
      <sectiondef kind="public-type">
      <memberdef kind="typedef" id="classhal_1_1can_1ae85571b4f7aac93fca8503aafcb32a47" prot="public" static="no">
        <type>uint32_t</type>
        <definition>using hal::can::id_t =  uint32_t</definition>
        <argsstring></argsstring>
        <name>id_t</name>
        <briefdescription>
<para>Can message ID type trait. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/can.hpp" line="36" column="3" bodyfile="libraries/include/libhal/can.hpp" bodystart="36" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classhal_1_1can_1aad5d17f59a3a8f3bddded97760737163" prot="public" static="no">
        <type>void(const <ref refid="structhal_1_1can_1_1message__t" kindref="compound">message_t</ref> &amp;p_message)</type>
        <definition>using hal::can::handler =  void(const message_t&amp; p_message)</definition>
        <argsstring></argsstring>
        <name>handler</name>
        <briefdescription>
<para>Receive handler for can messages. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/can.hpp" line="137" column="3" bodyfile="libraries/include/libhal/can.hpp" bodystart="137" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classhal_1_1can_1a3689f792846d977e93c69dd6c42b9ff9" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>status</type>
        <definition>status hal::can::configure</definition>
        <argsstring>(const settings &amp;p_settings)</argsstring>
        <name>configure</name>
        <param>
          <type>const <ref refid="structhal_1_1can_1_1settings" kindref="compound">settings</ref> &amp;</type>
          <declname>p_settings</declname>
        </param>
        <briefdescription>
<para>Configure this can bus port to match the settings supplied. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p_settings</parametername>
</parameternamelist>
<parameterdescription>
<para>- settings to apply to can driver </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>status - success or failure </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::errc::invalid_argument</parametername>
</parameternamelist>
<parameterdescription>
<para>if the settings could not be achieved. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/can.hpp" line="155" column="11" bodyfile="libraries/include/libhal/can.hpp" bodystart="155" bodyend="158"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1can_1afcf2dd59770197b320a22660e0f79fab" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>status</type>
        <definition>status hal::can::bus_on</definition>
        <argsstring>()</argsstring>
        <name>bus_on</name>
        <briefdescription>
<para>Transition the CAN device from &quot;bus-off&quot; to &quot;bus-on&quot;. </para>
        </briefdescription>
        <detaileddescription>
<para>WARNING: Calling this function when the device is already in &quot;bus-on&quot; will have no effect. This function is not necessary to call after creating the CAN driver as the driver should already be &quot;bus-on&quot; on creation.</para>
<para>Can devices have two counters to determine system health. These two counters are the &quot;transmit error counter&quot; and the &quot;receive error counter&quot;. Transmission errors can occur when the device attempts to communicate on the bus and either does not get an acknowledge or sees an unexpected or erroneous signal on the bus during its own transmission. When transmission errors reach 255 counts, the device will go into the &quot;bus-off&quot; state.</para>
<para>In the &quot;bus-off&quot; state, the CAN peripheral can no longer communicate on the bus. Any calls to <computeroutput><ref refid="classhal_1_1can_1aef573e4697999cd24dcc9074a6f85bec" kindref="member">send()</ref></computeroutput> will throw the error <computeroutput>std::errc::network_down</computeroutput>. If this occurs, this function must be called to re-enable bus communication.</para>
<para><simplesect kind="return"><para>status - success or failure. In the case this function fails repeatedly, it is advised to simply not use the bus anymore as something is critical wrong and may not be recoverable. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/can.hpp" line="183" column="11" bodyfile="libraries/include/libhal/can.hpp" bodystart="183" bodyend="186"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1can_1aef573e4697999cd24dcc9074a6f85bec" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>result&lt; <ref refid="structhal_1_1can_1_1send__t" kindref="compound">send_t</ref> &gt;</type>
        <definition>result&lt;send_t&gt; hal::can::send</definition>
        <argsstring>(const message_t &amp;p_message)</argsstring>
        <name>send</name>
        <param>
          <type>const <ref refid="structhal_1_1can_1_1message__t" kindref="compound">message_t</ref> &amp;</type>
          <declname>p_message</declname>
        </param>
        <briefdescription>
<para>Send a can message. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p_message</parametername>
</parameternamelist>
<parameterdescription>
<para>- the message to be sent </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>result&lt;send_t&gt; - success or failure </para>
</simplesect>
<parameterlist kind="exception"><parameteritem>
<parameternamelist>
<parametername>std::errc::network_down</parametername>
</parameternamelist>
<parameterdescription>
<para>- if the can device is in the &quot;bus-off&quot; state. This can happen if a critical fault in the bus has occurred. A call to <computeroutput><ref refid="classhal_1_1can_1afcf2dd59770197b320a22660e0f79fab" kindref="member">bus_on()</ref></computeroutput> will need to be issued to attempt to talk on the bus again. See <computeroutput><ref refid="classhal_1_1can_1afcf2dd59770197b320a22660e0f79fab" kindref="member">bus_on()</ref></computeroutput> for more details. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/can.hpp" line="198" column="11" bodyfile="libraries/include/libhal/can.hpp" bodystart="198" bodyend="201"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1can_1a8d428d2300fa5994e1acf3c3a467490c" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void hal::can::on_receive</definition>
        <argsstring>(hal::callback&lt; handler &gt; p_handler)</argsstring>
        <name>on_receive</name>
        <param>
          <type><ref refid="namespacehal_1a6051b44bfb2759cbcdba16019f3f1550" kindref="member">hal::callback</ref>&lt; <ref refid="classhal_1_1can_1aad5d17f59a3a8f3bddded97760737163" kindref="member">handler</ref> &gt;</type>
          <declname>p_handler</declname>
        </param>
        <briefdescription>
<para>Set the message reception handler. </para>
        </briefdescription>
        <detaileddescription>
<para>All messages received before a message handler is installed are dropped.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>p_handler</parametername>
</parameternamelist>
<parameterdescription>
<para>- this handler will be called when a message has been received. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/can.hpp" line="211" column="8" bodyfile="libraries/include/libhal/can.hpp" bodystart="211" bodyend="214"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1can_1a88c989bfc09af537f1177089eb8adbd8" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>virtual hal::can::~can</definition>
        <argsstring>()=default</argsstring>
        <name>~can</name>
        <reimplementedby refid="classhal_1_1lpc40_1_1can_1a735f1d91403040e5fe3d46729c206c8c">~can</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/can.hpp" line="216" column="11"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classhal_1_1can_1a74f1bb2345d78a9d9e32dbb08ea9f728" prot="private" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>status</type>
        <definition>virtual status hal::can::driver_configure</definition>
        <argsstring>(const settings &amp;p_settings)=0</argsstring>
        <name>driver_configure</name>
        <reimplementedby refid="classhal_1_1lpc40_1_1can_1a72040b318fa4e4d4c82a4a571b55ba95">driver_configure</reimplementedby>
        <reimplementedby refid="structhal_1_1mock_1_1can_1aa12791161fa697f57fe4e678af563dd3">driver_configure</reimplementedby>
        <param>
          <type>const <ref refid="structhal_1_1can_1_1settings" kindref="compound">settings</ref> &amp;</type>
          <declname>p_settings</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/can.hpp" line="219" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1can_1af3aacb89fa1d81eb2db4baa09936c5e1" prot="private" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>status</type>
        <definition>virtual status hal::can::driver_bus_on</definition>
        <argsstring>()=0</argsstring>
        <name>driver_bus_on</name>
        <reimplementedby refid="classhal_1_1lpc40_1_1can_1abf0e8ed97f3e9596d371682223b72ddd">driver_bus_on</reimplementedby>
        <reimplementedby refid="structhal_1_1mock_1_1can_1ab80b6f227f18902448e82c5a9896f7ce">driver_bus_on</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/can.hpp" line="220" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1can_1ab006bbc7a0afd7487586a22cd2edce66" prot="private" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>result&lt; <ref refid="structhal_1_1can_1_1send__t" kindref="compound">send_t</ref> &gt;</type>
        <definition>virtual result&lt;send_t&gt; hal::can::driver_send</definition>
        <argsstring>(const message_t &amp;p_message)=0</argsstring>
        <name>driver_send</name>
        <reimplementedby refid="classhal_1_1lpc40_1_1can_1a8a8e7787591c07e500d0c77afe97e1d5">driver_send</reimplementedby>
        <reimplementedby refid="structhal_1_1mock_1_1can_1a90237b1ecd453f33665d9e719375548c">driver_send</reimplementedby>
        <param>
          <type>const <ref refid="structhal_1_1can_1_1message__t" kindref="compound">message_t</ref> &amp;</type>
          <declname>p_message</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/can.hpp" line="221" column="18"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1can_1a4237e63cabfeccfbc069e54e0d829d56" prot="private" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>void</type>
        <definition>virtual void hal::can::driver_on_receive</definition>
        <argsstring>(hal::callback&lt; handler &gt; p_handler)=0</argsstring>
        <name>driver_on_receive</name>
        <reimplementedby refid="structhal_1_1mock_1_1can_1a738e33edcc02552d7dcbb40b6946bb2c">driver_on_receive</reimplementedby>
        <param>
          <type><ref refid="namespacehal_1a6051b44bfb2759cbcdba16019f3f1550" kindref="member">hal::callback</ref>&lt; <ref refid="classhal_1_1can_1aad5d17f59a3a8f3bddded97760737163" kindref="member">handler</ref> &gt;</type>
          <declname>p_handler</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/can.hpp" line="222" column="16"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Controller Area Network (CAN bus) hardware abstraction interface. </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <inheritancegraph>
      <node id="3">
        <label>hal::mock::can</label>
        <link refid="structhal_1_1mock_1_1can"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="2">
        <label>hal::lpc40::can</label>
        <link refid="classhal_1_1lpc40_1_1can"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>hal::can</label>
        <link refid="classhal_1_1can"/>
      </node>
    </inheritancegraph>
    <location file="libraries/include/libhal/can.hpp" line="29" column="1" bodyfile="libraries/include/libhal/can.hpp" bodystart="30" bodyend="223"/>
    <listofallmembers>
      <member refid="classhal_1_1can_1afcf2dd59770197b320a22660e0f79fab" prot="public" virt="non-virtual"><scope>hal::can</scope><name>bus_on</name></member>
      <member refid="classhal_1_1can_1a3689f792846d977e93c69dd6c42b9ff9" prot="public" virt="non-virtual"><scope>hal::can</scope><name>configure</name></member>
      <member refid="classhal_1_1can_1af3aacb89fa1d81eb2db4baa09936c5e1" prot="private" virt="pure-virtual"><scope>hal::can</scope><name>driver_bus_on</name></member>
      <member refid="classhal_1_1can_1a74f1bb2345d78a9d9e32dbb08ea9f728" prot="private" virt="pure-virtual"><scope>hal::can</scope><name>driver_configure</name></member>
      <member refid="classhal_1_1can_1a4237e63cabfeccfbc069e54e0d829d56" prot="private" virt="pure-virtual"><scope>hal::can</scope><name>driver_on_receive</name></member>
      <member refid="classhal_1_1can_1ab006bbc7a0afd7487586a22cd2edce66" prot="private" virt="pure-virtual"><scope>hal::can</scope><name>driver_send</name></member>
      <member refid="classhal_1_1can_1aad5d17f59a3a8f3bddded97760737163" prot="public" virt="non-virtual"><scope>hal::can</scope><name>handler</name></member>
      <member refid="classhal_1_1can_1ae85571b4f7aac93fca8503aafcb32a47" prot="public" virt="non-virtual"><scope>hal::can</scope><name>id_t</name></member>
      <member refid="classhal_1_1can_1a8d428d2300fa5994e1acf3c3a467490c" prot="public" virt="non-virtual"><scope>hal::can</scope><name>on_receive</name></member>
      <member refid="classhal_1_1can_1aef573e4697999cd24dcc9074a6f85bec" prot="public" virt="non-virtual"><scope>hal::can</scope><name>send</name></member>
      <member refid="classhal_1_1can_1a88c989bfc09af537f1177089eb8adbd8" prot="public" virt="virtual"><scope>hal::can</scope><name>~can</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
