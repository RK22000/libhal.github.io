<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="structhal_1_1bitmask" kind="struct" language="C++" prot="public">
    <compoundname>hal::bitmask</compoundname>
      <sectiondef kind="public-attrib">
      <memberdef kind="variable" id="structhal_1_1bitmask_1a4ebf20b63981f10c73d5114b8b8a0c87" prot="public" static="no" mutable="no">
        <type>std::uint32_t</type>
        <definition>std::uint32_t hal::bitmask::position</definition>
        <argsstring></argsstring>
        <name>position</name>
        <briefdescription>
<para>Where the bit mask starts. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal-util/bit.hpp" line="26" column="17" bodyfile="libraries/include/libhal-util/bit.hpp" bodystart="26" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="structhal_1_1bitmask_1a3554666dd31417c0948c29bb89e71e77" prot="public" static="no" mutable="no">
        <type>std::uint32_t</type>
        <definition>std::uint32_t hal::bitmask::width</definition>
        <argsstring></argsstring>
        <name>width</name>
        <briefdescription>
<para>The number of bits after position contained in the mask. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal-util/bit.hpp" line="28" column="17" bodyfile="libraries/include/libhal-util/bit.hpp" bodystart="28" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-static-func">
      <memberdef kind="function" id="structhal_1_1bitmask_1a4f47e08808c3257546b3fc2adbd4d9d3" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::uint32_t</type>
            <declname>position1</declname>
            <defname>position1</defname>
          </param>
          <param>
            <type>std::uint32_t</type>
            <declname>position2</declname>
            <defname>position2</defname>
          </param>
        </templateparamlist>
        <type>consteval <ref refid="structhal_1_1bitmask" kindref="compound">bitmask</ref></type>
        <definition>static consteval bitmask hal::bitmask::from</definition>
        <argsstring>()</argsstring>
        <name>from</name>
        <briefdescription>
<para>Generate, at compile time, a bitmask that spans the from position1 to position2. </para>
        </briefdescription>
        <detaileddescription>
<para>If position1 is the same position2 then the bitmask will have length of 1 and the bit position will be the value of position1.</para>
<para>position1 and position2 can be in any order so long as they span the distance from the start and end of the bitmask range.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>position1</parametername>
</parameternamelist>
<parameterdescription>
<para>- bit position 1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>position2</parametername>
</parameternamelist>
<parameterdescription>
<para>- bit position 2 </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>consteval bitmask - bit bitmask represented by the two bit positions </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal-util/bit.hpp" line="46" column="28" bodyfile="libraries/include/libhal-util/bit.hpp" bodystart="46" bodyend="56"/>
      </memberdef>
      <memberdef kind="function" id="structhal_1_1bitmask_1aaf57c05fca6a62141b3c85587893b38f" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::uint32_t</type>
            <declname>position</declname>
            <defname>position</defname>
          </param>
        </templateparamlist>
        <type>constexpr <ref refid="structhal_1_1bitmask" kindref="compound">bitmask</ref></type>
        <definition>static constexpr bitmask hal::bitmask::from</definition>
        <argsstring>()</argsstring>
        <name>from</name>
        <briefdescription>
<para>Generate, at compile time, a single bit width bitmask at position. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>position</parametername>
</parameternamelist>
<parameterdescription>
<para>- the bit to make the bitmask for </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>constexpr bitmask - bit bitmask with the position bit set to position </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal-util/bit.hpp" line="66" column="28" bodyfile="libraries/include/libhal-util/bit.hpp" bodystart="66" bodyend="69"/>
      </memberdef>
      <memberdef kind="function" id="structhal_1_1bitmask_1aaee0c47aa5bc56d9d6f928f17e9781f7" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>consteval <ref refid="structhal_1_1bitmask" kindref="compound">bitmask</ref></type>
        <definition>static consteval bitmask hal::bitmask::from</definition>
        <argsstring>(std::uint32_t position1, std::uint32_t position2)</argsstring>
        <name>from</name>
        <param>
          <type>std::uint32_t</type>
          <declname>position1</declname>
        </param>
        <param>
          <type>std::uint32_t</type>
          <declname>position2</declname>
        </param>
        <briefdescription>
<para>Generate, at compile time, a bitmask that spans the from position1 to position2. </para>
        </briefdescription>
        <detaileddescription>
<para>If position1 is the same position2 then the bitmask will have length of 1 and the bit position will be the value of position1.</para>
<para>position1 and position2 can be in any order so long as they span the distance from the start and end of the bitmask range.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>position1</parametername>
</parameternamelist>
<parameterdescription>
<para>- bit position 1 </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>position2</parametername>
</parameternamelist>
<parameterdescription>
<para>- bit position 2 </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>consteval bitmask - bit bitmask represented by the two bit positions </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal-util/bit.hpp" line="86" column="28" bodyfile="libraries/include/libhal-util/bit.hpp" bodystart="86" bodyend="97"/>
      </memberdef>
      <memberdef kind="function" id="structhal_1_1bitmask_1a8bcc3d13d396637b20eb84665e2f0dfd" prot="public" static="yes" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>constexpr <ref refid="structhal_1_1bitmask" kindref="compound">bitmask</ref></type>
        <definition>static constexpr bitmask hal::bitmask::from</definition>
        <argsstring>(std::uint32_t position)</argsstring>
        <name>from</name>
        <param>
          <type>std::uint32_t</type>
          <declname>position</declname>
        </param>
        <briefdescription>
<para>Generate, at runtime, a single bit width bitmask at position. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>position</parametername>
</parameternamelist>
<parameterdescription>
<para>- the bit to make the bitmask for </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>constexpr bitmask - bit bitmask with the position bit set to position </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal-util/bit.hpp" line="106" column="28" bodyfile="libraries/include/libhal-util/bit.hpp" bodystart="106" bodyend="109"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="structhal_1_1bitmask_1a31e1ce255ccbb3b326e8a700b31bed8d" prot="public" static="no" constexpr="yes" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::unsigned_integral</type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto hal::bitmask::origin</definition>
        <argsstring>() const</argsstring>
        <name>origin</name>
        <briefdescription>
<para>Convert bitmask to a integral representation but with bit position at 0. </para>
        </briefdescription>
        <detaileddescription>
<para>The integral presentation will have 1 bits starting from the position bit up to bit position + width. All other bits will be 0s.</para>
<para>For example: <verbatim> value&lt;std::uint16_t&gt;(bitmask{
     .position = 1,
     .width = 4,
 }); // returns = 0b0000&apos;0000&apos;0000&apos;1111;
</verbatim> <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>- unsigned integral type to hold the bitmask </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>constexpr auto - bitmask value as an unsigned integer </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal-util/bit.hpp" line="129" column="18" bodyfile="libraries/include/libhal-util/bit.hpp" bodystart="129" bodyend="143"/>
      </memberdef>
      <memberdef kind="function" id="structhal_1_1bitmask_1a1662e822b6d3e24e302cd2129ec539bb" prot="public" static="no" constexpr="yes" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>std::unsigned_integral</type>
            <declname>T</declname>
            <defname>T</defname>
          </param>
        </templateparamlist>
        <type>constexpr auto</type>
        <definition>constexpr auto hal::bitmask::value</definition>
        <argsstring>() const</argsstring>
        <name>value</name>
        <briefdescription>
<para>Convert mask to a integral representation. </para>
        </briefdescription>
        <detaileddescription>
<para>The integral presentation will have 1 bits starting from the position bit up to bit position + width. All other bits will be 0s.</para>
<para>For example: <verbatim> value&lt;std::uint16_t&gt;(bitmask{
     .position = 1,
     .width = 4,
 }); // returns = 0b0000&apos;0000&apos;0001&apos;1110;
</verbatim> <parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>- unsigned integral type to hold the mask </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>constexpr auto - mask value as an unsigned integer </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal-util/bit.hpp" line="162" column="18" bodyfile="libraries/include/libhal-util/bit.hpp" bodystart="162" bodyend="165"/>
      </memberdef>
      <memberdef kind="function" id="structhal_1_1bitmask_1ad9d7428ce56013f312a6a0c8a21f2cbe" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>constexpr bool</type>
        <definition>constexpr bool hal::bitmask::operator==</definition>
        <argsstring>(const bitmask &amp;other)</argsstring>
        <name>operator==</name>
        <param>
          <type>const <ref refid="structhal_1_1bitmask" kindref="compound">bitmask</ref> &amp;</type>
          <declname>other</declname>
        </param>
        <briefdescription>
<para>Comparison operator between this mask and another. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>other</parametername>
</parameternamelist>
<parameterdescription>
<para>- the other mask to compare against </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>true - the masks are the same </para>
</simplesect>
<simplesect kind="return"><para>false - the masks are not the same </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal-util/bit.hpp" line="174" column="18" bodyfile="libraries/include/libhal-util/bit.hpp" bodystart="174" bodyend="177"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="libraries/include/libhal-util/bit.hpp" line="23" column="1" bodyfile="libraries/include/libhal-util/bit.hpp" bodystart="24" bodyend="178"/>
    <listofallmembers>
      <member refid="structhal_1_1bitmask_1a4f47e08808c3257546b3fc2adbd4d9d3" prot="public" virt="non-virtual"><scope>hal::bitmask</scope><name>from</name></member>
      <member refid="structhal_1_1bitmask_1aaf57c05fca6a62141b3c85587893b38f" prot="public" virt="non-virtual"><scope>hal::bitmask</scope><name>from</name></member>
      <member refid="structhal_1_1bitmask_1aaee0c47aa5bc56d9d6f928f17e9781f7" prot="public" virt="non-virtual"><scope>hal::bitmask</scope><name>from</name></member>
      <member refid="structhal_1_1bitmask_1a8bcc3d13d396637b20eb84665e2f0dfd" prot="public" virt="non-virtual"><scope>hal::bitmask</scope><name>from</name></member>
      <member refid="structhal_1_1bitmask_1ad9d7428ce56013f312a6a0c8a21f2cbe" prot="public" virt="non-virtual"><scope>hal::bitmask</scope><name>operator==</name></member>
      <member refid="structhal_1_1bitmask_1a31e1ce255ccbb3b326e8a700b31bed8d" prot="public" virt="non-virtual"><scope>hal::bitmask</scope><name>origin</name></member>
      <member refid="structhal_1_1bitmask_1a4ebf20b63981f10c73d5114b8b8a0c87" prot="public" virt="non-virtual"><scope>hal::bitmask</scope><name>position</name></member>
      <member refid="structhal_1_1bitmask_1a1662e822b6d3e24e302cd2129ec539bb" prot="public" virt="non-virtual"><scope>hal::bitmask</scope><name>value</name></member>
      <member refid="structhal_1_1bitmask_1a3554666dd31417c0948c29bb89e71e77" prot="public" virt="non-virtual"><scope>hal::bitmask</scope><name>width</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
