<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classhal_1_1distance__sensor" kind="class" language="C++" prot="public" abstract="yes">
    <compoundname>hal::distance_sensor</compoundname>
    <derivedcompoundref refid="classhal_1_1inert__distance__sensor" prot="public" virt="non-virtual">hal::inert_distance_sensor</derivedcompoundref>
    <includes refid="distance__sensor_8hpp" local="no">distance_sensor.hpp</includes>
    <innerclass refid="structhal_1_1distance__sensor_1_1read__t" prot="public">hal::distance_sensor::read_t</innerclass>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classhal_1_1distance__sensor_1ac2c8a81474ab7198ab3e7ea51aee4f47" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>result&lt; <ref refid="structhal_1_1distance__sensor_1_1read__t" kindref="compound">read_t</ref> &gt;</type>
        <definition>result&lt;read_t&gt; hal::distance_sensor::read</definition>
        <argsstring>()</argsstring>
        <name>read</name>
        <briefdescription>
<para>Read the current distance measured by the device. </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>result&lt;read_t&gt; - distance data </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/distance_sensor.hpp" line="101" column="11" bodyfile="libraries/include/libhal/distance_sensor.hpp" bodystart="101" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="classhal_1_1distance__sensor_1a6c4a9a417f9eaf6e8a6aa9f487377a39" prot="public" static="no" const="no" explicit="no" inline="no" virt="virtual">
        <type></type>
        <definition>virtual hal::distance_sensor::~distance_sensor</definition>
        <argsstring>()=default</argsstring>
        <name>~distance_sensor</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/distance_sensor.hpp" line="106" column="11"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classhal_1_1distance__sensor_1a3f392e5c9723734218b6ad429550b8ff" prot="private" static="no" const="no" explicit="no" inline="no" virt="pure-virtual">
        <type>result&lt; <ref refid="structhal_1_1distance__sensor_1_1read__t" kindref="compound">read_t</ref> &gt;</type>
        <definition>virtual result&lt;read_t&gt; hal::distance_sensor::driver_read</definition>
        <argsstring>()=0</argsstring>
        <name>driver_read</name>
        <reimplementedby refid="classhal_1_1inert__distance__sensor_1a13620fe1df2e0dccfbb4f5fd19b7c859">driver_read</reimplementedby>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/include/libhal/distance_sensor.hpp" line="109" column="18"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>Linear distance hardware abstraction interface. </para>
    </briefdescription>
    <detaileddescription>
<para>Examples of distance encoder are:</para>
<para><itemizedlist>
<listitem><para>Linear Potentiometers</para>
</listitem><listitem><para>LIDAR or TOF (time of flight) sensor</para>
</listitem><listitem><para>Ultrasonic range finder</para>
</listitem><listitem><para>Infrared Distance Sensors</para>
</listitem><listitem><para>Linear Quadrature Encoders</para>
</listitem><listitem><para>Linear Incremental Encoders</para>
</listitem><listitem><para>Linear Absolute Encoders</para>
</listitem><listitem><para>Linear Magnetic Encoders</para>
</listitem></itemizedlist>
</para>
<para>Distance sensors can be relative or absolute. Relative position means that the sensor can only see changes in rotation from where measurement started. In other words, at application start, relative encoders will start at 0. Absolute encoders know their position at all times. At application start, the absolute encoder will be able to determine its exact orientation relative to a frame of reference when read.</para>
<para>Examples of relative rotation sensors are:</para>
<para><itemizedlist>
<listitem><para>Quadrature Encoders</para>
</listitem><listitem><para>Incremental Encoders</para>
</listitem></itemizedlist>
</para>
<para>Examples of absolute rotation sensors are:</para>
<para><itemizedlist>
<listitem><para>Potentiometers</para>
</listitem><listitem><para>Absolute Encoders</para>
</listitem><listitem><para>Rotary Magnetic Encoders</para>
</listitem><listitem><para>IMUs</para>
</listitem></itemizedlist>
</para>
<para>Distance sensors can also be finite or infinite. Finite meaning that the angle that can be reported is a fixed amount for the device. Infinite means that the encoder can continue rotating and adding more to its angle reading forever. Infinite rotation sensors tend to not have a physical stop that limits how much they can be rotated.</para>
<para>Examples of finite rotation sensors are:</para>
<para><itemizedlist>
<listitem><para>Potentiometers</para>
</listitem><listitem><para>Absolute Encoders</para>
</listitem><listitem><para>IMUs</para>
</listitem></itemizedlist>
</para>
<para>Examples of infinite rotation sensors are:</para>
<para><itemizedlist>
<listitem><para>Rotary Magnetic Encoders</para>
</listitem><listitem><para>Quadrature Encoders</para>
</listitem><listitem><para>Incremental Encoders</para>
</listitem></itemizedlist>
</para>
<para>This interface does not provide a means to determine these attributes of a rotation sensor as this is an application architecture decision. Drivers that implement this interface should document what kind of distance sensor it is such that a developer can determine its applicability to their application. The context of which sensor ought to be used for an application is solely known at architecture definition time and software should not be expected to at runtime, if the right type of rotation sensor was passed into the object. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="2">
        <label>hal::inert_distance_sensor</label>
        <link refid="classhal_1_1inert__distance__sensor"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="1">
        <label>hal::distance_sensor</label>
        <link refid="classhal_1_1distance__sensor"/>
      </node>
    </inheritancegraph>
    <location file="libraries/include/libhal/distance_sensor.hpp" line="80" column="1" bodyfile="libraries/include/libhal/distance_sensor.hpp" bodystart="81" bodyend="110"/>
    <listofallmembers>
      <member refid="classhal_1_1distance__sensor_1a3f392e5c9723734218b6ad429550b8ff" prot="private" virt="pure-virtual"><scope>hal::distance_sensor</scope><name>driver_read</name></member>
      <member refid="classhal_1_1distance__sensor_1ac2c8a81474ab7198ab3e7ea51aee4f47" prot="public" virt="non-virtual"><scope>hal::distance_sensor</scope><name>read</name></member>
      <member refid="classhal_1_1distance__sensor_1a6c4a9a417f9eaf6e8a6aa9f487377a39" prot="public" virt="virtual"><scope>hal::distance_sensor</scope><name>~distance_sensor</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
